<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3-4:2 Modal Resonance Framework Validation (Advanced Potential)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.7.0/math.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <style>
        body {
            font-family: 'Inter', Arial, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            margin-top: 10px;
            font-size: 1.2em;
            opacity: 0.9;
            font-weight: 300;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
        }
        h2 {
            color: #34495e;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
            margin-top: 30px;
        }
        .plot-container {
            margin: 25px 0;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding:10px;
        }
        .validation-results {
            background: #eaf2f8; /* Lighter blue */
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
            border: 1px solid #aed6f1;
        }
        .success {
            color: #27ae60; /* Green */
            font-weight: bold;
        }
        .failure {
            color: #c0392b; /* Red */
            font-weight: bold;
        }
        .formula {
            background: #ecf0f1; /* Light grey */
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
            border: 1px solid #bdc3c7;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 25px;
            margin: 25px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f8f9f9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>3-4:2 Modal Resonance Framework Validation (Advanced Potential)</h1>
            <div class="subtitle">
                Validating the Advanced Potential Framework
            </div>
        </div>
        
        <div class="validation-results">
            <h2>Mathematical Framework Reference</h2>
            <div class="formula">
                Original ψ(r,θ,φ,t) = Σ<sub>nlm</sub> A<sub>nlm</sub> j<sub>l</sub>(k<sub>n</sub>r) Y<sub>l</sub><sup>m</sup>(θ,φ) e<sup>-iωt</sup><br>
                Plots now use advanced potential P(x,y,z,t) from research paper.
            </div>
            <p>Where (for original framework):</p>
            <ul>
                <li>n = radial quantum number (1, 2, 3)</li>
                <li>l = orbital angular momentum (0 to 4)</li>
                <li>m = magnetic quantum number (-l to +l)</li>
                <li>j<sub>l</sub> = spherical Bessel function</li>
                <li>Y<sub>l</sub><sup>m</sup> = spherical harmonic</li>
            </ul>
             <p>Advanced Potential Parameters for Plots (defaults from source paper):</p>
            <ul>
                <li>Frequency: 80 Hz</li>
                <li>Mode M: 3 (corresponds to l_primary ≈ 3)</li>
                <li>Mode N: 4 (corresponds to m_primary ≈ 1, when l_primary=3)</li>
                <li>Mode P: 2 (influences ellipticalStrength)</li>
                <li>Waveform: Sine</li>
                <li>Plot Time: 0 (static snapshot)</li>
            </ul>
        </div>
        
        <div class="grid-container">
            <div id="radialPlot" class="plot-container"></div>
            <div id="ratioPlot" class="plot-container"></div>
            <div id="energyPlot" class="plot-container"></div>
            <div id="angularPlot" class="plot-container"></div>
        </div>
        
        <div class="validation-results" id="results">
            <h2>Validation Results</h2>
            <div id="testResults"></div>
        </div>
    </div>

    <script>
        // Constants from original target document
        const k0 = 1.676e-6; // Wave number (m^-1)
        const omega_const = 2 * Math.PI * 80; // 80 Hz
        const c_const = 3e8; // Speed of light

        // Constants and functions from the source paper ("advanced-elliptical-spherical-cymatics-optimized.html")
        const SIMULATION_EXTENT = 10; // As defined in the source paper
        const PLOT_TIME = 0; // Fixed time for static plots

        // Pre-computed lookup tables for performance (from source paper)
        const TRIG_TABLE_SIZE = 1024;
        const sinTable = new Float32Array(TRIG_TABLE_SIZE);
        const cosTable = new Float32Array(TRIG_TABLE_SIZE);
        
        // Initialize lookup tables (from source paper)
        for (let i = 0; i < TRIG_TABLE_SIZE; i++) {
            const angle = (i / TRIG_TABLE_SIZE) * 2 * Math.PI;
            sinTable[i] = Math.sin(angle);
            cosTable[i] = Math.cos(angle);
        }
        
        // Fast trigonometric functions using lookup tables (from source paper)
        function fastSin(x) {
            const index = Math.floor(((x % (2 * Math.PI)) / (2 * Math.PI)) * TRIG_TABLE_SIZE) & (TRIG_TABLE_SIZE - 1);
            return sinTable[index];
        }
        
        function fastCos(x) {
            const index = Math.floor(((x % (2 * Math.PI)) / (2 * Math.PI)) * TRIG_TABLE_SIZE) & (TRIG_TABLE_SIZE - 1);
            return cosTable[index];
        }

        // Optimized spherical harmonics with reduced complexity (from source paper)
        function fastSphericalYReal(l, m_signed, theta, phi) {
            // Ensure theta and phi are valid numbers
            theta = Number(theta);
            phi = Number(phi);
            if (isNaN(theta) || isNaN(phi)) return 0;

            if (l > 8) l = 8; // Limit complexity for performance
            const m_abs = Math.abs(m_signed); // Renamed to m_abs to avoid conflict
            if (m_abs > l) return 0;

            let result = 1.0;
            
            if (l === 0) return 0.282095; // Y_0^0 constant
            
            if (l === 1) {
                if (m_abs === 0) return 0.488603 * fastCos(theta);
                if (m_abs === 1) {
                    return m_signed > 0 ? 
                        0.345494 * fastSin(theta) * fastCos(phi) :
                        0.345494 * fastSin(theta) * fastSin(phi);
                }
            }
            
            if (l === 2) {
                if (m_abs === 0) return 0.315392 * (3 * fastCos(theta) * fastCos(theta) - 1);
                if (m_abs === 1) {
                    const sinTheta = fastSin(theta);
                    const cosTheta = fastCos(theta);
                    return m_signed > 0 ?
                        0.546274 * sinTheta * cosTheta * fastCos(phi) :
                        0.546274 * sinTheta * cosTheta * fastSin(phi);
                }
                if (m_abs === 2) {
                    const sinTheta = fastSin(theta);
                    return m_signed > 0 ?
                        0.273137 * sinTheta * sinTheta * fastCos(2 * phi) :
                        0.273137 * sinTheta * sinTheta * fastSin(2 * phi);
                }
            }
            
            // For higher orders, use simplified approximation
            const sinTheta = fastSin(theta);
            result = Math.pow(sinTheta, m_abs) * fastCos(l * theta + m_abs * phi); // Used m_abs for consistency
            
            return result * 0.5; // Normalize
        }
        
        // Gradient cache (from source paper, might not be heavily used for static plots without gradient)
        const GRADIENT_CACHE = new Map();
        const GRADIENT_CACHE_SIZE = 2000; // As in source
        let gradientCacheHits = 0;     // For potential diagnostics
        let gradientCacheMisses = 0;   // For potential diagnostics

        // PERFORMANCE OPTIMIZED WAVE POTENTIAL with gradient caching (from source paper)
        // Modified to take currentTime as a parameter
        function getOptimizedAdvancedWavePotential3D(x, y, z, freq_param, modeM_param, modeN_param, modeP_param, waveType_param, currentTime, computeGradient = false) {
            // Ensure numeric inputs
            x = Number(x); y = Number(y); z = Number(z); freq_param = Number(freq_param);
            modeM_param = parseInt(modeM_param); modeN_param = parseInt(modeN_param); modeP_param = parseInt(modeP_param);

            if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(freq_param) || isNaN(modeM_param) || isNaN(modeN_param) || isNaN(modeP_param)) {
                console.error("Invalid input to getOptimizedAdvancedWavePotential3D", {x,y,z,freq_param,modeM_param,modeN_param,modeP_param});
                return computeGradient ? {potential: 0, gradX: 0, gradY: 0, gradZ: 0} : 0;
            }

            const cacheX = Math.round(x * 20) / 20;
            const cacheY = Math.round(y * 20) / 20;
            const cacheZ = Math.round(z * 20) / 20;
            const cacheTime = Math.floor(currentTime / 100) * 100; 
            const cacheKey = `${cacheX},${cacheY},${cacheZ},${freq_param},${modeM_param},${modeN_param},${modeP_param},${waveType_param},${cacheTime}`;
            
            if (computeGradient && GRADIENT_CACHE.has(cacheKey)) {
                gradientCacheHits++;
                return GRADIENT_CACHE.get(cacheKey);
            }
            
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r < 1e-10) return computeGradient ? {potential: 0, gradX: 0, gradY: 0, gradZ: 0} : 0;
            
            const theta = Math.acos(Math.max(-1, Math.min(1, z / r)));
            const phi = Math.atan2(y, x);
            
            const l_primary = Math.max(0, Math.min(6, modeM_param)); 
            const m_primary_val = Math.max(-l_primary, Math.min(l_primary, modeN_param - l_primary)); // Renamed m_primary to m_primary_val
            const ellipticalStrength = parseFloat(modeP_param) * 0.08; 
            const frequencyScale = parseFloat(freq_param) * 0.01;
            
            const timePhase = currentTime * 0.001 * frequencyScale;
            
            let Y_primary_s1 = fastSphericalYReal(l_primary, m_primary_val, theta, phi + timePhase);
            
            const ellipticalFactor_s1 = 1.0 + ellipticalStrength * (
                fastSin(2 * theta) * fastCos(phi + timePhase) * 0.3 + 
                fastCos(theta) * fastSin(2 * phi + timePhase * 0.5) * 0.2
            );
            
            const normalizedR_s1 = r / (SIMULATION_EXTENT * ellipticalFactor_s1);
            const ellipticalDecay_s1 = Math.exp(-normalizedR_s1 * normalizedR_s1 * 1.5);
            
            let combinedHarmonic_s1 = Y_primary_s1 * ellipticalDecay_s1;
            
            const radialWaves_s1 = fastSin(normalizedR_s1 * Math.PI * (l_primary + 1) + timePhase);
            combinedHarmonic_s1 *= (1.0 + 0.3 * radialWaves_s1);
            
            const offsetX = SIMULATION_EXTENT * 0.3;
            const offsetY = SIMULATION_EXTENT * 0.15;
            const x2 = x - offsetX;
            const y2 = y - offsetY;
            const z2 = z;
            
            const r2 = Math.sqrt(x2*x2 + y2*y2 + z2*z2);
            let combinedHarmonic_s2 = 0;
            
            if (r2 > 1e-10) {
                const theta2 = Math.acos(Math.max(-1, Math.min(1, z2 / r2)));
                const phi2 = Math.atan2(y2, x2);
                const timePhase2 = timePhase * 0.8 + Math.PI / 4;
                
                const l_primary_s2 = Math.max(0, Math.min(6, (l_primary + 1) % 6 + 1));
                const m_primary_s2_val = Math.max(-l_primary_s2, Math.min(l_primary_s2, m_primary_val)); // Renamed
                
                let Y_primary_s2 = fastSphericalYReal(l_primary_s2, m_primary_s2_val, theta2, phi2 + timePhase2);
                
                const normalizedR_s2 = r2 / (SIMULATION_EXTENT * 0.8);
                const ellipticalDecay_s2 = Math.exp(-normalizedR_s2 * normalizedR_s2 * 1.8);
                
                combinedHarmonic_s2 = Y_primary_s2 * ellipticalDecay_s2 * 0.6;
            }
            
            let combinedVal = combinedHarmonic_s1 * 0.7 + combinedHarmonic_s2 * 0.3;
            
            const largeScale = fastSin(r / SIMULATION_EXTENT * Math.PI * 0.6 + timePhase * 0.4) * 0.1;
            combinedVal += largeScale;
            
            switch(waveType_param) {
                case 'sine': combinedVal = fastSin(combinedVal * Math.PI); break;
                case 'square': combinedVal = Math.sign(combinedVal) * Math.min(1.0, Math.abs(combinedVal) * 2.0); break;
                case 'triangle': const triVal = combinedVal * 2.0; combinedVal = 2.0 * Math.abs((triVal % 2.0) - 1.0) - 1.0; break;
                case 'sawtooth': const sawVal = combinedVal * 2.0; combinedVal = 2.0 * (sawVal - Math.floor(sawVal + 0.5)); break;
                default: combinedVal = fastSin(combinedVal * Math.PI); break;
            }
            
            const potential = isNaN(combinedVal) ? 0 : Math.max(-1.2, Math.min(1.2, combinedVal));
            
            if (!computeGradient) {
                return potential;
            }
            
            const delta = 0.05; 
            const potDx = getOptimizedAdvancedWavePotential3D(x + delta, y, z, freq_param, modeM_param, modeN_param, modeP_param, waveType_param, currentTime, false);
            const potDy = getOptimizedAdvancedWavePotential3D(x, y + delta, z, freq_param, modeM_param, modeN_param, modeP_param, waveType_param, currentTime, false);
            const potDz = getOptimizedAdvancedWavePotential3D(x, y, z + delta, freq_param, modeM_param, modeN_param, modeP_param, waveType_param, currentTime, false);
            
            const gradX = (potDx - potential) / delta;
            const gradY = (potDy - potential) / delta;
            const gradZ = (potDz - potential) / delta;
            
            const result = { potential, gradX, gradY, gradZ };
            
            gradientCacheMisses++;
            if (GRADIENT_CACHE.size >= GRADIENT_CACHE_SIZE) {
                const keys = Array.from(GRADIENT_CACHE.keys());
                for (let i = 0; i < GRADIENT_CACHE_SIZE / 4; i++) { GRADIENT_CACHE.delete(keys[i]); }
            }
            GRADIENT_CACHE.set(cacheKey, result);
            
            return result;
        }


        // --- Original functions from target document (kept for reference or other tests if needed) ---
        function sphericalBessel(n, x) {
            if (x === 0) return n === 0 ? 1 : 0;
            if (n === 0) return Math.sin(x) / x;
            if (n === 1) return Math.sin(x) / (x * x) - Math.cos(x) / x;
            if (n === 2) return (3 / (x * x) - 1) * Math.sin(x) / x - 3 * Math.cos(x) / (x * x);
            let j_n_minus_2 = Math.sin(x) / x; 
            let j_n_minus_1 = (Math.sin(x) / (x * x)) - (Math.cos(x) / x);
            if (n === 0) return j_n_minus_2;
            if (n === 1) return j_n_minus_1;
            let j_n_current;
            for (let i = 2; i <= n; i++) {
                j_n_current = (2 * i - 1) / x * j_n_minus_1 - j_n_minus_2;
                j_n_minus_2 = j_n_minus_1;
                j_n_minus_1 = j_n_current;
            }
            return j_n_current;
        }
        
        function calculateLayerRadii() {
            const R1 = Math.PI / k0;
            const R2 = Math.PI / (2 * k0);
            const R3 = Math.PI / (3 * k0);
            return [R1, R2, R3];
        }
        
        function radialWaveFunction(r, n_val) {
            const kn = n_val * k0;
            const lambdaDecay = 1e6; 
            const An = 1 / (n_val * n_val); 
            return An * sphericalBessel(n_val, kn * r) * Math.exp(-r / (lambdaDecay * n_val));
        }
        
        function totalRadialWaveFunction(r) {
            let totalPsi = 0;
            for (let n_val = 1; n_val <= 3; n_val++) {
                totalPsi += radialWaveFunction(r, n_val);
            }
            return Math.pow(Math.abs(totalPsi), 2);
        }
        
        function energyCascade(t, E0_initial, alpha) {
            const K_L3_TO_L2 = alpha * (2 * 1) ** 2; 
            const K_L2_TO_L1 = alpha * (4 * 2) ** 2; 
            const E_L3_i = E0_initial[2]; 
            const E_L2_i = E0_initial[1]; 
            const E_L1_i = E0_initial[0]; 
            const E_L3_t = E_L3_i * Math.exp(-K_L3_TO_L2 * t);
            let E_L2_t;
            if (Math.abs(K_L2_TO_L1 - K_L3_TO_L2) > 1e-9) {
                 E_L2_t = (K_L3_TO_L2 * E_L3_i / (K_L2_TO_L1 - K_L3_TO_L2)) * (Math.exp(-K_L3_TO_L2 * t) - Math.exp(-K_L2_TO_L1 * t)) +
                           E_L2_i * Math.exp(-K_L2_TO_L1 * t);
            } else { 
                 E_L2_t = (K_L3_TO_L2 * E_L3_i * t + E_L2_i) * Math.exp(-K_L2_TO_L1 * t);
            }
            const totalInitialEnergy = E_L1_i + E_L2_i + E_L3_i;
            const E_L1_t = totalInitialEnergy - E_L2_t - E_L3_t;
            return [E_L1_t, E_L2_t, E_L3_t];
        }
        // --- End of original functions ---

        // Plot radial wave function using ADVANCED POTENTIAL
        function plotRadialWaveFunction() {
            const rMaxPlot = SIMULATION_EXTENT; // Use SIMULATION_EXTENT for plot range
            const nPoints = 200; // Reduced points for faster plotting of complex function
            const r_values = [];
            const potential_values = []; // Plotting potential^2
            
            // Fixed parameters for the potential function from source paper defaults
            const plotFreq = 80;
            const plotModeM = 3;
            const plotModeN = 4;
            const plotModeP = 2;
            const plotWaveType = 'sine';

            for (let i = 0; i <= nPoints; i++) {
                const ri = (i / nPoints) * rMaxPlot;
                r_values.push(ri);
                // Calculate potential along x-axis (y=0, z=0)
                const potential = getOptimizedAdvancedWavePotential3D(ri, 0, 0, plotFreq, plotModeM, plotModeN, plotModeP, plotWaveType, PLOT_TIME, false);
                potential_values.push(Math.pow(potential, 2)); // Plotting potential squared
            }
            
            const [R1_simple, R2_simple, R3_simple] = calculateLayerRadii(); // Radii from simple model
            // Scale radii from meters (simple model) to SIMULATION_EXTENT units for comparison
            // This scaling is approximate as k0 is in m^-1 and SIMULATION_EXTENT is unitless here.
            // For visualization, we'll assume SIMULATION_EXTENT corresponds to roughly 2e6 m for node comparison.
            const rMaxOriginal = 2e6; 
            const scaleFactorForRadii = SIMULATION_EXTENT / rMaxOriginal;

            const maxPotentialSq = Math.max(...potential_values.filter(y => isFinite(y)));

            const trace = {
                x: r_values, // Already in SIMULATION_EXTENT units
                y: potential_values,
                type: 'scatter',
                mode: 'lines',
                name: '|P(r,0,0)|²', // Notation for potential along x-axis
                line: { color: '#3498db', width: 2 } 
            };
            
            const layout = {
                title: 'Advanced Potential Profile |P(r,0,0)|² (M=3,N=4,P=2, 80Hz)',
                xaxis: { title: `Radius (arbitrary units, max=${SIMULATION_EXTENT.toFixed(1)})`, zeroline: false },
                yaxis: { title: 'Potential Squared |P|²', zeroline: false, range: [0, maxPotentialSq > 0 ? maxPotentialSq * 1.1 : 1] },
                shapes: [
                    { type: 'line', x0: R1_simple * scaleFactorForRadii, x1: R1_simple * scaleFactorForRadii, y0: 0, y1: maxPotentialSq > 0 ? maxPotentialSq*1.1 : 1, line: { color: '#e74c3c', dash: 'dash', width: 1 }, label:{text:"R1 (simple)"}},
                    { type: 'line', x0: R2_simple * scaleFactorForRadii, x1: R2_simple * scaleFactorForRadii, y0: 0, y1: maxPotentialSq > 0 ? maxPotentialSq*1.1 : 1, line: { color: '#2ecc71', dash: 'dash', width: 1 }, label:{text:"R2 (simple)"}},
                    { type: 'line', x0: R3_simple * scaleFactorForRadii, x1: R3_simple * scaleFactorForRadii, y0: 0, y1: maxPotentialSq > 0 ? maxPotentialSq*1.1 : 1, line: { color: '#f39c12', dash: 'dash', width: 1 }, label:{text:"R3 (simple)"}}
                ],
                annotations: [
                    { x: R1_simple*scaleFactorForRadii, y: maxPotentialSq > 0 ? maxPotentialSq*0.95 : 0.95, text: 'R₁ (simple)', showarrow: false, font: {color: '#e74c3c', size:10} },
                    { x: R2_simple*scaleFactorForRadii, y: maxPotentialSq > 0 ? maxPotentialSq*0.85 : 0.85, text: 'R₂ (simple)', showarrow: false, font: {color: '#2ecc71', size:10} },
                    { x: R3_simple*scaleFactorForRadii, y: maxPotentialSq > 0 ? maxPotentialSq*0.75 : 0.75, text: 'R₃ (simple)', showarrow: false, font: {color: '#f39c12', size:10} }
                ],
                margin: { l: 70, r: 30, b: 50, t: 70 }
            };
            
            Plotly.newPlot('radialPlot', [trace], layout);
        }
        
        function plotScaleRatios() {
            const [R1, R2, R3] = calculateLayerRadii();
            const calculated_ratios = [R1/R2, R1/R3, R2/R3];
            const theoretical_ratios = [2.0, 3.0, 1.5];
            const labels = ['R₁/R₂', 'R₁/R₃', 'R₂/R₃'];
            const trace1 = { x: labels, y: calculated_ratios, name: 'Calculated (Simple Model)', type: 'bar', marker: { color: '#3498db' } };
            const trace2 = { x: labels, y: theoretical_ratios, name: 'Theoretical (Simple Model)', type: 'bar', marker: { color: '#f39c12' } };
            const layout = { title: 'Scale Ratio Verification (Simple Model: R<sub>n</sub>=π/nk₀)', xaxis: { title: 'Ratio Type' }, yaxis: { title: 'Value', zeroline: false }, barmode: 'group', legend: {x: 0.6, y: 1.0}, margin: { l: 60, r: 30, b: 50, t: 50 } };
            Plotly.newPlot('ratioPlot', [trace1, trace2], layout);
        }
        
        function plotEnergyCascade() {
            const tMax = 10; 
            const nPoints = 100; 
            const E0_initial_config = [0.1, 0.5, 1.0];
            const alpha_coeff = 1e-2; 
            const t_values = [];
            const E1_values = [], E2_values = [], E3_values = [];
            for (let i = 0; i <= nPoints; i++) {
                const ti = (i / nPoints) * tMax;
                t_values.push(ti);
                const [e1, e2, e3] = energyCascade(ti, E0_initial_config, alpha_coeff);
                E1_values.push(e1); E2_values.push(e2); E3_values.push(e3);
            }
            const traces = [
                { x: t_values, y: E1_values, name: 'Layer 1 (Outer)', mode: 'lines', line: { color: '#e74c3c', width: 2 } },
                { x: t_values, y: E2_values, name: 'Layer 2 (Middle)', mode: 'lines', line: { color: '#2ecc71', width: 2 } },
                { x: t_values, y: E3_values, name: 'Layer 3 (Inner)', mode: 'lines', line: { color: '#3498db', width: 2 } }
            ];
            const layout = { title: 'Energy Cascade Evolution (Conservative Model)', xaxis: { title: 'Time (arbitrary units)' }, yaxis: { title: 'Energy (arbitrary units)', zeroline: false }, legend: {x: 0.6, y: 1.0}, margin: { l: 60, r: 30, b: 50, t: 50 } };
            Plotly.newPlot('energyPlot', traces, layout);
        }
        
        // Plot angular dependence using fastSphericalYReal
        function plotAngularDependence() {
            const theta_values = [];
            const Ylm_squared_values = []; 
            const nPoints = 100;

            // Parameters from source paper defaults for M=3, N=4
            const modeM_plot = 3;
            const modeN_plot = 4;
            // Calculate l_primary and m_primary based on modeM and modeN as in getOptimizedAdvancedWavePotential3D
            const l_plot = Math.max(0, Math.min(6, modeM_plot)); 
            const m_plot = Math.max(-l_plot, Math.min(l_plot, modeN_plot - l_plot));
            const phi_fixed = 0; // Plot for a fixed azimuthal angle phi = 0

            for (let i = 0; i <= nPoints; i++) {
                const t_angle = (i / nPoints) * Math.PI; // theta from 0 to pi
                theta_values.push(t_angle);
                const ylm_val = fastSphericalYReal(l_plot, m_plot, t_angle, phi_fixed);
                Ylm_squared_values.push(Math.pow(ylm_val, 2));
            }
            
            const trace = {
                x: theta_values,
                y: Ylm_squared_values,
                type: 'scatter',
                mode: 'lines',
                name: `|Y<sub>${l_plot}</sub><sup>${m_plot}</sup>(θ,0)|²`,
                line: { color: '#8e44ad', width: 2 }
            };
            
            const layout = {
                title: `Angular Dependence |Y<sub>${l_plot}</sub><sup>${m_plot}</sup>(θ,0)|² (from M=${modeM_plot}, N=${modeN_plot})`,
                xaxis: { title: 'Polar Angle θ (radians)' },
                yaxis: { title: 'Magnitude Squared |Y<sub>lm</sub>|²', zeroline: false },
                margin: { l: 70, r: 30, b: 50, t: 70 }
            };
            
            Plotly.newPlot('angularPlot', [trace], layout);
        }
        
        function runValidationTests() {
            const validation_results_data = [];
            const [R1, R2, R3] = calculateLayerRadii();
            const ratio21 = R1 / R2; const ratio31 = R1 / R3; const ratio23 = R2 / R3;
            const tolerance = 1e-9;
            const scaleRatioTestPassed = Math.abs(ratio21 - 2.0) < tolerance && Math.abs(ratio31 - 3.0) < tolerance && Math.abs(ratio23 - 1.5) < tolerance;
            validation_results_data.push({ name: "Scale Ratio Test (Simple Model)", passed: scaleRatioTestPassed, details: `R₁/R₂ = ${ratio21.toFixed(10)} (expected 2.0)<br>R₁/R₃ = ${ratio31.toFixed(10)} (expected 3.0)<br>R₂/R₃ = ${ratio23.toFixed(10)} (expected 1.5)` });
            
            validation_results_data.push({ name: "Wave Function Visualization (Advanced Potential)", passed: true, details: `Advanced potential |P(r,0,0)|² plotted.<br>Angular part |Y<sub>lm</sub>|² for M=3,N=4 plotted.<br>Visual inspection for expected features.` });
            
            const E0_config_test = [0.1, 0.5, 1.0]; const alpha_test = 1e-2; const time_test = 10.0;
            const E_initial_total = E0_config_test.reduce((a, b) => a + b, 0);
            const [E1f, E2f, E3f] = energyCascade(time_test, E0_config_test, alpha_test);
            const E_final_total = E1f + E2f + E3f;
            const energy_drift = (E_initial_total === 0) ? (E_final_total === 0 ? 0 : Infinity) : Math.abs((E_final_total - E_initial_total) / E_initial_total);
            const energyConservationTestPassed = energy_drift < 1e-9; 
            validation_results_data.push({ name: "Energy Conservation (Cascade Model)", passed: energyConservationTestPassed, details: `Initial total energy: ${E_initial_total.toFixed(5)}<br>Final total energy: ${E_final_total.toFixed(5)}<br>Relative change: ${(energy_drift * 100).toExponential(3)}%` });
            
            const f_base = omega_const / (2 * Math.PI); const f1_layer = f_base; const f2_layer = f_base / 2; const f3_layer = f_base / 3;
            validation_results_data.push({ name: "Frequency Scaling (Conceptual, Simple Model)", passed: true, details: `Base frequency f₀: ${f_base.toFixed(1)} Hz<br>Layer (n=1 type): ${f1_layer.toFixed(1)} Hz (f₀/1)<br>Layer (n=2 type): ${f2_layer.toFixed(1)} Hz (f₀/2)<br>Layer (n=3 type): ${f3_layer.toFixed(1)} Hz (f₀/3)`});
            
            let html_output = '<table><thead><tr><th>Test Description</th><th>Status</th><th>Details</th></tr></thead><tbody>';
            validation_results_data.forEach(result => {
                const status_class = result.passed ? 'success' : 'failure';
                const status_text = result.passed ? '✓ PASSED' : '✗ FAILED';
                html_output += `<tr><td><strong>${result.name}</strong></td><td><span class="${status_class}">${status_text}</span></td><td>${result.details}</td></tr>`;
            });
            html_output += '</tbody></table>';
            const all_tests_passed = validation_results_data.every(r => r.passed);
            const overall_status_class = all_tests_passed ? 'success' : 'failure';
            const overall_status_text = all_tests_passed ? 'All Tests Passed ✓' : 'Some Tests Failed ✗';
            html_output += `<br><h3 style="text-align:center;" class="${overall_status_class}">Overall Result: ${overall_status_text}</h3>`;
            document.getElementById('testResults').innerHTML = html_output;
        }
        
        window.onload = function() {
            plotRadialWaveFunction();
            plotScaleRatios();
            plotEnergyCascade();
            plotAngularDependence();
            runValidationTests();
        };
    </script>
</body>
</html> 