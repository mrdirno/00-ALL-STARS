
// Numerical Stability Module
// Generated by Mathematical Correction Framework
// Claude-3.5-Sonnet - 2025-05-29

const NUMERICAL_STABILITY = {
    // Numerical constants
    EPSILON: 1e-15,
    SMALL_NUMBER: 1e-10,
    LARGE_NUMBER: 1e10,
    MAX_ITERATIONS: 10000,
    
    // Safe mathematical operations
    safeDivision: function(numerator, denominator, epsilon = this.EPSILON) {
        if (Math.abs(denominator) < epsilon) {
            console.warn(`Division by near-zero: ${denominator}, using regularization`);
            const sign = Math.sign(denominator) || 1;
            return numerator / (sign * epsilon);
        }
        return numerator / denominator;
    },
    
    safeSqrt: function(value, epsilon = this.EPSILON) {
        if (value < 0) {
            console.warn(`Square root of negative number: ${value}, returning 0`);
            return 0;
        }
        if (value < epsilon) {
            return Math.sqrt(epsilon);
        }
        return Math.sqrt(value);
    },
    
    safeLog: function(value, epsilon = this.EPSILON) {
        if (value <= 0) {
            console.warn(`Logarithm of non-positive number: ${value}, using epsilon`);
            return Math.log(epsilon);
        }
        return Math.log(value);
    },
    
    safeArcsin: function(value) {
        const clamped = Math.max(-1, Math.min(1, value));
        if (clamped !== value) {
            console.warn(`Arcsin input clamped from ${value} to ${clamped}`);
        }
        return Math.asin(clamped);
    },
    
    safeArccos: function(value) {
        const clamped = Math.max(-1, Math.min(1, value));
        if (clamped !== value) {
            console.warn(`Arccos input clamped from ${value} to ${clamped}`);
        }
        return Math.acos(clamped);
    },
    
    // Validation functions
    validateFinite: function(value, name = 'value') {
        if (!isFinite(value) || isNaN(value)) {
            console.error(`Invalid ${name}: ${value}`);
            return false;
        }
        return true;
    },
    
    validatePositive: function(value, name = 'value') {
        if (value <= 0) {
            console.error(`${name} must be positive: ${value}`);
            return false;
        }
        return true;
    },
    
    validateRange: function(value, min, max, name = 'value') {
        if (value < min || value > max) {
            console.error(`${name} out of range [${min}, ${max}]: ${value}`);
            return false;
        }
        return true;
    },
    
    // Edge case handling for physics simulations
    handleZeroMass: function(mass, default_mass = 1e-10) {
        if (Math.abs(mass) < this.EPSILON) {
            console.warn(`Zero mass detected, using default: ${default_mass}`);
            return default_mass;
        }
        return mass;
    },
    
    handleInfiniteVelocity: function(velocity, max_velocity = 0.1 * 299792458) {
        const speed = Math.sqrt(velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z);
        if (speed > max_velocity) {
            const scale = max_velocity / speed;
            console.warn(`Velocity clamped from ${speed} to ${max_velocity}`);
            return {
                x: velocity.x * scale,
                y: velocity.y * scale,
                z: velocity.z * scale
            };
        }
        return velocity;
    },
    
    handleNegativeEnergy: function(energy, min_energy = 0) {
        if (energy < min_energy) {
            console.warn(`Negative energy ${energy} set to minimum: ${min_energy}`);
            return min_energy;
        }
        return energy;
    },
    
    // Kahan summation for numerical stability
    kahanSum: function(values) {
        let sum = 0;
        let compensation = 0;
        
        for (let value of values) {
            const y = value - compensation;
            const t = sum + y;
            compensation = (t - sum) - y;
            sum = t;
        }
        
        return sum;
    },
    
    // Adaptive time stepping
    adaptiveTimeStep: function(current_dt, error, target_error = 1e-6, safety_factor = 0.9) {
        if (error === 0) return current_dt;
        
        const ratio = target_error / error;
        const new_dt = current_dt * safety_factor * Math.pow(ratio, 0.2);
        
        // Clamp to reasonable range
        return Math.max(1e-12, Math.min(1e-3, new_dt));
    }
};

// Export for use in simulations
if (typeof module !== 'undefined' && module.exports) {
    module.exports = NUMERICAL_STABILITY;
}
