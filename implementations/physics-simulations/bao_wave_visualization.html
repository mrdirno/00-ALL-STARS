<!DOCTYPE html>
<!--
    BAO Wave Visualization - based on origin-simple.html
    Author: Aldrin Payopay & AI Agent 1
    Date: 2025-05-28
    Description: Simplified 3D particle system visualizing Baryon Acoustic Oscillations.
                 Uses Three.js for WebGL and Tweakpane for simple controls.
    License: MIT
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BAO Wave Visualization</title>
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.10.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
            "tweakpane": "https://unpkg.com/tweakpane@4.0.3/dist/tweakpane.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: #fff; font-family: Arial, sans-serif; }
        #container { width: 100%; height: 100%; }
        .tp-dfwv { width: 300px !important; /* Tweakpane width */ }
        #paramsDisplay {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 8px;
            background: rgba(0,0,0,0.6);
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.5;
            max-width: 280px;
            word-wrap: break-word;
        }
        #paramsDisplay div { margin-bottom: 4px; }
        #paramsDisplay span { font-weight: bold; }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="paramsDisplay"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { Pane } from 'tweakpane';

        let scene, camera, renderer, particles, controls;
        let particleMaterial;
        const particleCount = 30000; 
        const boxSize = 20; // Increased box size for BAO scale

        // Parameters for BAO-like patterns
        const PARAMS = {
            baoRadius: 5.0,      // Characteristic radius of the main BAO shell (scaled to boxSize)
            numShells: 3,        // Number of visible shells
            shellThickness: 0.5, // Thickness of the attractive part of the shell
            shellSpacing: 2.5,   // Spacing between shells if numShells > 1
            potentialStrength: 1.0, // Strength of the BAO potential wells
            damping: 0.03,        // Damping factor for particle movement
            particleSize: 0.025,
            particleColor: '#44aaff',
            bgColor: '#050510',
            autoRotate: true,
            rotationSpeed: 0.0003,
            timeEvolutionSpeed: 0.5, // Speed of subtle temporal evolution of shells
            showAxes: false,
            forceStrength: 0.02, // Strength of the force attracting particles
        };

        const currentParams = { ...PARAMS };
        let velocities = new Float32Array(particleCount * 3);
        let axesHelper;
        let time = 0;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(boxSize * 0.7, boxSize * 0.5, boxSize * 1.2);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);
            renderer.setClearColor(new THREE.Color(PARAMS.bgColor));

            const particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * boxSize * 1.5; // Start slightly outside main view
                positions[i + 1] = (Math.random() - 0.5) * boxSize * 1.5;
                positions[i + 2] = (Math.random() - 0.5) * boxSize * 1.5;
                velocities[i] = (Math.random() - 0.5) * 0.005;
                velocities[i+1] = (Math.random() - 0.5) * 0.005;
                velocities[i+2] = (Math.random() - 0.5) * 0.005;
            }
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            particleMaterial = new THREE.PointsMaterial({
                size: PARAMS.particleSize,
                color: new THREE.Color(PARAMS.particleColor),
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8
            });
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 1;
            controls.maxDistance = boxSize * 3;

            axesHelper = new THREE.AxesHelper(boxSize / 2);
            axesHelper.visible = PARAMS.showAxes;
            scene.add(axesHelper);

            setupTweakpane();
            updateParamsDisplay();
            window.addEventListener('resize', onWindowResize, false);
        }

        function setupTweakpane() {
            const pane = new Pane({ title: 'BAO Parameters' });

            const baoFolder = pane.addFolder({ title: 'BAO Characteristics' });
            baoFolder.addBinding(PARAMS, 'baoRadius', { min: 1, max: boxSize * 0.8, step: 0.1, label: 'Primary Radius' });
            baoFolder.addBinding(PARAMS, 'numShells', { min: 1, max: 5, step: 1, label: 'Num Shells' });
            baoFolder.addBinding(PARAMS, 'shellThickness', { min: 0.1, max: 2.0, step: 0.05, label: 'Shell Thickness' });
            baoFolder.addBinding(PARAMS, 'shellSpacing', { min: 0.5, max: 5.0, step: 0.1, label: 'Shell Spacing' });
            baoFolder.addBinding(PARAMS, 'potentialStrength', { min: 0.1, max: 3.0, step: 0.05, label: 'Potential Strength' });
            
            const particleFolder = pane.addFolder({ title: 'Particle Behavior' });
            particleFolder.addBinding(PARAMS, 'damping', { min: 0, max: 0.1, step: 0.001 });
            particleFolder.addBinding(PARAMS, 'forceStrength', { min: 0.001, max: 0.1, step: 0.001 });
            particleFolder.addBinding(PARAMS, 'timeEvolutionSpeed', { min: 0, max: 2, step: 0.01, label: 'Evolution Speed' });

            const vis = pane.addFolder({ title: 'Visuals' });
            vis.addBinding(PARAMS, 'particleSize', { min: 0.001, max: 0.1, step: 0.001 });
            vis.addBinding(PARAMS, 'particleColor', { view: 'color' });
            vis.addBinding(PARAMS, 'bgColor', { view: 'color' }).on('change', (ev) => {
                renderer.setClearColor(new THREE.Color(ev.value));
            });

            const sceneCtrl = pane.addFolder({ title: 'Scene Control' });
            sceneCtrl.addBinding(PARAMS, 'autoRotate', { label: 'Auto Rotate' });
            sceneCtrl.addBinding(PARAMS, 'rotationSpeed', { min: 0, max: 0.005, step: 0.0001 });
            sceneCtrl.addBinding(PARAMS, 'showAxes').on('change', (ev) => {
                axesHelper.visible = ev.value;
            });

            pane.on('change', () => {
                if (particleMaterial) {
                    particleMaterial.size = PARAMS.particleSize;
                    particleMaterial.color.set(PARAMS.particleColor);
                }
                updateParamsDisplay();
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // BAO Potential Function - defines spherical shells of attraction
        // Returns a scalar value, more negative means stronger attraction (a potential well)
        function getBAOPotential3D(x, y, z, t_evo) {
            const r = Math.sqrt(x*x + y*y + z*z);
            let potential = 0;

            for (let i = 0; i < PARAMS.numShells; i++) {
                // Add subtle time evolution to shell radius or strength
                const currentRadius = PARAMS.baoRadius + i * PARAMS.shellSpacing + 
                                      Math.sin(t_evo * 0.1 + i * Math.PI / PARAMS.numShells) * 0.1; // Small ripple
                const distToShell = Math.abs(r - currentRadius);
                
                // Gaussian-like profile for the shell's attractive force
                // Sharper peak for thinner shells
                const sigma = PARAMS.shellThickness / 2.355; // FWHM to sigma approx.
                if (sigma > 1e-3) { // Avoid division by zero for very thin shells
                     potential -= PARAMS.potentialStrength * Math.exp(- (distToShell * distToShell) / (2 * sigma * sigma) );
                }
            }
            return potential;
        }

        function getForceFromBAOPotential(x, y, z, t_evo) {
            const delta = 0.01; // Small step for numerical gradient

            const pot_center = getBAOPotential3D(x, y, z, t_evo);
            const pot_dx = getBAOPotential3D(x + delta, y, z, t_evo);
            const pot_dy = getBAOPotential3D(x, y + delta, z, t_evo);
            const pot_dz = getBAOPotential3D(x, y, z + delta, t_evo);

            // Force is the negative gradient of the potential
            const fx = -(pot_dx - pot_center) / delta;
            const fy = -(pot_dy - pot_center) / delta;
            const fz = -(pot_dz - pot_center) / delta;
            
            return new THREE.Vector3(fx, fy, fz);
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016 * PARAMS.timeEvolutionSpeed; 

            const positions = particles.geometry.attributes.position.array;
            const damping = PARAMS.damping;
            const forceStrength = PARAMS.forceStrength;

            for (let i = 0; i < particleCount; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let x = positions[ix];
                let y = positions[iy];
                let z = positions[iz];

                const force = getForceFromBAOPotential(x, y, z, time);

                velocities[ix] += force.x * forceStrength;
                velocities[iy] += force.y * forceStrength;
                velocities[iz] += force.z * forceStrength;

                velocities[ix] *= (1 - damping);
                velocities[iy] *= (1 - damping);
                velocities[iz] *= (1 - damping);

                positions[ix] += velocities[ix];
                positions[iy] += velocities[iy];
                positions[iz] += velocities[iz];

                // Boundary conditions: Soft reflection or containment
                const halfBox = boxSize / 2;
                const boundaryStrength = 0.1; // How strongly they are pushed back

                if (positions[ix] > halfBox) { velocities[ix] -= (positions[ix] - halfBox) * boundaryStrength; }
                if (positions[ix] < -halfBox) { velocities[ix] -= (positions[ix] + halfBox) * boundaryStrength; }
                if (positions[iy] > halfBox) { velocities[iy] -= (positions[iy] - halfBox) * boundaryStrength; }
                if (positions[iy] < -halfBox) { velocities[iy] -= (positions[iy] + halfBox) * boundaryStrength; }
                if (positions[iz] > halfBox) { velocities[iz] -= (positions[iz] - halfBox) * boundaryStrength; }
                if (positions[iz] < -halfBox) { velocities[iz] -= (positions[iz] + halfBox) * boundaryStrength; }
            }

            particles.geometry.attributes.position.needsUpdate = true;

            if (PARAMS.autoRotate) {
                const scaledRotationSpeed = PARAMS.rotationSpeed;
                scene.rotation.y += scaledRotationSpeed;
                scene.rotation.x += scaledRotationSpeed * 0.3; // Slightly different rotation on x
            }

            controls.update();
            renderer.render(scene, camera);
        }

        function updateParamsDisplay() {
            const display = document.getElementById('paramsDisplay');
            currentParams.baoRadius = PARAMS.baoRadius;
            currentParams.numShells = PARAMS.numShells;
            currentParams.shellThickness = PARAMS.shellThickness;
            currentParams.shellSpacing = PARAMS.shellSpacing;
            currentParams.potentialStrength = PARAMS.potentialStrength;
            currentParams.damping = PARAMS.damping;
            currentParams.particleSize = PARAMS.particleSize;
            currentParams.particleColor = PARAMS.particleColor;
            currentParams.bgColor = PARAMS.bgColor;
            currentParams.autoRotate = PARAMS.autoRotate;
            currentParams.rotationSpeed = PARAMS.rotationSpeed;
            currentParams.timeEvolutionSpeed = PARAMS.timeEvolutionSpeed;
            currentParams.showAxes = PARAMS.showAxes;
            currentParams.forceStrength = PARAMS.forceStrength;
            
            let html = `<div><span>Particles:</span> ${particleCount.toLocaleString()}</div>`;
            html += `<div><span>Box Size:</span> ${boxSize.toFixed(1)}</div>`;
            for (const key in currentParams) {
                let value = currentParams[key];
                if (typeof value === 'number') value = value.toFixed(3);
                if (typeof value === 'boolean') value = value ? 'On' : 'Off';
                html += `<div><span>${key.charAt(0).toUpperCase() + key.slice(1)}:</span> ${value}</div>`;
            }
            display.innerHTML = html;
        }

        init();
        animate();
    </script>
</body>
</html> 