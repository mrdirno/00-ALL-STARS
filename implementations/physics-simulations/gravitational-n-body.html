<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gravitational N-Body Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            max-width: 250px;
        }
        
        .control-group {
            margin-bottom: 8px;
        }
        
        label {
            display: inline-block;
            width: 100px;
            font-size: 11px;
        }
        
        input[type="range"] {
            width: 120px;
        }
        
        input[type="number"] {
            width: 60px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 2px;
            font-size: 11px;
        }
        
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 4px 8px;
            cursor: pointer;
            margin: 2px;
            font-size: 11px;
        }
        
        button:hover {
            background: #555;
        }
        
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 11px;
            max-width: 280px;
        }
        
        .equation {
            background: #111;
            padding: 4px;
            margin: 4px 0;
            border-left: 2px solid #0ff;
            font-family: 'Times New Roman', serif;
            font-size: 10px;
        }
        
        .preset-button {
            background: #444;
            margin: 1px;
            padding: 3px 6px;
            font-size: 10px;
        }
        
        .preset-button:hover {
            background: #666;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <h3>N-Body Gravity Simulation</h3>
            
            <div class="control-group">
                <label>Bodies:</label>
                <input type="number" id="numBodies" value="4" min="2" max="20">
                <button onclick="resetSimulation()">Reset</button>
            </div>
            
            <div class="control-group">
                <label>G Constant:</label>
                <input type="number" id="gravityConstant" value="100" step="10" min="1" max="1000">
            </div>
            
            <div class="control-group">
                <label>Time Scale:</label>
                <input type="range" id="timeScale" min="0.1" max="3.0" step="0.1" value="1.0">
                <span id="timeScaleValue">1.0</span>
            </div>
            
            <div class="control-group">
                <label>Softening:</label>
                <input type="range" id="softening" min="1" max="20" step="1" value="5">
                <span id="softeningValue">5</span>
            </div>
            
            <div class="control-group">
                <button onclick="togglePause()">Pause/Resume</button>
                <button onclick="toggleTrails()">Toggle Trails</button>
            </div>
            
            <div class="control-group">
                <button onclick="toggleVectors()">Toggle Vectors</button>
                <button onclick="centerOfMass()">Center View</button>
            </div>
            
            <h4>Presets:</h4>
            <div class="control-group">
                <button class="preset-button" onclick="loadPreset('binary')">Binary Star</button>
                <button class="preset-button" onclick="loadPreset('triple')">Triple System</button>
                <button class="preset-button" onclick="loadPreset('solar')">Solar System</button>
                <button class="preset-button" onclick="loadPreset('cluster')">Star Cluster</button>
            </div>
        </div>
        
        <div id="info">
            <h4>Physics Information</h4>
            <div class="equation">
                <strong>Newton's Law of Gravitation:</strong><br>
                F = G(m₁m₂)/r²
            </div>
            <div class="equation">
                <strong>Force Vector:</strong><br>
                F⃗ = G(m₁m₂)/r³ · r⃗
            </div>
            <div class="equation">
                <strong>Acceleration:</strong><br>
                a⃗ = F⃗/m = Σ(Gm_j/r³_ij) · r⃗_ij
            </div>
            
            <div id="realTimeData">
                <h4>System Data</h4>
                <div>Time: <span id="timeDisplay">0.00</span> s</div>
                <div>Total Mass: <span id="totalMass">0</span> kg</div>
                <div>Total Energy: <span id="totalEnergy">0</span> J</div>
                <div>Kinetic Energy: <span id="kineticEnergy">0</span> J</div>
                <div>Potential Energy: <span id="potentialEnergy">0</span> J</div>
                <div>Center of Mass: (<span id="comX">0</span>, <span id="comY">0</span>)</div>
                <div>Angular Momentum: <span id="angularMomentum">0</span></div>
            </div>
            
            <div id="instructions">
                <h4>Controls</h4>
                <div>• Mouse: Pan view</div>
                <div>• Wheel: Zoom</div>
                <div>• Click body: Select/info</div>
                <div>• Drag: Add velocity</div>
            </div>
        </div>
    </div>

    <script>
        // Physics constants and variables
        let canvas, ctx;
        let animationId;
        let isPaused = false;
        let showTrails = true;
        let showVectors = false;
        let time = 0;
        let dt = 0.016; // 60 FPS
        
        // Simulation parameters
        let G = 100; // Gravitational constant (scaled for visualization)
        let softening = 5; // Softening parameter to prevent singularities
        
        // Bodies array
        let bodies = [];
        
        // Camera and rendering
        let camera = {
            x: 0, y: 0,
            zoom: 1.0
        };
        
        let selectedBody = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        
        // Initialize simulation
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupMouseControls();
            setupControls();
            
            // Start with binary star system
            loadPreset('binary');
            animate();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function setupMouseControls() {
            let mouseDown = false;
            let lastMouseX, lastMouseY;
            
            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                // Check if clicking on a body
                const mousePos = screenToWorld(e.clientX, e.clientY);
                selectedBody = findBodyAt(mousePos.x, mousePos.y);
                
                if (selectedBody) {
                    isDragging = true;
                    dragStart = { x: mousePos.x, y: mousePos.y };
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (mouseDown && !isDragging) {
                    // Pan camera
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    camera.x -= deltaX / camera.zoom;
                    camera.y -= deltaY / camera.zoom;
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (isDragging && selectedBody) {
                    // Add velocity based on drag
                    const mousePos = screenToWorld(e.clientX, e.clientY);
                    const deltaX = mousePos.x - dragStart.x;
                    const deltaY = mousePos.y - dragStart.y;
                    
                    selectedBody.vx += deltaX * 0.01;
                    selectedBody.vy += deltaY * 0.01;
                }
                
                mouseDown = false;
                isDragging = false;
                selectedBody = null;
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = 1 - e.deltaY * 0.001;
                camera.zoom *= zoomFactor;
                camera.zoom = Math.max(0.1, Math.min(5.0, camera.zoom));
            });
        }
        
        function setupControls() {
            document.getElementById('timeScale').addEventListener('input', (e) => {
                document.getElementById('timeScaleValue').textContent = e.target.value;
            });
            
            document.getElementById('softening').addEventListener('input', (e) => {
                softening = parseFloat(e.target.value);
                document.getElementById('softeningValue').textContent = e.target.value;
            });
            
            document.getElementById('gravityConstant').addEventListener('input', (e) => {
                G = parseFloat(e.target.value);
            });
        }
        
        function screenToWorld(screenX, screenY) {
            return {
                x: (screenX - canvas.width/2) / camera.zoom + camera.x,
                y: (screenY - canvas.height/2) / camera.zoom + camera.y
            };
        }
        
        function worldToScreen(worldX, worldY) {
            return {
                x: (worldX - camera.x) * camera.zoom + canvas.width/2,
                y: (worldY - camera.y) * camera.zoom + canvas.height/2
            };
        }
        
        function findBodyAt(x, y) {
            for (let body of bodies) {
                const dx = x - body.x;
                const dy = y - body.y;
                const distance = Math.sqrt(dx*dx + dy*dy);
                if (distance < body.radius + 10) {
                    return body;
                }
            }
            return null;
        }
        
        function createBody(x, y, vx, vy, mass, color) {
            return {
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                mass: mass,
                radius: Math.max(3, Math.sqrt(mass) * 0.5),
                color: color || '#ffffff',
                trail: []
            };
        }
        
        function loadPreset(preset) {
            bodies = [];
            time = 0;
            
            switch(preset) {
                case 'binary':
                    bodies.push(createBody(-100, 0, 0, 2, 100, '#ffff00'));
                    bodies.push(createBody(100, 0, 0, -2, 100, '#ff8800'));
                    break;
                    
                case 'triple':
                    bodies.push(createBody(-80, 0, 0, 1.5, 80, '#ffff00'));
                    bodies.push(createBody(80, 0, 0, -1.5, 80, '#ff8800'));
                    bodies.push(createBody(0, 120, -2, 0, 60, '#ff0088'));
                    break;
                    
                case 'solar':
                    // Central star
                    bodies.push(createBody(0, 0, 0, 0, 200, '#ffff00'));
                    // Planets
                    bodies.push(createBody(80, 0, 0, 3.5, 10, '#8888ff'));
                    bodies.push(createBody(120, 0, 0, 2.8, 15, '#ff8888'));
                    bodies.push(createBody(160, 0, 0, 2.3, 12, '#88ff88'));
                    bodies.push(createBody(220, 0, 0, 1.8, 8, '#ffaa88'));
                    break;
                    
                case 'cluster':
                    const numBodies = 8;
                    for (let i = 0; i < numBodies; i++) {
                        const angle = (i / numBodies) * 2 * Math.PI;
                        const radius = 80 + Math.random() * 40;
                        const x = Math.cos(angle) * radius;
                        const y = Math.sin(angle) * radius;
                        const vx = -Math.sin(angle) * 1.5 + (Math.random() - 0.5) * 0.5;
                        const vy = Math.cos(angle) * 1.5 + (Math.random() - 0.5) * 0.5;
                        const mass = 30 + Math.random() * 40;
                        const hue = (i / numBodies) * 360;
                        const color = `hsl(${hue}, 80%, 60%)`;
                        bodies.push(createBody(x, y, vx, vy, mass, color));
                    }
                    break;
            }
            
            document.getElementById('numBodies').value = bodies.length;
        }
        
        function resetSimulation() {
            const numBodies = parseInt(document.getElementById('numBodies').value);
            bodies = [];
            time = 0;
            
            // Create random configuration
            for (let i = 0; i < numBodies; i++) {
                const angle = Math.random() * 2 * Math.PI;
                const radius = 50 + Math.random() * 100;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                const vx = (Math.random() - 0.5) * 2;
                const vy = (Math.random() - 0.5) * 2;
                const mass = 20 + Math.random() * 80;
                const hue = Math.random() * 360;
                const color = `hsl(${hue}, 70%, 60%)`;
                bodies.push(createBody(x, y, vx, vy, mass, color));
            }
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        function toggleTrails() {
            showTrails = !showTrails;
            if (!showTrails) {
                bodies.forEach(body => body.trail = []);
            }
        }
        
        function toggleVectors() {
            showVectors = !showVectors;
        }
        
        function centerOfMass() {
            let totalMass = 0;
            let comX = 0, comY = 0;
            
            for (let body of bodies) {
                totalMass += body.mass;
                comX += body.x * body.mass;
                comY += body.y * body.mass;
            }
            
            if (totalMass > 0) {
                comX /= totalMass;
                comY /= totalMass;
                camera.x = comX;
                camera.y = comY;
            }
        }
        
        // Physics simulation using Leapfrog integration
        function updatePhysics() {
            if (isPaused) return;
            
            G = parseFloat(document.getElementById('gravityConstant').value);
            const timeScale = parseFloat(document.getElementById('timeScale').value);
            const effectiveDt = dt * timeScale;
            
            // Calculate forces and accelerations
            for (let i = 0; i < bodies.length; i++) {
                let fx = 0, fy = 0;
                
                for (let j = 0; j < bodies.length; j++) {
                    if (i !== j) {
                        const dx = bodies[j].x - bodies[i].x;
                        const dy = bodies[j].y - bodies[i].y;
                        const r2 = dx*dx + dy*dy + softening*softening; // Softening prevents singularities
                        const r = Math.sqrt(r2);
                        const r3 = r2 * r;
                        
                        // F = G * m1 * m2 / r^2, direction = r_hat
                        const force = G * bodies[i].mass * bodies[j].mass / r2;
                        fx += force * dx / r;
                        fy += force * dy / r;
                    }
                }
                
                // Update velocity: v = v + a*dt
                bodies[i].vx += (fx / bodies[i].mass) * effectiveDt;
                bodies[i].vy += (fy / bodies[i].mass) * effectiveDt;
            }
            
            // Update positions: x = x + v*dt
            for (let body of bodies) {
                body.x += body.vx * effectiveDt;
                body.y += body.vy * effectiveDt;
                
                // Add to trail
                if (showTrails && body.trail.length < 500) {
                    body.trail.push({ x: body.x, y: body.y });
                }
            }
            
            time += effectiveDt;
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw trails
            if (showTrails) {
                drawTrails();
            }
            
            // Draw bodies
            drawBodies();
            
            // Draw vectors if enabled
            if (showVectors) {
                drawVectors();
            }
            
            // Draw drag line
            if (isDragging && selectedBody) {
                drawDragLine();
            }
            
            // Update display
            updateDisplay();
        }
        
        function drawTrails() {
            for (let body of bodies) {
                if (body.trail.length > 1) {
                    ctx.strokeStyle = body.color;
                    ctx.globalAlpha = 0.3;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    
                    for (let i = 0; i < body.trail.length; i++) {
                        const pos = worldToScreen(body.trail[i].x, body.trail[i].y);
                        if (i === 0) {
                            ctx.moveTo(pos.x, pos.y);
                        } else {
                            ctx.lineTo(pos.x, pos.y);
                        }
                    }
                    
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                }
            }
        }
        
        function drawBodies() {
            for (let body of bodies) {
                const pos = worldToScreen(body.x, body.y);
                const radius = body.radius * camera.zoom;
                
                // Draw body
                const gradient = ctx.createRadialGradient(
                    pos.x - radius/3, pos.y - radius/3, 0,
                    pos.x, pos.y, radius
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(1, body.color);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // Highlight selected body
                if (body === selectedBody) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + 5, 0, 2 * Math.PI);
                    ctx.stroke();
                }
                
                // Draw mass label
                ctx.fillStyle = '#ffffff';
                ctx.font = '10px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText(body.mass.toFixed(0), pos.x, pos.y + radius + 15);
            }
        }
        
        function drawVectors() {
            for (let body of bodies) {
                const pos = worldToScreen(body.x, body.y);
                const velScale = 10;
                const velEnd = worldToScreen(
                    body.x + body.vx * velScale,
                    body.y + body.vy * velScale
                );
                
                // Velocity vector
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.lineTo(velEnd.x, velEnd.y);
                ctx.stroke();
                
                // Arrow head
                const angle = Math.atan2(velEnd.y - pos.y, velEnd.x - pos.x);
                const arrowLength = 8;
                ctx.beginPath();
                ctx.moveTo(velEnd.x, velEnd.y);
                ctx.lineTo(velEnd.x - arrowLength * Math.cos(angle - 0.3), velEnd.y - arrowLength * Math.sin(angle - 0.3));
                ctx.moveTo(velEnd.x, velEnd.y);
                ctx.lineTo(velEnd.x - arrowLength * Math.cos(angle + 0.3), velEnd.y - arrowLength * Math.sin(angle + 0.3));
                ctx.stroke();
            }
        }
        
        function drawDragLine() {
            const bodyPos = worldToScreen(selectedBody.x, selectedBody.y);
            const mousePos = worldToScreen(dragStart.x, dragStart.y);
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(bodyPos.x, bodyPos.y);
            ctx.lineTo(mousePos.x, mousePos.y);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function updateDisplay() {
            // Calculate system properties
            let totalMass = 0;
            let kineticEnergy = 0;
            let potentialEnergy = 0;
            let comX = 0, comY = 0;
            let angularMomentum = 0;
            
            // Calculate center of mass and kinetic energy
            for (let body of bodies) {
                totalMass += body.mass;
                comX += body.x * body.mass;
                comY += body.y * body.mass;
                kineticEnergy += 0.5 * body.mass * (body.vx*body.vx + body.vy*body.vy);
                
                // Angular momentum about center of mass
                angularMomentum += body.mass * (body.x * body.vy - body.y * body.vx);
            }
            
            comX /= totalMass;
            comY /= totalMass;
            
            // Calculate potential energy
            for (let i = 0; i < bodies.length; i++) {
                for (let j = i + 1; j < bodies.length; j++) {
                    const dx = bodies[j].x - bodies[i].x;
                    const dy = bodies[j].y - bodies[i].y;
                    const r = Math.sqrt(dx*dx + dy*dy);
                    potentialEnergy -= G * bodies[i].mass * bodies[j].mass / r;
                }
            }
            
            const totalEnergy = kineticEnergy + potentialEnergy;
            
            // Update display
            document.getElementById('timeDisplay').textContent = time.toFixed(2);
            document.getElementById('totalMass').textContent = totalMass.toFixed(1);
            document.getElementById('totalEnergy').textContent = totalEnergy.toFixed(2);
            document.getElementById('kineticEnergy').textContent = kineticEnergy.toFixed(2);
            document.getElementById('potentialEnergy').textContent = potentialEnergy.toFixed(2);
            document.getElementById('comX').textContent = comX.toFixed(1);
            document.getElementById('comY').textContent = comY.toFixed(1);
            document.getElementById('angularMomentum').textContent = angularMomentum.toFixed(2);
        }
        
        function animate() {
            updatePhysics();
            render();
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 