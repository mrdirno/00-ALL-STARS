<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced WebGL Physics Visualizer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Courier New', monospace;
            color: #00ff00;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ff00;
            max-width: 300px;
            z-index: 100;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #00ff00;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        
        select, button {
            width: 100%;
            padding: 5px;
            background: #001100;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 3px;
            margin-bottom: 5px;
        }
        
        button:hover {
            background: #002200;
        }
        
        #performance {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #00ff00;
            font-size: 12px;
            z-index: 100;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #00ff00;
            font-size: 11px;
            max-width: 400px;
            z-index: 100;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <h3>Advanced Physics Visualizer</h3>
            
            <div class="control-group">
                <label>Simulation Type:</label>
                <select id="simulationType">
                    <option value="quantum_field">Quantum Field Dynamics</option>
                    <option value="gravitational_waves">Gravitational Wave Propagation</option>
                    <option value="plasma_physics">Plasma Physics Simulation</option>
                    <option value="fluid_dynamics">Computational Fluid Dynamics</option>
                    <option value="electromagnetic">Electromagnetic Field Visualization</option>
                    <option value="particle_collision">High-Energy Particle Collision</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Particle Count: <span id="particleCountValue">50000</span></label>
                <input type="range" id="particleCount" min="1000" max="200000" value="50000" step="1000">
            </div>
            
            <div class="control-group">
                <label>Field Strength: <span id="fieldStrengthValue">1.0</span></label>
                <input type="range" id="fieldStrength" min="0.1" max="5.0" value="1.0" step="0.1">
            </div>
            
            <div class="control-group">
                <label>Time Scale: <span id="timeScaleValue">1.0</span></label>
                <input type="range" id="timeScale" min="0.1" max="10.0" value="1.0" step="0.1">
            </div>
            
            <div class="control-group">
                <label>Visualization Mode:</label>
                <select id="visualMode">
                    <option value="particles">Particle View</option>
                    <option value="field_lines">Field Lines</option>
                    <option value="density_map">Density Mapping</option>
                    <option value="energy_flow">Energy Flow</option>
                    <option value="phase_space">Phase Space</option>
                    <option value="spectral">Spectral Analysis</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="togglePause">Pause/Resume</button>
                <button id="resetSim">Reset Simulation</button>
                <button id="exportData">Export Data</button>
                <button id="toggleVR" class="hidden">Enter VR Mode</button>
            </div>
        </div>
        
        <div id="performance">
            <div>FPS: <span id="fps">60</span></div>
            <div>Particles: <span id="activeParticles">50000</span></div>
            <div>GPU Memory: <span id="gpuMemory">0</span> MB</div>
            <div>Compute Time: <span id="computeTime">0</span> ms</div>
            <div>Energy Conservation: <span id="energyConservation">100.0</span>%</div>
        </div>
        
        <div id="info">
            <strong>Advanced WebGL Physics Visualizer</strong><br>
            Real-time physics simulation using WebGL compute shaders and advanced rendering techniques.<br>
            <em>Scientific Methods Applied:</em> Variational Principles (#35), Operational Measurement (#21), Conservation Principles (#8)<br>
            <em>Features:</em> Multi-dimensional visualization, energy conservation monitoring, VR/AR ready
        </div>
    </div>

    <script>
        // Advanced WebGL Physics Visualizer Implementation
        class AdvancedPhysicsVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                this.programs = {};
                this.buffers = {};
                this.textures = {};
                this.framebuffers = {};
                
                // Simulation state
                this.particleCount = 50000;
                this.currentSimulation = 'quantum_field';
                this.isPaused = false;
                this.time = 0;
                this.deltaTime = 0;
                this.lastTime = 0;
                
                // Performance monitoring
                this.frameCount = 0;
                this.lastFPSUpdate = 0;
                this.currentFPS = 60;
                this.computeStartTime = 0;
                this.computeTime = 0;
                
                // Physics parameters
                this.fieldStrength = 1.0;
                this.timeScale = 1.0;
                this.visualMode = 'particles';
                
                // Energy conservation tracking
                this.totalEnergy = 0;
                this.initialEnergy = 0;
                this.energyHistory = [];
                
                this.init();
            }
            
            init() {
                this.setupWebGL();
                this.createShaders();
                this.createBuffers();
                this.setupEventListeners();
                this.initializeSimulation();
                this.animate();
            }
            
            setupWebGL() {
                // Get WebGL2 context with required extensions
                this.gl = this.canvas.getContext('webgl2', {
                    antialias: true,
                    alpha: false,
                    depth: true,
                    stencil: false,
                    preserveDrawingBuffer: false,
                    powerPreference: 'high-performance'
                });
                
                if (!this.gl) {
                    throw new Error('WebGL2 not supported');
                }
                
                // Enable required extensions
                const ext = this.gl.getExtension('EXT_color_buffer_float');
                if (!ext) {
                    console.warn('EXT_color_buffer_float not supported - using fallback');
                }
                
                // Set up WebGL state
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.enable(this.gl.BLEND);
                this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                const displayWidth = this.canvas.clientWidth;
                const displayHeight = this.canvas.clientHeight;
                
                if (this.canvas.width !== displayWidth || this.canvas.height !== displayHeight) {
                    this.canvas.width = displayWidth;
                    this.canvas.height = displayHeight;
                    this.gl.viewport(0, 0, displayWidth, displayHeight);
                }
            }
            
            createShaders() {
                // Vertex shader for particle rendering
                const particleVertexShader = `#version 300 es
                    precision highp float;
                    
                    layout(location = 0) in vec3 position;
                    layout(location = 1) in vec3 velocity;
                    layout(location = 2) in float mass;
                    layout(location = 3) in float charge;
                    
                    uniform mat4 uProjectionMatrix;
                    uniform mat4 uViewMatrix;
                    uniform float uTime;
                    uniform float uPointSize;
                    
                    out vec3 vVelocity;
                    out float vMass;
                    out float vCharge;
                    out float vSpeed;
                    
                    void main() {
                        vVelocity = velocity;
                        vMass = mass;
                        vCharge = charge;
                        vSpeed = length(velocity);
                        
                        gl_Position = uProjectionMatrix * uViewMatrix * vec4(position, 1.0);
                        gl_PointSize = uPointSize * (1.0 + vSpeed * 0.5);
                    }
                `;
                
                // Fragment shader for particle rendering
                const particleFragmentShader = `#version 300 es
                    precision highp float;
                    
                    in vec3 vVelocity;
                    in float vMass;
                    in float vCharge;
                    in float vSpeed;
                    
                    out vec4 fragColor;
                    
                    void main() {
                        vec2 coord = gl_PointCoord - 0.5;
                        float dist = length(coord);
                        
                        if (dist > 0.5) discard;
                        
                        // Color based on charge and speed
                        vec3 color = vec3(0.0);
                        if (vCharge > 0.0) {
                            color = vec3(1.0, 0.3, 0.3); // Positive charge - red
                        } else if (vCharge < 0.0) {
                            color = vec3(0.3, 0.3, 1.0); // Negative charge - blue
                        } else {
                            color = vec3(0.3, 1.0, 0.3); // Neutral - green
                        }
                        
                        // Intensity based on speed
                        float intensity = 0.5 + 0.5 * (vSpeed / 10.0);
                        color *= intensity;
                        
                        // Circular particle with soft edges
                        float alpha = 1.0 - smoothstep(0.3, 0.5, dist);
                        
                        fragColor = vec4(color, alpha);
                    }
                `;
                
                // Compute shader for physics simulation
                const computeShader = `#version 300 es
                    precision highp float;
                    
                    layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
                    
                    layout(std430, binding = 0) buffer PositionBuffer {
                        vec4 positions[];
                    };
                    
                    layout(std430, binding = 1) buffer VelocityBuffer {
                        vec4 velocities[];
                    };
                    
                    layout(std430, binding = 2) buffer PropertiesBuffer {
                        vec4 properties[]; // mass, charge, energy, potential
                    };
                    
                    uniform float uDeltaTime;
                    uniform float uFieldStrength;
                    uniform int uSimulationType;
                    uniform float uTime;
                    uniform int uParticleCount;
                    
                    // Constants
                    const float G = 6.67430e-11;
                    const float k_e = 8.9875517923e9;
                    const float c = 299792458.0;
                    const float hbar = 1.054571817e-34;
                    
                    vec3 calculateQuantumFieldForce(uint index, vec3 pos, vec3 vel) {
                        vec3 force = vec3(0.0);
                        
                        // Quantum field fluctuations
                        float phase = uTime * 0.1 + float(index) * 0.01;
                        vec3 fieldGradient = vec3(
                            sin(phase + pos.x * 10.0),
                            cos(phase + pos.y * 10.0),
                            sin(phase + pos.z * 10.0)
                        );
                        
                        force += fieldGradient * uFieldStrength * 0.001;
                        
                        // Harmonic oscillator potential
                        force -= pos * 0.1;
                        
                        return force;
                    }
                    
                    vec3 calculateGravitationalWaveForce(uint index, vec3 pos, vec3 vel) {
                        vec3 force = vec3(0.0);
                        
                        // Gravitational wave propagation
                        float wavePhase = uTime * c * 0.0001 - length(pos) * 0.1;
                        float amplitude = uFieldStrength * 0.01;
                        
                        // Strain tensor effects
                        mat3 strain = mat3(
                            amplitude * cos(wavePhase), amplitude * sin(wavePhase), 0.0,
                            amplitude * sin(wavePhase), -amplitude * cos(wavePhase), 0.0,
                            0.0, 0.0, 0.0
                        );
                        
                        force = strain * pos * 0.001;
                        
                        return force;
                    }
                    
                    vec3 calculatePlasmaForce(uint index, vec3 pos, vec3 vel) {
                        vec3 force = vec3(0.0);
                        float charge = properties[index].y;
                        
                        // Electromagnetic forces
                        vec3 E = vec3(0.0, 0.0, uFieldStrength);
                        vec3 B = vec3(0.0, uFieldStrength * 0.1, 0.0);
                        
                        // Lorentz force: F = q(E + v Ã— B)
                        force += charge * (E + cross(vel, B));
                        
                        // Plasma oscillations
                        float plasmaFreq = sqrt(charge * charge / properties[index].x) * 0.1;
                        force += vec3(
                            sin(uTime * plasmaFreq + pos.x),
                            cos(uTime * plasmaFreq + pos.y),
                            sin(uTime * plasmaFreq + pos.z)
                        ) * 0.001;
                        
                        return force;
                    }
                    
                    void main() {
                        uint index = gl_GlobalInvocationID.x;
                        if (index >= uint(uParticleCount)) return;
                        
                        vec3 pos = positions[index].xyz;
                        vec3 vel = velocities[index].xyz;
                        float mass = properties[index].x;
                        float charge = properties[index].y;
                        
                        vec3 force = vec3(0.0);
                        
                        // Calculate forces based on simulation type
                        if (uSimulationType == 0) { // Quantum field
                            force = calculateQuantumFieldForce(index, pos, vel);
                        } else if (uSimulationType == 1) { // Gravitational waves
                            force = calculateGravitationalWaveForce(index, pos, vel);
                        } else if (uSimulationType == 2) { // Plasma physics
                            force = calculatePlasmaForce(index, pos, vel);
                        }
                        
                        // Numerical integration using Verlet method
                        vec3 acceleration = force / mass;
                        
                        // Update position and velocity
                        vec3 newPos = pos + vel * uDeltaTime + 0.5 * acceleration * uDeltaTime * uDeltaTime;
                        vec3 newVel = vel + acceleration * uDeltaTime;
                        
                        // Boundary conditions
                        float boundarySize = 10.0;
                        if (abs(newPos.x) > boundarySize) {
                            newPos.x = sign(newPos.x) * boundarySize;
                            newVel.x *= -0.8; // Energy loss on collision
                        }
                        if (abs(newPos.y) > boundarySize) {
                            newPos.y = sign(newPos.y) * boundarySize;
                            newVel.y *= -0.8;
                        }
                        if (abs(newPos.z) > boundarySize) {
                            newPos.z = sign(newPos.z) * boundarySize;
                            newVel.z *= -0.8;
                        }
                        
                        // Calculate energy for conservation monitoring
                        float kineticEnergy = 0.5 * mass * dot(newVel, newVel);
                        float potentialEnergy = 0.5 * mass * dot(newPos, newPos) * 0.1; // Harmonic potential
                        
                        // Update buffers
                        positions[index] = vec4(newPos, 1.0);
                        velocities[index] = vec4(newVel, 0.0);
                        properties[index].z = kineticEnergy + potentialEnergy; // Total energy
                    }
                `;
                
                // Create and compile shaders
                this.programs.particle = this.createProgram(particleVertexShader, particleFragmentShader);
                this.programs.compute = this.createComputeProgram(computeShader);
            }
            
            createProgram(vertexSource, fragmentSource) {
                const gl = this.gl;
                
                const vertexShader = this.compileShader(gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.compileShader(gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Program link error: ' + gl.getProgramInfoLog(program));
                }
                
                return program;
            }
            
            createComputeProgram(computeSource) {
                const gl = this.gl;
                
                const computeShader = this.compileShader(gl.COMPUTE_SHADER, computeSource);
                
                const program = gl.createProgram();
                gl.attachShader(program, computeShader);
                gl.linkProgram(program);
                
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    throw new Error('Compute program link error: ' + gl.getProgramInfoLog(program));
                }
                
                return program;
            }
            
            compileShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    throw new Error('Shader compile error: ' + gl.getShaderInfoLog(shader));
                }
                
                return shader;
            }
            
            createBuffers() {
                const gl = this.gl;
                
                // Create particle data
                const positions = new Float32Array(this.particleCount * 4);
                const velocities = new Float32Array(this.particleCount * 4);
                const properties = new Float32Array(this.particleCount * 4); // mass, charge, energy, potential
                
                // Initialize particle data
                for (let i = 0; i < this.particleCount; i++) {
                    const i4 = i * 4;
                    
                    // Random positions in sphere
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const r = Math.random() * 5;
                    
                    positions[i4] = r * Math.sin(phi) * Math.cos(theta);
                    positions[i4 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    positions[i4 + 2] = r * Math.cos(phi);
                    positions[i4 + 3] = 1.0;
                    
                    // Random velocities
                    velocities[i4] = (Math.random() - 0.5) * 2;
                    velocities[i4 + 1] = (Math.random() - 0.5) * 2;
                    velocities[i4 + 2] = (Math.random() - 0.5) * 2;
                    velocities[i4 + 3] = 0.0;
                    
                    // Properties: mass, charge, energy, potential
                    properties[i4] = 1.0 + Math.random() * 0.5; // Mass
                    properties[i4 + 1] = (Math.random() - 0.5) * 2; // Charge
                    properties[i4 + 2] = 0.0; // Energy (calculated)
                    properties[i4 + 3] = 0.0; // Potential (calculated)
                }
                
                // Create buffers
                this.buffers.position = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.bufferData(gl.ARRAY_BUFFER, positions, gl.DYNAMIC_DRAW);
                
                this.buffers.velocity = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.velocity);
                gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.DYNAMIC_DRAW);
                
                this.buffers.properties = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.properties);
                gl.bufferData(gl.ARRAY_BUFFER, properties, gl.DYNAMIC_DRAW);
                
                // Create vertex array object
                this.vao = gl.createVertexArray();
                gl.bindVertexArray(this.vao);
                
                // Position attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.position);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 16, 0);
                
                // Velocity attribute
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.velocity);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 16, 0);
                
                // Properties attributes
                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.properties);
                gl.enableVertexAttribArray(2);
                gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 16, 0); // Mass
                gl.enableVertexAttribArray(3);
                gl.vertexAttribPointer(3, 1, gl.FLOAT, false, 16, 4); // Charge
                
                gl.bindVertexArray(null);
            }
            
            setupEventListeners() {
                // Control event listeners
                document.getElementById('simulationType').addEventListener('change', (e) => {
                    this.currentSimulation = e.target.value;
                    this.resetSimulation();
                });
                
                document.getElementById('particleCount').addEventListener('input', (e) => {
                    this.particleCount = parseInt(e.target.value);
                    document.getElementById('particleCountValue').textContent = this.particleCount;
                    this.createBuffers();
                });
                
                document.getElementById('fieldStrength').addEventListener('input', (e) => {
                    this.fieldStrength = parseFloat(e.target.value);
                    document.getElementById('fieldStrengthValue').textContent = this.fieldStrength.toFixed(1);
                });
                
                document.getElementById('timeScale').addEventListener('input', (e) => {
                    this.timeScale = parseFloat(e.target.value);
                    document.getElementById('timeScaleValue').textContent = this.timeScale.toFixed(1);
                });
                
                document.getElementById('visualMode').addEventListener('change', (e) => {
                    this.visualMode = e.target.value;
                });
                
                document.getElementById('togglePause').addEventListener('click', () => {
                    this.isPaused = !this.isPaused;
                });
                
                document.getElementById('resetSim').addEventListener('click', () => {
                    this.resetSimulation();
                });
                
                document.getElementById('exportData').addEventListener('click', () => {
                    this.exportSimulationData();
                });
                
                // Check for VR support
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            document.getElementById('toggleVR').classList.remove('hidden');
                            document.getElementById('toggleVR').addEventListener('click', () => {
                                this.toggleVRMode();
                            });
                        }
                    });
                }
            }
            
            initializeSimulation() {
                this.time = 0;
                this.lastTime = performance.now();
                this.calculateInitialEnergy();
            }
            
            calculateInitialEnergy() {
                // Calculate initial total energy for conservation monitoring
                const gl = this.gl;
                
                // Read back properties buffer to calculate total energy
                gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, this.buffers.properties);
                const properties = new Float32Array(this.particleCount * 4);
                gl.getBufferSubData(gl.SHADER_STORAGE_BUFFER, 0, properties);
                
                this.initialEnergy = 0;
                for (let i = 0; i < this.particleCount; i++) {
                    this.initialEnergy += properties[i * 4 + 2]; // Energy component
                }
                
                this.totalEnergy = this.initialEnergy;
            }
            
            resetSimulation() {
                this.createBuffers();
                this.initializeSimulation();
            }
            
            animate() {
                const currentTime = performance.now();
                this.deltaTime = (currentTime - this.lastTime) * 0.001 * this.timeScale;
                this.lastTime = currentTime;
                
                if (!this.isPaused) {
                    this.time += this.deltaTime;
                    this.updatePhysics();
                }
                
                this.render();
                this.updatePerformanceMetrics();
                
                requestAnimationFrame(() => this.animate());
            }
            
            updatePhysics() {
                const gl = this.gl;
                this.computeStartTime = performance.now();
                
                // Bind compute shader
                gl.useProgram(this.programs.compute);
                
                // Bind buffers as shader storage buffers
                gl.bindBufferBase(gl.SHADER_STORAGE_BUFFER, 0, this.buffers.position);
                gl.bindBufferBase(gl.SHADER_STORAGE_BUFFER, 1, this.buffers.velocity);
                gl.bindBufferBase(gl.SHADER_STORAGE_BUFFER, 2, this.buffers.properties);
                
                // Set uniforms
                gl.uniform1f(gl.getUniformLocation(this.programs.compute, 'uDeltaTime'), this.deltaTime);
                gl.uniform1f(gl.getUniformLocation(this.programs.compute, 'uFieldStrength'), this.fieldStrength);
                gl.uniform1f(gl.getUniformLocation(this.programs.compute, 'uTime'), this.time);
                gl.uniform1i(gl.getUniformLocation(this.programs.compute, 'uParticleCount'), this.particleCount);
                
                // Set simulation type
                const simTypes = {
                    'quantum_field': 0,
                    'gravitational_waves': 1,
                    'plasma_physics': 2,
                    'fluid_dynamics': 3,
                    'electromagnetic': 4,
                    'particle_collision': 5
                };
                gl.uniform1i(gl.getUniformLocation(this.programs.compute, 'uSimulationType'), simTypes[this.currentSimulation] || 0);
                
                // Dispatch compute shader
                const workGroupSize = 64;
                const numWorkGroups = Math.ceil(this.particleCount / workGroupSize);
                gl.dispatchCompute(numWorkGroups, 1, 1);
                
                // Wait for compute to finish
                gl.memoryBarrier(gl.SHADER_STORAGE_BARRIER_BIT);
                
                this.computeTime = performance.now() - this.computeStartTime;
                
                // Update energy conservation monitoring
                this.updateEnergyConservation();
            }
            
            updateEnergyConservation() {
                // Periodically check energy conservation (every 60 frames)
                if (this.frameCount % 60 === 0) {
                    const gl = this.gl;
                    
                    // Read back properties buffer
                    gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, this.buffers.properties);
                    const properties = new Float32Array(this.particleCount * 4);
                    gl.getBufferSubData(gl.SHADER_STORAGE_BUFFER, 0, properties);
                    
                    this.totalEnergy = 0;
                    for (let i = 0; i < this.particleCount; i++) {
                        this.totalEnergy += properties[i * 4 + 2]; // Energy component
                    }
                    
                    this.energyHistory.push(this.totalEnergy);
                    if (this.energyHistory.length > 100) {
                        this.energyHistory.shift();
                    }
                }
            }
            
            render() {
                const gl = this.gl;
                
                // Clear canvas
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                
                // Use particle rendering program
                gl.useProgram(this.programs.particle);
                
                // Set up camera matrices
                const aspect = this.canvas.width / this.canvas.height;
                const projectionMatrix = this.createPerspectiveMatrix(45 * Math.PI / 180, aspect, 0.1, 100);
                const viewMatrix = this.createViewMatrix();
                
                // Set uniforms
                gl.uniformMatrix4fv(gl.getUniformLocation(this.programs.particle, 'uProjectionMatrix'), false, projectionMatrix);
                gl.uniformMatrix4fv(gl.getUniformLocation(this.programs.particle, 'uViewMatrix'), false, viewMatrix);
                gl.uniform1f(gl.getUniformLocation(this.programs.particle, 'uTime'), this.time);
                gl.uniform1f(gl.getUniformLocation(this.programs.particle, 'uPointSize'), 3.0);
                
                // Render particles
                gl.bindVertexArray(this.vao);
                gl.drawArrays(gl.POINTS, 0, this.particleCount);
                gl.bindVertexArray(null);
                
                this.frameCount++;
            }
            
            createPerspectiveMatrix(fov, aspect, near, far) {
                const f = 1.0 / Math.tan(fov / 2);
                const rangeInv = 1 / (near - far);
                
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }
            
            createViewMatrix() {
                const radius = 20;
                const x = radius * Math.cos(this.time * 0.1) * Math.sin(this.time * 0.05);
                const y = radius * Math.sin(this.time * 0.1);
                const z = radius * Math.cos(this.time * 0.1) * Math.cos(this.time * 0.05);
                
                return this.lookAt([x, y, z], [0, 0, 0], [0, 1, 0]);
            }
            
            lookAt(eye, center, up) {
                const f = this.normalize(this.subtract(center, eye));
                const s = this.normalize(this.cross(f, up));
                const u = this.cross(s, f);
                
                return new Float32Array([
                    s[0], u[0], -f[0], 0,
                    s[1], u[1], -f[1], 0,
                    s[2], u[2], -f[2], 0,
                    -this.dot(s, eye), -this.dot(u, eye), this.dot(f, eye), 1
                ]);
            }
            
            normalize(v) {
                const length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
                return [v[0] / length, v[1] / length, v[2] / length];
            }
            
            subtract(a, b) {
                return [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
            }
            
            cross(a, b) {
                return [
                    a[1] * b[2] - a[2] * b[1],
                    a[2] * b[0] - a[0] * b[2],
                    a[0] * b[1] - a[1] * b[0]
                ];
            }
            
            dot(a, b) {
                return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
            }
            
            updatePerformanceMetrics() {
                const currentTime = performance.now();
                
                if (currentTime - this.lastFPSUpdate > 1000) {
                    this.currentFPS = Math.round(this.frameCount * 1000 / (currentTime - this.lastFPSUpdate));
                    this.frameCount = 0;
                    this.lastFPSUpdate = currentTime;
                    
                    // Update UI
                    document.getElementById('fps').textContent = this.currentFPS;
                    document.getElementById('activeParticles').textContent = this.particleCount.toLocaleString();
                    document.getElementById('computeTime').textContent = this.computeTime.toFixed(2);
                    
                    // Calculate energy conservation percentage
                    if (this.initialEnergy > 0) {
                        const conservation = (this.totalEnergy / this.initialEnergy) * 100;
                        document.getElementById('energyConservation').textContent = conservation.toFixed(1);
                    }
                    
                    // Estimate GPU memory usage
                    const bytesPerParticle = 4 * 4 * 3; // 3 vec4s per particle
                    const gpuMemoryMB = (this.particleCount * bytesPerParticle) / (1024 * 1024);
                    document.getElementById('gpuMemory').textContent = gpuMemoryMB.toFixed(1);
                }
            }
            
            exportSimulationData() {
                const gl = this.gl;
                
                // Read back all buffer data
                gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, this.buffers.position);
                const positions = new Float32Array(this.particleCount * 4);
                gl.getBufferSubData(gl.SHADER_STORAGE_BUFFER, 0, positions);
                
                gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, this.buffers.velocity);
                const velocities = new Float32Array(this.particleCount * 4);
                gl.getBufferSubData(gl.SHADER_STORAGE_BUFFER, 0, velocities);
                
                gl.bindBuffer(gl.SHADER_STORAGE_BUFFER, this.buffers.properties);
                const properties = new Float32Array(this.particleCount * 4);
                gl.getBufferSubData(gl.SHADER_STORAGE_BUFFER, 0, properties);
                
                const exportData = {
                    timestamp: new Date().toISOString(),
                    simulationType: this.currentSimulation,
                    particleCount: this.particleCount,
                    time: this.time,
                    fieldStrength: this.fieldStrength,
                    energyConservation: this.totalEnergy / this.initialEnergy,
                    energyHistory: this.energyHistory,
                    particles: []
                };
                
                for (let i = 0; i < this.particleCount; i++) {
                    const i4 = i * 4;
                    exportData.particles.push({
                        position: [positions[i4], positions[i4 + 1], positions[i4 + 2]],
                        velocity: [velocities[i4], velocities[i4 + 1], velocities[i4 + 2]],
                        mass: properties[i4],
                        charge: properties[i4 + 1],
                        energy: properties[i4 + 2]
                    });
                }
                
                // Download as JSON
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `physics_simulation_${this.currentSimulation}_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
            
            toggleVRMode() {
                if (navigator.xr) {
                    navigator.xr.requestSession('immersive-vr').then((session) => {
                        // VR session setup would go here
                        console.log('VR mode activated');
                        // This would require additional WebXR implementation
                    }).catch((error) => {
                        console.error('VR mode failed:', error);
                    });
                }
            }
        }
        
        // Initialize the visualizer when page loads
        window.addEventListener('load', () => {
            try {
                new AdvancedPhysicsVisualizer();
            } catch (error) {
                console.error('Failed to initialize Advanced Physics Visualizer:', error);
                document.getElementById('info').innerHTML = `
                    <strong>Error:</strong> ${error.message}<br>
                    Please ensure your browser supports WebGL2 and compute shaders.
                `;
            }
        });
    </script>
</body>
</html> 