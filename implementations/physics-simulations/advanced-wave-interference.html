<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Wave Interference Simulation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            max-width: 300px;
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 140px;
        }
        
        input[type="number"] {
            width: 80px;
            background: #222;
            color: #fff;
            border: 1px solid #555;
            padding: 3px;
            font-size: 11px;
        }
        
        button {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            margin: 3px;
            font-size: 11px;
        }
        
        button:hover {
            background: #555;
        }
        
        .active {
            background: #0066cc !important;
        }
        
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #333;
            font-size: 11px;
            max-width: 320px;
        }
        
        .equation {
            background: #111;
            padding: 5px;
            margin: 5px 0;
            border-left: 3px solid #0ff;
            font-family: 'Times New Roman', serif;
            font-size: 11px;
        }
        
        .wave-type {
            background: #333;
            margin: 2px;
            padding: 4px 8px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <h3>Wave Interference Simulation</h3>
            
            <h4>Wave Source 1</h4>
            <div class="control-group">
                <label>Frequency 1 (Hz):</label>
                <input type="number" id="freq1" value="2.0" step="0.1" min="0.1" max="10">
            </div>
            
            <div class="control-group">
                <label>Amplitude 1:</label>
                <input type="range" id="amp1" min="0.1" max="2.0" step="0.1" value="1.0">
                <span id="amp1Value">1.0</span>
            </div>
            
            <div class="control-group">
                <label>Phase 1 (rad):</label>
                <input type="range" id="phase1" min="0" max="6.28" step="0.1" value="0">
                <span id="phase1Value">0.0</span>
            </div>
            
            <h4>Wave Source 2</h4>
            <div class="control-group">
                <label>Frequency 2 (Hz):</label>
                <input type="number" id="freq2" value="2.2" step="0.1" min="0.1" max="10">
            </div>
            
            <div class="control-group">
                <label>Amplitude 2:</label>
                <input type="range" id="amp2" min="0.1" max="2.0" step="0.1" value="1.0">
                <span id="amp2Value">1.0</span>
            </div>
            
            <div class="control-group">
                <label>Phase 2 (rad):</label>
                <input type="range" id="phase2" min="0" max="6.28" step="0.1" value="0">
                <span id="phase2Value">0.0</span>
            </div>
            
            <h4>Simulation Controls</h4>
            <div class="control-group">
                <label>Wave Speed (m/s):</label>
                <input type="number" id="waveSpeed" value="5.0" step="0.1" min="1" max="20">
            </div>
            
            <div class="control-group">
                <label>Time Scale:</label>
                <input type="range" id="timeScale" min="0.1" max="3.0" step="0.1" value="1.0">
                <span id="timeScaleValue">1.0</span>
            </div>
            
            <div class="control-group">
                <button onclick="togglePause()">Pause/Resume</button>
                <button onclick="resetWaves()">Reset</button>
            </div>
            
            <h4>Wave Types</h4>
            <div class="control-group">
                <button class="wave-type active" onclick="setWaveType('circular')">Circular Waves</button>
                <button class="wave-type" onclick="setWaveType('plane')">Plane Waves</button>
                <button class="wave-type" onclick="setWaveType('standing')">Standing Waves</button>
            </div>
            
            <div class="control-group">
                <button onclick="toggleSources()">Toggle Sources</button>
                <button onclick="toggleGrid()">Toggle Grid</button>
            </div>
        </div>
        
        <div id="info">
            <h4>Wave Physics</h4>
            <div class="equation">
                <strong>Wave Equation:</strong><br>
                ∂²ψ/∂t² = c²∇²ψ
            </div>
            <div class="equation">
                <strong>Superposition Principle:</strong><br>
                ψ_total = ψ₁ + ψ₂ + ... + ψₙ
            </div>
            <div class="equation">
                <strong>Circular Wave:</strong><br>
                ψ(r,t) = A sin(kr - ωt + φ)/r
            </div>
            <div class="equation">
                <strong>Plane Wave:</strong><br>
                ψ(x,t) = A sin(kx - ωt + φ)
            </div>
            <div class="equation">
                <strong>Interference:</strong><br>
                I = |ψ₁ + ψ₂|²
            </div>
            
            <div id="realTimeData">
                <h4>Wave Properties</h4>
                <div>Time: <span id="timeDisplay">0.00</span> s</div>
                <div>Wavelength 1: <span id="lambda1Display">0</span> m</div>
                <div>Wavelength 2: <span id="lambda2Display">0</span> m</div>
                <div>Beat Frequency: <span id="beatFreqDisplay">0</span> Hz</div>
                <div>Max Amplitude: <span id="maxAmpDisplay">0</span></div>
                <div>Energy Density: <span id="energyDisplay">0</span> J/m²</div>
            </div>
            
            <div id="instructions">
                <h4>Controls</h4>
                <div>• Mouse: Move wave sources</div>
                <div>• Wheel: Zoom view</div>
                <div>• Different frequencies create beats</div>
                <div>• Phase difference affects interference</div>
                <div>• Red/Blue: Wave sources</div>
                <div>• Bright areas: Constructive interference</div>
                <div>• Dark areas: Destructive interference</div>
            </div>
        </div>
    </div>

    <script>
        // Physics constants and simulation parameters
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Simulation state
        let animationId;
        let isPaused = false;
        let showSources = true;
        let showGrid = true;
        let time = 0;
        let dt = 0.016; // 60 FPS
        
        // Wave parameters
        let waveParams = {
            freq1: 2.0,
            freq2: 2.2,
            amp1: 1.0,
            amp2: 1.0,
            phase1: 0.0,
            phase2: 0.0,
            waveSpeed: 5.0,
            waveType: 'circular'
        };
        
        // Wave sources (can be moved with mouse)
        let sources = [
            { x: 200, y: 300, active: true },
            { x: 600, y: 300, active: true }
        ];
        
        // Camera and view
        let camera = {
            zoom: 1.0,
            offsetX: 0,
            offsetY: 0
        };
        
        // Grid for wave calculation
        let gridSize = 100;
        let waveField = [];
        
        // Initialize simulation
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupMouseControls();
            setupControls();
            initializeWaveField();
            
            animate();
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        
        function setupMouseControls() {
            let dragging = false;
            let dragSource = -1;
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                // Check if clicking near a source
                for (let i = 0; i < sources.length; i++) {
                    const dx = mouseX - sources[i].x;
                    const dy = mouseY - sources[i].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if (dist < 30) {
                        dragging = true;
                        dragSource = i;
                        break;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (dragging && dragSource >= 0) {
                    const rect = canvas.getBoundingClientRect();
                    sources[dragSource].x = e.clientX - rect.left;
                    sources[dragSource].y = e.clientY - rect.top;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                dragging = false;
                dragSource = -1;
            });
            
            // Zoom with mouse wheel
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.zoom *= (1 - e.deltaY * 0.001);
                camera.zoom = Math.max(0.5, Math.min(3.0, camera.zoom));
            });
        }
        
        function setupControls() {
            // Wave 1 controls
            document.getElementById('freq1').addEventListener('input', (e) => {
                waveParams.freq1 = parseFloat(e.target.value);
            });
            
            document.getElementById('amp1').addEventListener('input', (e) => {
                waveParams.amp1 = parseFloat(e.target.value);
                document.getElementById('amp1Value').textContent = e.target.value;
            });
            
            document.getElementById('phase1').addEventListener('input', (e) => {
                waveParams.phase1 = parseFloat(e.target.value);
                document.getElementById('phase1Value').textContent = parseFloat(e.target.value).toFixed(1);
            });
            
            // Wave 2 controls
            document.getElementById('freq2').addEventListener('input', (e) => {
                waveParams.freq2 = parseFloat(e.target.value);
            });
            
            document.getElementById('amp2').addEventListener('input', (e) => {
                waveParams.amp2 = parseFloat(e.target.value);
                document.getElementById('amp2Value').textContent = e.target.value;
            });
            
            document.getElementById('phase2').addEventListener('input', (e) => {
                waveParams.phase2 = parseFloat(e.target.value);
                document.getElementById('phase2Value').textContent = parseFloat(e.target.value).toFixed(1);
            });
            
            // Simulation controls
            document.getElementById('waveSpeed').addEventListener('input', (e) => {
                waveParams.waveSpeed = parseFloat(e.target.value);
            });
            
            document.getElementById('timeScale').addEventListener('input', (e) => {
                document.getElementById('timeScaleValue').textContent = e.target.value;
            });
        }
        
        function initializeWaveField() {
            waveField = [];
            for (let i = 0; i < gridSize; i++) {
                waveField[i] = [];
                for (let j = 0; j < gridSize; j++) {
                    waveField[i][j] = 0;
                }
            }
        }
        
        function setWaveType(type) {
            waveParams.waveType = type;
            
            // Update button states
            document.querySelectorAll('.wave-type').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }
        
        function togglePause() {
            isPaused = !isPaused;
        }
        
        function toggleSources() {
            showSources = !showSources;
        }
        
        function toggleGrid() {
            showGrid = !showGrid;
        }
        
        function resetWaves() {
            time = 0;
            initializeWaveField();
        }
        
        // Calculate wave interference at each point
        function calculateWaveField() {
            const omega1 = 2 * Math.PI * waveParams.freq1;
            const omega2 = 2 * Math.PI * waveParams.freq2;
            const k1 = omega1 / waveParams.waveSpeed;
            const k2 = omega2 / waveParams.waveSpeed;
            
            const stepX = canvas.width / gridSize;
            const stepY = canvas.height / gridSize;
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const x = i * stepX;
                    const y = j * stepY;
                    
                    let wave1 = 0;
                    let wave2 = 0;
                    
                    if (sources[0].active) {
                        wave1 = calculateWaveAtPoint(x, y, sources[0], k1, omega1, waveParams.amp1, waveParams.phase1);
                    }
                    
                    if (sources[1].active) {
                        wave2 = calculateWaveAtPoint(x, y, sources[1], k2, omega2, waveParams.amp2, waveParams.phase2);
                    }
                    
                    // Superposition principle
                    waveField[i][j] = wave1 + wave2;
                }
            }
        }
        
        function calculateWaveAtPoint(x, y, source, k, omega, amplitude, phase) {
            const dx = x - source.x;
            const dy = y - source.y;
            const r = Math.sqrt(dx*dx + dy*dy);
            
            if (r < 1) return 0; // Avoid singularity at source
            
            switch (waveParams.waveType) {
                case 'circular':
                    // Circular wave: amplitude decreases with 1/r
                    return (amplitude / Math.sqrt(r)) * Math.sin(k * r - omega * time + phase);
                    
                case 'plane':
                    // Plane wave in x direction
                    return amplitude * Math.sin(k * x - omega * time + phase);
                    
                case 'standing':
                    // Standing wave pattern
                    return amplitude * Math.sin(k * x + phase) * Math.cos(omega * time);
                    
                default:
                    return 0;
            }
        }
        
        function updatePhysics() {
            if (isPaused) return;
            
            const timeScale = parseFloat(document.getElementById('timeScale').value);
            time += dt * timeScale;
            
            // Update wave parameters from controls
            waveParams.freq1 = parseFloat(document.getElementById('freq1').value);
            waveParams.freq2 = parseFloat(document.getElementById('freq2').value);
            waveParams.amp1 = parseFloat(document.getElementById('amp1').value);
            waveParams.amp2 = parseFloat(document.getElementById('amp2').value);
            waveParams.phase1 = parseFloat(document.getElementById('phase1').value);
            waveParams.phase2 = parseFloat(document.getElementById('phase2').value);
            waveParams.waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
            
            // Calculate wave interference
            calculateWaveField();
        }
        
        function render() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw wave field
            drawWaveField();
            
            // Draw grid if enabled
            if (showGrid) {
                drawGrid();
            }
            
            // Draw wave sources
            if (showSources) {
                drawSources();
            }
            
            // Update display
            updateDisplay();
        }
        
        function drawWaveField() {
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;
            
            const stepX = canvas.width / gridSize;
            const stepY = canvas.height / gridSize;
            
            // Find max amplitude for normalization
            let maxAmp = 0;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    maxAmp = Math.max(maxAmp, Math.abs(waveField[i][j]));
                }
            }
            
            // Draw wave field as colored pixels
            for (let i = 0; i < gridSize - 1; i++) {
                for (let j = 0; j < gridSize - 1; j++) {
                    const amplitude = waveField[i][j];
                    const normalized = maxAmp > 0 ? amplitude / maxAmp : 0;
                    
                    // Color mapping: blue for negative, red for positive
                    let r, g, b;
                    if (normalized > 0) {
                        r = Math.floor(255 * normalized);
                        g = Math.floor(100 * normalized);
                        b = 0;
                    } else {
                        r = 0;
                        g = Math.floor(100 * Math.abs(normalized));
                        b = Math.floor(255 * Math.abs(normalized));
                    }
                    
                    // Fill rectangular region
                    const startX = Math.floor(i * stepX);
                    const endX = Math.floor((i + 1) * stepX);
                    const startY = Math.floor(j * stepY);
                    const endY = Math.floor((j + 1) * stepY);
                    
                    for (let px = startX; px < endX; px++) {
                        for (let py = startY; py < endY; py++) {
                            if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                const index = (py * canvas.width + px) * 4;
                                data[index] = r;     // Red
                                data[index + 1] = g; // Green
                                data[index + 2] = b; // Blue
                                data[index + 3] = 255; // Alpha
                            }
                        }
                    }
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }
        
        function drawGrid() {
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            
            const stepX = canvas.width / 10;
            const stepY = canvas.height / 10;
            
            // Vertical lines
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(i * stepX, 0);
                ctx.lineTo(i * stepX, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(0, i * stepY);
                ctx.lineTo(canvas.width, i * stepY);
                ctx.stroke();
            }
        }
        
        function drawSources() {
            // Draw source 1 (red)
            if (sources[0].active) {
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(sources[0].x, sources[0].y, 15, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText('1', sources[0].x - 4, sources[0].y + 4);
            }
            
            // Draw source 2 (blue)
            if (sources[1].active) {
                ctx.fillStyle = '#0000ff';
                ctx.beginPath();
                ctx.arc(sources[1].x, sources[1].y, 15, 0, 2 * Math.PI);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px monospace';
                ctx.fillText('2', sources[1].x - 4, sources[1].y + 4);
            }
        }
        
        function updateDisplay() {
            // Calculate wave properties
            const lambda1 = waveParams.waveSpeed / waveParams.freq1;
            const lambda2 = waveParams.waveSpeed / waveParams.freq2;
            const beatFreq = Math.abs(waveParams.freq1 - waveParams.freq2);
            
            // Find maximum amplitude in current field
            let maxAmp = 0;
            let totalEnergy = 0;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    const amp = Math.abs(waveField[i][j]);
                    maxAmp = Math.max(maxAmp, amp);
                    totalEnergy += amp * amp; // Energy proportional to amplitude squared
                }
            }
            
            const avgEnergy = totalEnergy / (gridSize * gridSize);
            
            // Update display
            document.getElementById('timeDisplay').textContent = time.toFixed(2);
            document.getElementById('lambda1Display').textContent = lambda1.toFixed(2);
            document.getElementById('lambda2Display').textContent = lambda2.toFixed(2);
            document.getElementById('beatFreqDisplay').textContent = beatFreq.toFixed(2);
            document.getElementById('maxAmpDisplay').textContent = maxAmp.toFixed(3);
            document.getElementById('energyDisplay').textContent = avgEnergy.toFixed(4);
        }
        
        function animate() {
            updatePhysics();
            render();
            animationId = requestAnimationFrame(animate);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html> 