<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cosmic Standing Wave Sim (Agent 1)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #container { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <div id="container"></div>
    <script>
        // COSMIC STANDING WAVE LOGIC
        let scene, camera, renderer, controls;
        let particleSystem, particlePositions, particleVelocities, particleMaterials;
        
        let PARTICLE_COUNT = 50000;
        const PARTICLE_BOUNDS = 100; // Simulation domain size
        
        // Standing wave parameters
        let WAVE_KX = 0.05; 
        let WAVE_KY = 0.05;
        let WAVE_KZ = 0.05;
        let WAVE_AMPLITUDE = 5.0;
        let FORCE_STRENGTH = 0.5; // Keep this to scale forces
        let DAMPING = 0.02;
        let PARTICLE_SIZE = 1.5;

        // DELTA_GRAD is not needed for analytical gradient
        // const DELTA_GRAD = 0.01; 

        let lastTime = performance.now();
        // let frameCount = 0; // Not used

        // --- Standing Wave Potential Function (3D) ---
        function standingWavePotential3D(x, y, z, kx, ky, kz, amplitude) {
            // Potential is amplitude * cos(kx*x) * cos(ky*y) * cos(kz*z)
            // Nodal surfaces occur where terms are zero.
            let potential = amplitude * Math.cos(kx * x) * Math.cos(ky * y) * Math.cos(kz * z);
            potential = isNaN(potential) ? 0 : potential;
            // Clamping might be useful depending on force model, but original was clamped.
            return Math.max(-amplitude, Math.min(amplitude, potential)); // Clamp to amplitude range
        }

        // --- Gradient of Standing Wave Potential (3D) - Analytical ---
        function gradientStandingWave3D(x, y, z, kx, ky, kz, amplitude) {
            const cosKxX = Math.cos(kx * x);
            const sinKxX = Math.sin(kx * x);
            const cosKyY = Math.cos(ky * y);
            const sinKyY = Math.sin(ky * y);
            const cosKzZ = Math.cos(kz * z);
            const sinKzZ = Math.sin(kz * z);

            const p_dx = -amplitude * kx * sinKxX * cosKyY * cosKzZ;
            const p_dy = -amplitude * ky * cosKxX * sinKyY * cosKzZ;
            const p_dz = -amplitude * kz * cosKxX * cosKyY * sinKzZ;
            
            let gradVec = new THREE.Vector3(p_dx, p_dy, p_dz);
            if (isNaN(gradVec.x) || isNaN(gradVec.y) || isNaN(gradVec.z)) {
                return new THREE.Vector3(0,0,0);
            }
            return gradVec;
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.008); 

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 150);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI;

            initParticles();
            
            window.addEventListener('resize', onWindowResize, false);
            console.log("Cosmic Standing Wave Simulation Initialized.");
        }

        function initParticles() {
            if (particleSystem) scene.remove(particleSystem);

            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const color = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r_init = PARTICLE_BOUNDS * Math.cbrt(Math.random());
                const theta_init = Math.random() * Math.PI * 2;
                const phi_init = Math.acos(2 * Math.random() - 1);
                particlePositions[i * 3] = r_init * Math.sin(phi_init) * Math.cos(theta_init);
                particlePositions[i * 3 + 1] = r_init * Math.sin(phi_init) * Math.sin(theta_init);
                particlePositions[i * 3 + 2] = r_init * Math.cos(phi_init);
                particleVelocities[i * 3] = (Math.random() - 0.5) * 0.1;
                particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                particleVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
                color.setHSL(Math.random(), 0.7, 0.6); // Randomize color slightly for better visual
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            particleMaterials = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false 
            });

            particleSystem = new THREE.Points(geometry, particleMaterials);
            scene.add(particleSystem);
        }
        
        function updateParticles(deltaTime) {
            if (!particleSystem || !particlePositions || !particleVelocities) return;
            const positions = particleSystem.geometry.attributes.position.array;
            const timeScale = deltaTime * 30; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                let x = positions[ix], y = positions[iy], z = positions[iz];
                let vx = particleVelocities[ix], vy = particleVelocities[iy], vz = particleVelocities[iz];

                // Use standing wave potential and gradient
                const potential = standingWavePotential3D(x, y, z, WAVE_KX, WAVE_KY, WAVE_KZ, WAVE_AMPLITUDE);
                const gradP = gradientStandingWave3D(x, y, z, WAVE_KX, WAVE_KY, WAVE_KZ, WAVE_AMPLITUDE);
                
                // Force F = -potential * grad(potential). This pushes particles from high |potential| to low |potential|.
                // Since nodes have potential = 0, particles should be attracted towards nodal surfaces.
                let ax = -FORCE_STRENGTH * potential * gradP.x;
                let ay = -FORCE_STRENGTH * potential * gradP.y;
                let az = -FORCE_STRENGTH * potential * gradP.z;
                
                // Add damping
                ax -= DAMPING * vx;
                ay -= DAMPING * vy;
                az -= DAMPING * vz;
                
                // Update velocities
                vx += ax * timeScale;
                vy += ay * timeScale;
                vz += az * timeScale;
                
                // Update positions
                x += vx * timeScale;
                y += vy * timeScale;
                z += vz * timeScale;

                // Boundary conditions (simple reflection with some energy loss)
                if (x < -PARTICLE_BOUNDS || x > PARTICLE_BOUNDS) { vx *= -0.5; x = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, x)); }
                if (y < -PARTICLE_BOUNDS || y > PARTICLE_BOUNDS) { vy *= -0.5; y = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, y)); }
                if (z < -PARTICLE_BOUNDS || z > PARTICLE_BOUNDS) { vz *= -0.5; z = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, z)); }
                
                positions[ix] = x;
                positions[iy] = y;
                positions[iz] = z;
                particleVelocities[ix] = vx;
                particleVelocities[iy] = vy;
                particleVelocities[iz] = vz;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000; 
            lastTime = currentTime;
            
            updateParticles(deltaTime);
            controls.update(); 
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
        animate();
    </script>
</body>
</html> 