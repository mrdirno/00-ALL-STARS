<!DOCTYPE html>
<html>
<head>
<title>Cosmic Standing Wave Particle System</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="particleCanvas"></canvas>
<script>
  const canvas = document.getElementById('particleCanvas');
  const ctx = canvas.getContext('2d');

  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;

  const numParticles = 5000;
  const particles = [];
  const particleSize = 1;
  // const connectionDistance = 50; // Max distance to draw a line between particles (keep commented out for performance)

  // Wave parameters for Cosmic Standing Waves
  const A = 50;  // Amplitude of displacement
  const kx = 0.015; // Wavenumber for x-dimension
  const ky = 0.02;  // Wavenumber for y-dimension
  const kz = 0.025; // Wavenumber for z-dimension
  const w = 0.01;   // Angular frequency for temporal evolution

  let time = 0;

  // Camera properties
  let fov = 300; // Field of view - effectively zoom
  let viewX = 0;
  let viewY = 0;
  let viewZ = -600; // Camera Z position, start further back

  class Particle {
    constructor(x, y, z) {
      this.x0 = x; // Initial x
      this.y0 = y; // Initial y
      this.z0 = z; // Initial z
      this.x = x;
      this.y = y;
      this.z = z;
      this.color = `hsl(${Math.random() * 60 + 200}, 100%, 70%)`; // Cool blue/purple hues
    }

    updatePosition(time) {
      // Cosmic Standing Wave mathematics
      // Particles are pushed towards nodal surfaces of a 3D standing wave pattern
      const cos_wt = Math.cos(w * time);

      const forceX = Math.sin(kx * this.x0) * Math.cos(ky * this.y0) * Math.cos(kz * this.z0);
      const forceY = Math.cos(kx * this.x0) * Math.sin(ky * this.y0) * Math.cos(kz * this.z0);
      const forceZ = Math.cos(kx * this.x0) * Math.cos(ky * this.y0) * Math.sin(kz * this.z0);
      
      // Nudge particles slightly off their initial positions to avoid perfect grid lock initially
      // and add a small random component to break perfect symmetry over time.
      const randFactor = 0.01;
      const randX = (Math.random() - 0.5) * randFactor * this.x0;
      const randY = (Math.random() - 0.5) * randFactor * this.y0;
      const randZ = (Math.random() - 0.5) * randFactor * this.z0;


      this.x = this.x0 + A * forceX * cos_wt + randX;
      this.y = this.y0 + A * forceY * cos_wt + randY;
      this.z = this.z0 + A * forceZ * cos_wt + randZ;
    }

    project() {
      // Simple 3D projection
      const effectiveZ = this.z - viewZ;
      if (effectiveZ <= 0) return null; // Behind or at camera plane

      const scale = fov / effectiveZ;
      const x2d = (this.x - viewX) * scale + width / 2;
      const y2d = (this.y - viewY) * scale + height / 2;
      // Make particle size decrease less sharply with distance for a denser look
      const sizeFactor = Math.max(0.1, 1 - effectiveZ / 2000); 
      return { x: x2d, y: y2d, scale: scale * sizeFactor };
    }

    draw() {
      const proj = this.project();
      if (proj) {
        ctx.beginPath();
        // Adjust particle size scaling for visual appeal
        ctx.arc(proj.x, proj.y, particleSize * Math.max(0.5, proj.scale) * (1 + Math.max(0, this.z / 1500)), 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
      }
    }
  }

  function initParticles() {
    particles.length = 0; // Clear existing particles
    const spread = 500; // How spread out the initial particles are
    for (let i = 0; i < numParticles; i++) {
      // Distribute particles in a sphere initially for better visual
      const r = Math.random() * spread;
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos(2 * Math.random() - 1);
      
      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);
      particles.push(new Particle(x, y, z));
    }
  }
  
  let mouseX = 0, mouseY = 0;
  let targetViewX = 0, targetViewY = 0;
  let autoPanSpeedX = 0.2; // Slow automatic panning
  let autoPanSpeedY = 0.1;

  document.addEventListener('mousemove', (e) => {
    mouseX = (e.clientX / width) * 2 - 1; // -1 to 1
    mouseY = (e.clientY / height) * 2 - 1; // -1 to 1
    targetViewX = mouseX * 150; // Control camera pan with mouse
    targetViewY = mouseY * 150;
  });
  
  document.addEventListener('wheel', (e) => {
    viewZ += e.deltaY * 0.5; // Adjust zoom sensitivity and direction
    viewZ = Math.min(-100, Math.max(-2000, viewZ)); // Clamp camera Z
  });


  function animate() {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.08)'; // Slightly slower fade for more pronounced trails
    ctx.fillRect(0, 0, width, height);

    time += 0.03; // Slow down time a bit for smoother wave evolution

    // Smooth camera movement towards mouse target, plus gentle auto-pan
    targetViewX += autoPanSpeedX * Math.sin(time * 0.1); // Oscillating auto-pan
    targetViewY += autoPanSpeedY * Math.cos(time * 0.15);

    viewX += (targetViewX - viewX) * 0.03; // Slower camera follow
    viewY += (targetViewY - viewY) * 0.03;


    particles.sort((a, b) => b.z - a.z); 

    for (let i = 0; i < particles.length; i++) {
      particles[i].updatePosition(time);
      particles[i].draw();
    }
    
    requestAnimationFrame(animate);
  }

  window.addEventListener('resize', () => {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    // initParticles(); // Consider if re-initialization on resize is desired
  });

  initParticles();
  animate();
</script>
</body>
</html> 