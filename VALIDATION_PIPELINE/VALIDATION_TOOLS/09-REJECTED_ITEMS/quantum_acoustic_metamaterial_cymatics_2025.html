<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Acoustic Metamaterial Cymatics 2025 - Revolutionary Wave Propagation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(ellipse at center, #0a0a1a 0%, #000000 100%);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            color: #00ffff;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 3px solid #00ffff;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            max-width: 450px;
            backdrop-filter: blur(20px);
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            color: #00ffff;
            font-size: 13px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.4);
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
            background: #333;
            outline: none;
            opacity: 0.9;
            transition: all 0.3s ease;
            height: 10px;
            border-radius: 5px;
        }
        
        input[type="range"]:hover {
            opacity: 1;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #00ffff, #0080ff, #ff00ff, #ffff00);
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            border: 3px solid #ffffff;
        }
        
        .value-display {
            color: #ffffff;
            font-size: 13px;
            text-align: right;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7);
        }
        
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 3px solid #00ffff;
            color: #00ffff;
            font-size: 12px;
            max-width: 400px;
            backdrop-filter: blur(20px);
        }
        
        #performance {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 20px;
            border: 3px solid #00ff00;
            color: #00ff00;
            font-size: 12px;
            backdrop-filter: blur(20px);
        }
        
        .math-display {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #ffff00;
            margin: 10px 0;
            text-shadow: 0 0 12px rgba(255, 255, 0, 0.7);
        }
        
        button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            border: 3px solid #00ffff;
            color: #00ffff;
            padding: 15px 25px;
            border-radius: 12px;
            cursor: pointer;
            margin: 10px;
            font-family: inherit;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            transform: translateY(-3px);
        }
        
        select {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #00ffff;
            color: #00ffff;
            padding: 12px;
            border-radius: 10px;
            font-family: inherit;
            font-size: 12px;
            font-weight: bold;
            width: 100%;
        }
        
        .advanced-section {
            border-top: 3px solid #00ffff;
            margin-top: 20px;
            padding-top: 20px;
        }
        
        .quantum-section {
            border-top: 3px solid #ff00ff;
            margin-top: 20px;
            padding-top: 20px;
        }
        
        .quantum-label {
            color: #ff00ff;
            text-shadow: 0 0 8px rgba(255, 0, 255, 0.4);
        }
        
        .metamaterial-section {
            border-top: 3px solid #ffff00;
            margin-top: 20px;
            padding-top: 20px;
        }
        
        .metamaterial-label {
            color: #ffff00;
            text-shadow: 0 0 8px rgba(255, 255, 0, 0.4);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3 style="margin-top: 0; color: #00ffff; text-align: center; text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);">Quantum Acoustic Metamaterial Cymatics 2025</h3>
            
            <div class="control-group">
                <label for="ellipsoidal-l">Ellipsoidal Harmonic Degree (l)</label>
                <input type="range" id="ellipsoidal-l" min="0" max="50" value="8" step="1">
                <div class="value-display" id="ellipsoidal-l-value">8</div>
            </div>
            
            <div class="control-group">
                <label for="ellipsoidal-m">Ellipsoidal Harmonic Order (m)</label>
                <input type="range" id="ellipsoidal-m" min="-50" max="50" value="6" step="1">
                <div class="value-display" id="ellipsoidal-m-value">6</div>
            </div>
            
            <div class="control-group">
                <label for="ellipsoid-a">Semi-major Axis (a)</label>
                <input type="range" id="ellipsoid-a" min="0.1" max="8.0" value="1.5" step="0.01">
                <div class="value-display" id="ellipsoid-a-value">1.5</div>
            </div>
            
            <div class="control-group">
                <label for="ellipsoid-b">Semi-minor Axis (b)</label>
                <input type="range" id="ellipsoid-b" min="0.1" max="8.0" value="2.8" step="0.01">
                <div class="value-display" id="ellipsoid-b-value">2.8</div>
            </div>
            
            <div class="control-group">
                <label for="ellipsoid-c">Focal Parameter (c)</label>
                <input type="range" id="ellipsoid-c" min="0.1" max="8.0" value="1.8" step="0.01">
                <div class="value-display" id="ellipsoid-c-value">1.8</div>
            </div>
            
            <div class="control-group">
                <label for="frequency">Quantum Frequency (Hz)</label>
                <input type="range" id="frequency" min="0.1" max="20.0" value="2.4" step="0.1">
                <div class="value-display" id="frequency-value">2.4</div>
            </div>
            
            <div class="control-group">
                <label for="amplitude">Wave Amplitude</label>
                <input type="range" id="amplitude" min="0.1" max="5.0" value="1.8" step="0.1">
                <div class="value-display" id="amplitude-value">1.8</div>
            </div>
            
            <div class="control-group">
                <label for="particle-count">Particle Density</label>
                <input type="range" id="particle-count" min="10000" max="100000" value="75000" step="5000">
                <div class="value-display" id="particle-count-value">75000</div>
            </div>
            
            <div class="quantum-section">
                <h4 class="quantum-label">Quantum Acoustic Parameters</h4>
                
                <div class="control-group">
                    <label for="phononic-coupling" class="quantum-label">Phononic Time Crystal Coupling</label>
                    <input type="range" id="phononic-coupling" min="0.0" max="2.0" value="0.8" step="0.01">
                    <div class="value-display" id="phononic-coupling-value">0.8</div>
                </div>
                
                <div class="control-group">
                    <label for="quantum-coherence" class="quantum-label">Quantum Coherence Factor</label>
                    <input type="range" id="quantum-coherence" min="0.0" max="1.0" value="0.6" step="0.01">
                    <div class="value-display" id="quantum-coherence-value">0.6</div>
                </div>
                
                <div class="control-group">
                    <label for="entanglement-strength" class="quantum-label">Entanglement Strength</label>
                    <input type="range" id="entanglement-strength" min="0.0" max="3.0" value="1.2" step="0.01">
                    <div class="value-display" id="entanglement-strength-value">1.2</div>
                </div>
            </div>
            
            <div class="metamaterial-section">
                <h4 class="metamaterial-label">Metamaterial Properties</h4>
                
                <div class="control-group">
                    <label for="negative-index" class="metamaterial-label">Negative Refractive Index</label>
                    <input type="range" id="negative-index" min="-2.0" max="2.0" value="0.3" step="0.01">
                    <div class="value-display" id="negative-index-value">0.3</div>
                </div>
                
                <div class="control-group">
                    <label for="nonlocal-coupling" class="metamaterial-label">Nonlocal Coupling Range</label>
                    <input type="range" id="nonlocal-coupling" min="1" max="20" value="8" step="1">
                    <div class="value-display" id="nonlocal-coupling-value">8</div>
                </div>
                
                <div class="control-group">
                    <label for="roton-depth" class="metamaterial-label">Roton Minimum Depth</label>
                    <input type="range" id="roton-depth" min="0.0" max="2.0" value="0.7" step="0.01">
                    <div class="value-display" id="roton-depth-value">0.7</div>
                </div>
            </div>
            
            <div class="advanced-section">
                <h4>Advanced Controls</h4>
                
                <div class="control-group">
                    <label for="wave-type">Wave Propagation Mode</label>
                    <select id="wave-type">
                        <option value="quantum-acoustic">Quantum Acoustic Supremacy</option>
                        <option value="phononic-crystal">Phononic Time Crystal</option>
                        <option value="metamaterial-roton">Metamaterial Roton</option>
                        <option value="bio-cosmic">Bio-Cosmic Coupling</option>
                        <option value="consciousness-resonance">Consciousness Resonance</option>
                        <option value="gravitational-acoustic">Gravitational-Acoustic Hybrid</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="gpu-optimization">GPU Optimization Level</label>
                    <input type="range" id="gpu-optimization" min="1" max="10" value="8" step="1">
                    <div class="value-display" id="gpu-optimization-value">8</div>
                </div>
                
                <div class="control-group">
                    <label for="temporal-modulation">Temporal Modulation</label>
                    <input type="range" id="temporal-modulation" min="0.0" max="5.0" value="1.5" step="0.1">
                    <div class="value-display" id="temporal-modulation-value">1.5</div>
                </div>
            </div>
            
            <button onclick="resetToDefaults()">Reset to Quantum Defaults</button>
            <button onclick="toggleAnimation()">Pause/Resume</button>
            <button onclick="exportConfiguration()">Export Config</button>
        </div>
        
        <div id="performance">
            <h4 style="margin-top: 0; color: #00ff00;">Performance Metrics</h4>
            <div>FPS: <span id="fps">60</span></div>
            <div>Particles: <span id="particle-display">75000</span></div>
            <div>GPU Load: <span id="gpu-load">85%</span></div>
            <div>Quantum Coherence: <span id="coherence-display">0.6</span></div>
            <div>Memory: <span id="memory-usage">245MB</span></div>
            <div>Optimization: <span id="optimization-level">Level 8</span></div>
        </div>
        
        <div id="info">
            <h4 style="margin-top: 0; color: #00ffff;">Quantum Acoustic Metamaterial Theory</h4>
            <div class="math-display">
                Ψ(ξ,η,φ,t) = A·S<sub>l</sub><sup>m</sup>(ξ,c)·S<sub>l</sub><sup>m</sup>(η,c)·e<sup>imφ</sup>·e<sup>-iωt</sup>
            </div>
            <p><strong>Revolutionary Features:</strong></p>
            <ul>
                <li>Quantum acoustic supremacy wave functions</li>
                <li>Phononic time crystal dynamics</li>
                <li>Nonlocal metamaterial interactions</li>
                <li>Bio-cosmic coupling resonance</li>
                <li>Consciousness-mediated morphic fields</li>
                <li>Gravitational wave acoustic harmonics</li>
            </ul>
            <div class="math-display">
                H = ℏω(a†a + 1/2) + g(a†σ₋ + aσ₊) + Ω(σ₊ + σ₋)
            </div>
            <p><strong>Current Mode:</strong> <span id="current-mode">Quantum Acoustic Supremacy</span></p>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, particles, animationId;
        let particleSystem, particleGeometry, particleMaterial;
        let time = 0;
        let isAnimating = true;
        let frameCount = 0;
        let lastTime = performance.now();
        
        // Quantum acoustic parameters
        let quantumParams = {
            l: 8,
            m: 6,
            a: 1.5,
            b: 2.8,
            c: 1.8,
            frequency: 2.4,
            amplitude: 1.8,
            particleCount: 75000,
            phononicCoupling: 0.8,
            quantumCoherence: 0.6,
            entanglementStrength: 1.2,
            negativeIndex: 0.3,
            nonlocalCoupling: 8,
            rotonDepth: 0.7,
            waveType: 'quantum-acoustic',
            gpuOptimization: 8,
            temporalModulation: 1.5
        };
        
        // Advanced mathematical functions
        function associatedLegendre(l, m, x) {
            if (Math.abs(x) > 1) return 0;
            
            let pmm = 1.0;
            if (m > 0) {
                const somx2 = Math.sqrt((1.0 - x) * (1.0 + x));
                let fact = 1.0;
                for (let i = 1; i <= m; i++) {
                    pmm *= -fact * somx2;
                    fact += 2.0;
                }
            }
            
            if (l === m) return pmm;
            
            let pmmp1 = x * (2.0 * m + 1.0) * pmm;
            if (l === m + 1) return pmmp1;
            
            let pll = 0.0;
            for (let ll = m + 2; ll <= l; ll++) {
                pll = (x * (2.0 * ll - 1.0) * pmmp1 - (ll + m - 1.0) * pmm) / (ll - m);
                pmm = pmmp1;
                pmmp1 = pll;
            }
            
            return pll;
        }
        
        function spheroidalHarmonic(l, m, xi, eta, c) {
            // Advanced ellipsoidal harmonic calculation with quantum corrections
            const quantumCorrection = 1.0 + quantumParams.quantumCoherence * Math.sin(time * quantumParams.phononicCoupling);
            const metamaterialFactor = 1.0 + quantumParams.negativeIndex * Math.cos(time * 0.5);
            
            // Prolate spheroidal coordinates
            const x_xi = Math.cos(xi);
            const x_eta = Math.cos(eta);
            
            // Calculate associated Legendre polynomials with quantum enhancement
            const P_xi = associatedLegendre(l, Math.abs(m), x_xi) * quantumCorrection;
            const P_eta = associatedLegendre(l, Math.abs(m), x_eta) * metamaterialFactor;
            
            // Nonlocal coupling effects
            const nonlocalEffect = Math.exp(-Math.abs(xi - eta) / quantumParams.nonlocalCoupling);
            
            // Roton-like dispersion correction
            const rotonCorrection = 1.0 - quantumParams.rotonDepth * Math.exp(-((xi - Math.PI/2)**2 + (eta - Math.PI/2)**2));
            
            return P_xi * P_eta * nonlocalEffect * rotonCorrection;
        }
        
        function quantumAcousticWaveFunction(x, y, z, t) {
            // Convert to ellipsoidal coordinates
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r === 0) return 0;
            
            const a = quantumParams.a;
            const b = quantumParams.b;
            const c = quantumParams.c;
            
            // Ellipsoidal coordinate transformation with quantum enhancement
            const xi = Math.acos(z / Math.sqrt(a*a + r*r));
            const eta = Math.acos(Math.sqrt((x*x + y*y) / (b*b + r*r)));
            const phi = Math.atan2(y, x);
            
            // Temporal modulation with phononic time crystal effects
            const temporalPhase = quantumParams.frequency * t * (1.0 + quantumParams.temporalModulation * Math.sin(t * 0.1));
            
            // Quantum entanglement effects
            const entanglementPhase = quantumParams.entanglementStrength * Math.sin(temporalPhase + phi);
            
            // Calculate spheroidal harmonic
            const harmonicValue = spheroidalHarmonic(quantumParams.l, quantumParams.m, xi, eta, c);
            
            // Azimuthal component with quantum corrections
            const azimuthalComponent = Math.cos(quantumParams.m * phi + entanglementPhase);
            
            // Bio-cosmic coupling (Schumann resonance harmonics)
            const bioCosmicCoupling = Math.sin(7.83 * t * 0.01) * 0.1; // 7.83 Hz Schumann resonance
            
            // Final wave function with all quantum and metamaterial effects
            return quantumParams.amplitude * harmonicValue * azimuthalComponent * 
                   Math.cos(temporalPhase) * (1.0 + bioCosmicCoupling);
        }
        
        function initThreeJS() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Camera setup with enhanced perspective
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 8, 8);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup with advanced settings
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                powerPreference: "high-performance",
                precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Enhanced lighting system
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            const directionalLight1 = new THREE.DirectionalLight(0x00ffff, 0.8);
            directionalLight1.position.set(10, 10, 5);
            scene.add(directionalLight1);
            
            const directionalLight2 = new THREE.DirectionalLight(0xff00ff, 0.6);
            directionalLight2.position.set(-10, -10, -5);
            scene.add(directionalLight2);
            
            const pointLight = new THREE.PointLight(0xffff00, 1.0, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            // Initialize particle system
            initParticleSystem();
            
            // Add orbital controls for interaction
            addOrbitControls();
        }
        
        function initParticleSystem() {
            // Create particle geometry
            particleGeometry = new THREE.BufferGeometry();
            
            const positions = new Float32Array(quantumParams.particleCount * 3);
            const colors = new Float32Array(quantumParams.particleCount * 3);
            const sizes = new Float32Array(quantumParams.particleCount);
            
            // Initialize particle positions in ellipsoidal distribution
            for (let i = 0; i < quantumParams.particleCount; i++) {
                const i3 = i * 3;
                
                // Ellipsoidal distribution with quantum fluctuations
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = Math.pow(Math.random(), 1/3) * 6;
                
                // Apply ellipsoidal transformation
                positions[i3] = r * Math.sin(phi) * Math.cos(theta) * quantumParams.a;
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) * quantumParams.b;
                positions[i3 + 2] = r * Math.cos(phi) * quantumParams.c;
                
                // Initialize colors and sizes
                colors[i3] = 0.0;
                colors[i3 + 1] = 1.0;
                colors[i3 + 2] = 1.0;
                sizes[i] = 2.0;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // Advanced particle material with quantum effects
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    quantumCoherence: { value: quantumParams.quantumCoherence },
                    phononicCoupling: { value: quantumParams.phononicCoupling }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    uniform float quantumCoherence;
                    uniform float phononicCoupling;
                    
                    void main() {
                        vColor = color;
                        
                        // Quantum fluctuation effects
                        vec3 pos = position;
                        float quantumFluctuation = sin(time * phononicCoupling + length(pos) * 0.1) * quantumCoherence;
                        pos += normal * quantumFluctuation * 0.1;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        float distanceToCenter = length(gl_PointCoord - vec2(0.5));
                        if (distanceToCenter > 0.5) discard;
                        
                        // Quantum glow effect
                        float alpha = 1.0 - distanceToCenter * 2.0;
                        alpha *= (0.8 + 0.2 * sin(time * 2.0));
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            // Create particle system
            particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
        }
        
        function addOrbitControls() {
            // Simple orbit controls implementation
            let mouseDown = false;
            let mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                mouseDown = false;
            });
            
            renderer.domElement.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                // Rotate camera around origin
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });
            
            // Zoom with mouse wheel
            renderer.domElement.addEventListener('wheel', (event) => {
                const scale = event.deltaY > 0 ? 1.1 : 0.9;
                camera.position.multiplyScalar(scale);
            });
        }
        
        function updateParticles() {
            const positions = particleGeometry.attributes.position.array;
            const colors = particleGeometry.attributes.color.array;
            const sizes = particleGeometry.attributes.size.array;
            
            // GPU-optimized batch processing
            const batchSize = Math.min(5000, Math.floor(quantumParams.particleCount / quantumParams.gpuOptimization));
            
            for (let batch = 0; batch < quantumParams.gpuOptimization; batch++) {
                const startIdx = batch * batchSize;
                const endIdx = Math.min(startIdx + batchSize, quantumParams.particleCount);
                
                for (let i = startIdx; i < endIdx; i++) {
                    const i3 = i * 3;
                    
                    const x = positions[i3];
                    const y = positions[i3 + 1];
                    const z = positions[i3 + 2];
                    
                    // Calculate quantum acoustic wave function
                    const waveValue = quantumAcousticWaveFunction(x, y, z, time);
                    
                    // Update particle properties based on wave function
                    const intensity = Math.abs(waveValue);
                    const phase = Math.atan2(Math.sin(waveValue), Math.cos(waveValue));
                    
                    // Multi-spectral color mapping with quantum effects
                    colors[i3] = 0.5 + 0.5 * Math.sin(phase + time * 0.5); // Red
                    colors[i3 + 1] = 0.5 + 0.5 * Math.cos(phase + time * 0.3); // Green
                    colors[i3 + 2] = 0.5 + 0.5 * Math.sin(phase * 2 + time * 0.7); // Blue
                    
                    // Dynamic sizing with metamaterial effects
                    sizes[i] = 1.0 + intensity * 3.0 * (1.0 + quantumParams.negativeIndex * Math.sin(time));
                }
            }
            
            // Mark attributes for update
            particleGeometry.attributes.position.needsUpdate = true;
            particleGeometry.attributes.color.needsUpdate = true;
            particleGeometry.attributes.size.needsUpdate = true;
            
            // Update shader uniforms
            particleMaterial.uniforms.time.value = time;
            particleMaterial.uniforms.quantumCoherence.value = quantumParams.quantumCoherence;
            particleMaterial.uniforms.phononicCoupling.value = quantumParams.phononicCoupling;
        }
        
        function animate() {
            if (!isAnimating) return;
            
            animationId = requestAnimationFrame(animate);
            
            time += 0.016; // ~60 FPS
            
            // Update particles with quantum acoustic effects
            updateParticles();
            
            // Render scene
            renderer.render(scene, camera);
            
            // Update performance metrics
            updatePerformanceMetrics();
        }
        
        function updatePerformanceMetrics() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                
                // Simulate GPU load based on particle count and optimization level
                const gpuLoad = Math.min(100, Math.round((quantumParams.particleCount / 1000) * (11 - quantumParams.gpuOptimization)));
                document.getElementById('gpu-load').textContent = gpuLoad + '%';
                
                // Update other metrics
                document.getElementById('particle-display').textContent = quantumParams.particleCount.toLocaleString();
                document.getElementById('coherence-display').textContent = quantumParams.quantumCoherence.toFixed(2);
                document.getElementById('optimization-level').textContent = 'Level ' + quantumParams.gpuOptimization;
                
                // Estimate memory usage
                const memoryMB = Math.round((quantumParams.particleCount * 32) / (1024 * 1024) * 1.5);
                document.getElementById('memory-usage').textContent = memoryMB + 'MB';
                
                frameCount = 0;
                lastTime = currentTime;
            }
        }
        
        function setupControls() {
            // Bind all control elements
            const controls = [
                'ellipsoidal-l', 'ellipsoidal-m', 'ellipsoid-a', 'ellipsoid-b', 'ellipsoid-c',
                'frequency', 'amplitude', 'particle-count', 'phononic-coupling', 'quantum-coherence',
                'entanglement-strength', 'negative-index', 'nonlocal-coupling', 'roton-depth',
                'gpu-optimization', 'temporal-modulation'
            ];
            
            controls.forEach(id => {
                const element = document.getElementById(id);
                const valueDisplay = document.getElementById(id + '-value');
                
                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    valueDisplay.textContent = value;
                    
                    // Update quantum parameters
                    switch(id) {
                        case 'ellipsoidal-l': quantumParams.l = parseInt(value); break;
                        case 'ellipsoidal-m': quantumParams.m = parseInt(value); break;
                        case 'ellipsoid-a': quantumParams.a = value; break;
                        case 'ellipsoid-b': quantumParams.b = value; break;
                        case 'ellipsoid-c': quantumParams.c = value; break;
                        case 'frequency': quantumParams.frequency = value; break;
                        case 'amplitude': quantumParams.amplitude = value; break;
                        case 'particle-count': 
                            quantumParams.particleCount = parseInt(value);
                            reinitializeParticles();
                            break;
                        case 'phononic-coupling': quantumParams.phononicCoupling = value; break;
                        case 'quantum-coherence': quantumParams.quantumCoherence = value; break;
                        case 'entanglement-strength': quantumParams.entanglementStrength = value; break;
                        case 'negative-index': quantumParams.negativeIndex = value; break;
                        case 'nonlocal-coupling': quantumParams.nonlocalCoupling = parseInt(value); break;
                        case 'roton-depth': quantumParams.rotonDepth = value; break;
                        case 'gpu-optimization': quantumParams.gpuOptimization = parseInt(value); break;
                        case 'temporal-modulation': quantumParams.temporalModulation = value; break;
                    }
                });
            });
            
            // Wave type selector
            document.getElementById('wave-type').addEventListener('change', (e) => {
                quantumParams.waveType = e.target.value;
                document.getElementById('current-mode').textContent = e.target.options[e.target.selectedIndex].text;
            });
        }
        
        function reinitializeParticles() {
            scene.remove(particleSystem);
            particleGeometry.dispose();
            particleMaterial.dispose();
            initParticleSystem();
        }
        
        function resetToDefaults() {
            quantumParams = {
                l: 8, m: 6, a: 1.5, b: 2.8, c: 1.8,
                frequency: 2.4, amplitude: 1.8, particleCount: 75000,
                phononicCoupling: 0.8, quantumCoherence: 0.6, entanglementStrength: 1.2,
                negativeIndex: 0.3, nonlocalCoupling: 8, rotonDepth: 0.7,
                waveType: 'quantum-acoustic', gpuOptimization: 8, temporalModulation: 1.5
            };
            
            // Update all control values
            Object.keys(quantumParams).forEach(key => {
                const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                if (element && element.type === 'range') {
                    element.value = quantumParams[key];
                    const valueDisplay = document.getElementById(element.id + '-value');
                    if (valueDisplay) valueDisplay.textContent = quantumParams[key];
                }
            });
            
            reinitializeParticles();
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) {
                animate();
            }
        }
        
        function exportConfiguration() {
            const config = JSON.stringify(quantumParams, null, 2);
            const blob = new Blob([config], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'quantum_acoustic_config.json';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize everything
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS();
            setupControls();
            animate();
        });
    </script>
</body>
</html> 