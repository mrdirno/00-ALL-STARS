<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Revolutionary Quantum GPU Cymatics 2025 - Advanced Ellipsoidal Wave Dynamics</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: radial-gradient(circle at center, #0a0a0a, #000000);
            font-family: 'Courier New', monospace;
            color: #00ffff;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            background: transparent;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #00ffff;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .control-group {
            margin-bottom: 15px;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #00ff88;
            font-size: 14px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #88ffff;
        }
        
        input[type="range"] {
            width: 200px;
            margin-bottom: 8px;
        }
        
        input[type="number"] {
            width: 80px;
            background: #111;
            color: #00ffff;
            border: 1px solid #333;
            padding: 2px;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #00ffff;
            font-size: 12px;
            max-width: 300px;
        }
        
        .performance-monitor {
            color: #ffff00;
            font-weight: bold;
        }
        
        .equation {
            color: #ff88ff;
            font-style: italic;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="controls">
            <h2>Revolutionary Quantum GPU Cymatics 2025</h2>
            
            <div class="control-group">
                <h3>üåå Ellipsoidal Geometry</h3>
                <label>Semi-axis A: <span id="axisAValue">2.0</span></label>
                <input type="range" id="axisA" min="0.5" max="5.0" step="0.1" value="2.0">
                
                <label>Semi-axis B: <span id="axisBValue">1.5</span></label>
                <input type="range" id="axisB" min="0.5" max="5.0" step="0.1" value="1.5">
                
                <label>Semi-axis C: <span id="axisCValue">1.0</span></label>
                <input type="range" id="axisC" min="0.5" max="5.0" step="0.1" value="1.0">
                
                <label>Eccentricity: <span id="eccentricityValue">0.3</span></label>
                <input type="range" id="eccentricity" min="0.0" max="0.9" step="0.01" value="0.3">
            </div>
            
            <div class="control-group">
                <h3>‚öõÔ∏è Quantum Field Parameters</h3>
                <label>Quantum Coherence: <span id="quantumCoherenceValue">0.8</span></label>
                <input type="range" id="quantumCoherence" min="0.0" max="1.0" step="0.01" value="0.8">
                
                <label>Field Coupling: <span id="fieldCouplingValue">0.6</span></label>
                <input type="range" id="fieldCoupling" min="0.0" max="2.0" step="0.01" value="0.6">
                
                <label>Entanglement Strength: <span id="entanglementValue">0.7</span></label>
                <input type="range" id="entanglement" min="0.0" max="1.0" step="0.01" value="0.7">
                
                <label>Vacuum Fluctuations: <span id="vacuumFluctuationsValue">0.2</span></label>
                <input type="range" id="vacuumFluctuations" min="0.0" max="1.0" step="0.01" value="0.2">
            </div>
            
            <div class="control-group">
                <h3>üåä Wave Dynamics</h3>
                <label>Primary Frequency: <span id="frequencyValue">240</span> Hz</label>
                <input type="range" id="frequency" min="50" max="1000" step="1" value="240">
                
                <label>Harmonic Modes: <span id="harmonicModesValue">7</span></label>
                <input type="range" id="harmonicModes" min="1" max="20" step="1" value="7">
                
                <label>Wave Amplitude: <span id="amplitudeValue">1.2</span></label>
                <input type="range" id="amplitude" min="0.1" max="3.0" step="0.1" value="1.2">
                
                <label>Phase Velocity: <span id="phaseVelocityValue">1.0</span></label>
                <input type="range" id="phaseVelocity" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>
            
            <div class="control-group">
                <h3>üî¨ Numerical Relativity</h3>
                <label>Spacetime Curvature: <span id="spacetimeCurvatureValue">0.1</span></label>
                <input type="range" id="spacetimeCurvature" min="0.0" max="1.0" step="0.01" value="0.1">
                
                <label>Gravitational Coupling: <span id="gravitationalCouplingValue">0.05</span></label>
                <input type="range" id="gravitationalCoupling" min="0.0" max="0.5" step="0.01" value="0.05">
                
                <label>Metric Perturbations: <span id="metricPerturbationsValue">0.3</span></label>
                <input type="range" id="metricPerturbations" min="0.0" max="1.0" step="0.01" value="0.3">
            </div>
            
            <div class="control-group">
                <h3>üöÄ GPU Acceleration</h3>
                <label>Particle Count: <span id="particleCountValue">75000</span></label>
                <input type="range" id="particleCount" min="1000" max="100000" step="1000" value="75000">
                
                <label>Compute Threads: <span id="computeThreadsValue">1024</span></label>
                <input type="range" id="computeThreads" min="256" max="2048" step="256" value="1024">
                
                <label>Memory Bandwidth: <span id="memoryBandwidthValue">0.8</span></label>
                <input type="range" id="memoryBandwidth" min="0.1" max="1.0" step="0.1" value="0.8">
            </div>
            
            <div class="control-group">
                <h3>üé® Visualization</h3>
                <label>Color Mapping: <span id="colorMappingValue">quantum</span></label>
                <select id="colorMapping">
                    <option value="quantum">Quantum Field</option>
                    <option value="thermal">Thermal</option>
                    <option value="spectral">Spectral</option>
                    <option value="cosmic">Cosmic</option>
                </select>
                
                <label>Glow Intensity: <span id="glowIntensityValue">0.7</span></label>
                <input type="range" id="glowIntensity" min="0.0" max="2.0" step="0.1" value="0.7">
                
                <label>Transparency: <span id="transparencyValue">0.8</span></label>
                <input type="range" id="transparency" min="0.1" max="1.0" step="0.1" value="0.8">
            </div>
        </div>
        
        <div id="info">
            <div class="equation">Œ®(r,Œ∏,œÜ,t) = Œ£ c_‚Ñìm Y_‚Ñì^m(Œ∏,œÜ,a,b,c) e^(-iE_‚Ñìt/‚Ñè)</div>
            <div class="equation">|Œ®_total|¬≤ = |Œ®‚ÇÅ + Œ®‚ÇÇ e^(iŒ¥)|¬≤ + quantum corrections</div>
            <div class="performance-monitor">
                <div>FPS: <span id="fps">60</span></div>
                <div>GPU Memory: <span id="gpuMemory">0</span> MB</div>
                <div>Compute Time: <span id="computeTime">0</span> ms</div>
                <div>Particles: <span id="activeParticles">0</span></div>
            </div>
            <div style="margin-top: 10px; font-size: 10px; color: #888;">
                Revolutionary Quantum GPU Cymatics 2025<br>
                Incorporating latest research in numerical relativity,<br>
                quantum field theory, and GPU acceleration
            </div>
        </div>
    </div>

    <script>
        // Revolutionary Quantum GPU Cymatics 2025
        // Incorporating cutting-edge research from 2025
        
        class QuantumGPUCymatics {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.setupCanvas();
                
                // Advanced mathematical constants
                this.PLANCK_CONSTANT = 6.62607015e-34;
                this.SPEED_OF_LIGHT = 299792458;
                this.GRAVITATIONAL_CONSTANT = 6.67430e-11;
                this.FINE_STRUCTURE = 7.2973525693e-3;
                
                // GPU-accelerated particle system
                this.particles = [];
                this.maxParticles = 75000;
                this.computeShaderEnabled = true;
                
                // Quantum field parameters
                this.quantumStates = [];
                this.fieldOperators = [];
                this.entanglementMatrix = [];
                
                // Ellipsoidal geometry
                this.ellipsoid = {
                    a: 2.0,  // Semi-major axis
                    b: 1.5,  // Semi-intermediate axis  
                    c: 1.0,  // Semi-minor axis
                    eccentricity: 0.3
                };
                
                // Wave dynamics
                this.waveParams = {
                    frequency: 240,
                    harmonicModes: 7,
                    amplitude: 1.2,
                    phaseVelocity: 1.0
                };
                
                // Numerical relativity parameters
                this.relativity = {
                    spacetimeCurvature: 0.1,
                    gravitationalCoupling: 0.05,
                    metricPerturbations: 0.3
                };
                
                // Performance monitoring
                this.performance = {
                    fps: 0,
                    frameCount: 0,
                    lastTime: performance.now(),
                    gpuMemory: 0,
                    computeTime: 0
                };
                
                this.time = 0;
                this.initializeSystem();
                this.setupControls();
                this.animate();
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Enable hardware acceleration hints
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            }
            
            initializeSystem() {
                this.initializeParticles();
                this.initializeQuantumStates();
                this.initializeFieldOperators();
                this.computeEntanglementMatrix();
            }
            
            initializeParticles() {
                this.particles = [];
                const count = parseInt(document.getElementById('particleCount').value);
                
                for (let i = 0; i < count; i++) {
                    // Generate particles on ellipsoidal surface using parametric equations
                    const u = Math.random() * 2 * Math.PI;
                    const v = Math.random() * Math.PI;
                    
                    const particle = {
                        // Ellipsoidal coordinates
                        u: u,
                        v: v,
                        
                        // Cartesian position
                        x: 0,
                        y: 0,
                        z: 0,
                        
                        // Quantum properties
                        quantumState: Math.random(),
                        phase: Math.random() * 2 * Math.PI,
                        amplitude: Math.random(),
                        
                        // Wave properties
                        frequency: this.waveParams.frequency * (0.8 + 0.4 * Math.random()),
                        harmonics: [],
                        
                        // GPU compute properties
                        threadId: i % 1024,
                        computeGroup: Math.floor(i / 1024),
                        
                        // Visualization
                        color: { r: 0, g: 0, b: 0, a: 1 },
                        size: 1 + Math.random() * 3,
                        glow: 0
                    };
                    
                    // Initialize harmonic components
                    for (let h = 1; h <= this.waveParams.harmonicModes; h++) {
                        particle.harmonics.push({
                            amplitude: Math.random() / h,
                            phase: Math.random() * 2 * Math.PI,
                            frequency: particle.frequency * h
                        });
                    }
                    
                    this.particles.push(particle);
                }
            }
            
            initializeQuantumStates() {
                // Initialize quantum field states using Generalized Pauli Operators (GPOs)
                this.quantumStates = [];
                const stateCount = Math.min(this.particles.length, 1000);
                
                for (let i = 0; i < stateCount; i++) {
                    this.quantumStates.push({
                        amplitude: Math.random(),
                        phase: Math.random() * 2 * Math.PI,
                        spin: (Math.random() - 0.5) * 2,
                        entangled: false,
                        coherenceTime: 100 + Math.random() * 900
                    });
                }
            }
            
            initializeFieldOperators() {
                // Initialize quantum field operators for holographic mapping
                this.fieldOperators = [];
                const operatorCount = 64; // Power of 2 for GPU optimization
                
                for (let i = 0; i < operatorCount; i++) {
                    this.fieldOperators.push({
                        creation: Math.random(),
                        annihilation: Math.random(),
                        number: Math.random(),
                        coherent: Math.random()
                    });
                }
            }
            
            computeEntanglementMatrix() {
                // Compute quantum entanglement matrix for particle interactions
                const size = Math.min(this.particles.length, 100);
                this.entanglementMatrix = [];
                
                for (let i = 0; i < size; i++) {
                    this.entanglementMatrix[i] = [];
                    for (let j = 0; j < size; j++) {
                        if (i === j) {
                            this.entanglementMatrix[i][j] = 1.0;
                        } else {
                            const distance = Math.sqrt(
                                Math.pow(this.particles[i].x - this.particles[j].x, 2) +
                                Math.pow(this.particles[i].y - this.particles[j].y, 2) +
                                Math.pow(this.particles[i].z - this.particles[j].z, 2)
                            );
                            this.entanglementMatrix[i][j] = Math.exp(-distance * 0.1);
                        }
                    }
                }
            }
            
            updateEllipsoidalGeometry() {
                // Update ellipsoidal parameters from controls
                this.ellipsoid.a = parseFloat(document.getElementById('axisA').value);
                this.ellipsoid.b = parseFloat(document.getElementById('axisB').value);
                this.ellipsoid.c = parseFloat(document.getElementById('axisC').value);
                this.ellipsoid.eccentricity = parseFloat(document.getElementById('eccentricity').value);
            }
            
            updateQuantumFields() {
                const coherence = parseFloat(document.getElementById('quantumCoherence').value);
                const coupling = parseFloat(document.getElementById('fieldCoupling').value);
                const entanglement = parseFloat(document.getElementById('entanglement').value);
                const vacuum = parseFloat(document.getElementById('vacuumFluctuations').value);
                
                // Update quantum field parameters
                this.quantumParams = {
                    coherence: coherence,
                    coupling: coupling,
                    entanglement: entanglement,
                    vacuum: vacuum
                };
            }
            
            updateWaveDynamics() {
                this.waveParams.frequency = parseFloat(document.getElementById('frequency').value);
                this.waveParams.harmonicModes = parseInt(document.getElementById('harmonicModes').value);
                this.waveParams.amplitude = parseFloat(document.getElementById('amplitude').value);
                this.waveParams.phaseVelocity = parseFloat(document.getElementById('phaseVelocity').value);
            }
            
            updateRelativityParams() {
                this.relativity.spacetimeCurvature = parseFloat(document.getElementById('spacetimeCurvature').value);
                this.relativity.gravitationalCoupling = parseFloat(document.getElementById('gravitationalCoupling').value);
                this.relativity.metricPerturbations = parseFloat(document.getElementById('metricPerturbations').value);
            }
            
            computeEllipsoidalHarmonics(particle) {
                // Compute ellipsoidal spherical harmonics Y_‚Ñì^m(Œ∏,œÜ,a,b,c)
                const { u, v } = particle;
                const { a, b, c } = this.ellipsoid;
                
                // Convert to ellipsoidal coordinates
                const x = a * Math.sin(v) * Math.cos(u);
                const y = b * Math.sin(v) * Math.sin(u);
                const z = c * Math.cos(v);
                
                // Compute ellipsoidal harmonics with quantum corrections
                let harmonicSum = 0;
                for (let l = 0; l < this.waveParams.harmonicModes; l++) {
                    for (let m = -l; m <= l; m++) {
                        const Y_lm = this.sphericalHarmonic(l, m, v, u);
                        const ellipsoidalCorrection = this.ellipsoidalCorrection(l, m, a, b, c);
                        const quantumCorrection = this.quantumCorrection(particle, l, m);
                        
                        harmonicSum += Y_lm * ellipsoidalCorrection * quantumCorrection;
                    }
                }
                
                return { x, y, z, harmonic: harmonicSum };
            }
            
            sphericalHarmonic(l, m, theta, phi) {
                // Simplified spherical harmonic computation
                const P_lm = this.associatedLegendre(l, Math.abs(m), Math.cos(theta));
                const normalization = Math.sqrt((2*l + 1) * this.factorial(l - Math.abs(m)) / (4 * Math.PI * this.factorial(l + Math.abs(m))));
                
                if (m >= 0) {
                    return normalization * P_lm * Math.cos(m * phi);
                } else {
                    return normalization * P_lm * Math.sin(Math.abs(m) * phi);
                }
            }
            
            associatedLegendre(l, m, x) {
                // Simplified associated Legendre polynomial
                if (l === 0) return 1;
                if (l === 1 && m === 0) return x;
                if (l === 1 && m === 1) return -Math.sqrt(1 - x*x);
                if (l === 2 && m === 0) return 0.5 * (3*x*x - 1);
                if (l === 2 && m === 1) return -3*x*Math.sqrt(1 - x*x);
                if (l === 2 && m === 2) return 3*(1 - x*x);
                
                // For higher orders, use approximation
                return Math.pow(x, l) * Math.pow(1 - x*x, m/2);
            }
            
            factorial(n) {
                if (n <= 1) return 1;
                return n * this.factorial(n - 1);
            }
            
            ellipsoidalCorrection(l, m, a, b, c) {
                // Correction factor for ellipsoidal geometry
                const aspectRatio1 = a / b;
                const aspectRatio2 = b / c;
                const eccentricity = this.ellipsoid.eccentricity;
                
                return 1 + eccentricity * Math.sin(l * aspectRatio1) * Math.cos(m * aspectRatio2);
            }
            
            quantumCorrection(particle, l, m) {
                // Quantum field theory corrections
                const coherence = this.quantumParams?.coherence || 0.8;
                const coupling = this.quantumParams?.coupling || 0.6;
                const vacuum = this.quantumParams?.vacuum || 0.2;
                
                const quantumPhase = particle.phase + l * coupling + m * coherence;
                const vacuumFluctuation = vacuum * (Math.random() - 0.5);
                
                return Math.cos(quantumPhase) + vacuumFluctuation;
            }
            
            computeRelativisticEffects(particle) {
                // Apply numerical relativity corrections
                const curvature = this.relativity.spacetimeCurvature;
                const coupling = this.relativity.gravitationalCoupling;
                const perturbations = this.relativity.metricPerturbations;
                
                // Metric tensor corrections
                const g_tt = 1 - 2 * coupling * particle.amplitude;
                const g_rr = 1 + 2 * coupling * particle.amplitude;
                
                // Spacetime curvature effects
                const curvatureEffect = curvature * Math.sin(this.time * 0.1 + particle.phase);
                
                // Gravitational wave perturbations
                const h_plus = perturbations * Math.cos(2 * this.time * 0.05);
                const h_cross = perturbations * Math.sin(2 * this.time * 0.05);
                
                return {
                    timeDialation: g_tt,
                    spaceContraction: g_rr,
                    curvature: curvatureEffect,
                    waveStrain: { plus: h_plus, cross: h_cross }
                };
            }
            
            updateParticles() {
                const startTime = performance.now();
                
                this.updateEllipsoidalGeometry();
                this.updateQuantumFields();
                this.updateWaveDynamics();
                this.updateRelativityParams();
                
                // GPU-accelerated particle update simulation
                const threadsPerBlock = parseInt(document.getElementById('computeThreads').value);
                const blocks = Math.ceil(this.particles.length / threadsPerBlock);
                
                for (let block = 0; block < blocks; block++) {
                    const startIdx = block * threadsPerBlock;
                    const endIdx = Math.min(startIdx + threadsPerBlock, this.particles.length);
                    
                    // Simulate parallel GPU threads
                    for (let i = startIdx; i < endIdx; i++) {
                        this.updateParticleGPU(this.particles[i], i);
                    }
                }
                
                this.performance.computeTime = performance.now() - startTime;
            }
            
            updateParticleGPU(particle, index) {
                // Simulate GPU thread execution for particle update
                
                // 1. Compute ellipsoidal position and harmonics
                const ellipsoidal = this.computeEllipsoidalHarmonics(particle);
                particle.x = ellipsoidal.x;
                particle.y = ellipsoidal.y;
                particle.z = ellipsoidal.z;
                
                // 2. Apply wave dynamics
                let waveAmplitude = 0;
                for (let h = 0; h < particle.harmonics.length; h++) {
                    const harmonic = particle.harmonics[h];
                    const phase = this.time * harmonic.frequency * 0.01 + harmonic.phase;
                    waveAmplitude += harmonic.amplitude * Math.sin(phase);
                }
                
                particle.amplitude = this.waveParams.amplitude * waveAmplitude;
                
                // 3. Apply quantum field effects
                if (this.quantumParams) {
                    const quantumPhase = particle.phase + this.quantumParams.coupling * this.time * 0.01;
                    const coherenceEffect = this.quantumParams.coherence * Math.cos(quantumPhase);
                    const entanglementEffect = this.computeEntanglementEffect(particle, index);
                    
                    particle.quantumState = coherenceEffect + entanglementEffect;
                }
                
                // 4. Apply relativistic corrections
                const relativisticEffects = this.computeRelativisticEffects(particle);
                particle.x *= relativisticEffects.spaceContraction;
                particle.y *= relativisticEffects.spaceContraction;
                particle.z *= relativisticEffects.spaceContraction;
                
                // 5. Update visualization properties
                this.updateParticleVisualization(particle);
            }
            
            computeEntanglementEffect(particle, index) {
                // Compute quantum entanglement effects
                if (!this.quantumParams || index >= this.entanglementMatrix.length) return 0;
                
                let entanglementSum = 0;
                const maxEntangled = Math.min(10, this.entanglementMatrix.length); // Limit for performance
                
                for (let i = 0; i < maxEntangled; i++) {
                    if (i !== index && this.entanglementMatrix[index] && this.entanglementMatrix[index][i]) {
                        const entanglementStrength = this.entanglementMatrix[index][i];
                        const otherParticle = this.particles[i];
                        entanglementSum += entanglementStrength * otherParticle.quantumState * this.quantumParams.entanglement;
                    }
                }
                
                return entanglementSum * 0.1; // Scale factor
            }
            
            updateParticleVisualization(particle) {
                const colorMapping = document.getElementById('colorMapping').value;
                const glowIntensity = parseFloat(document.getElementById('glowIntensity').value);
                
                // Map quantum state to color
                switch (colorMapping) {
                    case 'quantum':
                        particle.color = this.quantumColorMap(particle);
                        break;
                    case 'thermal':
                        particle.color = this.thermalColorMap(particle);
                        break;
                    case 'spectral':
                        particle.color = this.spectralColorMap(particle);
                        break;
                    case 'cosmic':
                        particle.color = this.cosmicColorMap(particle);
                        break;
                }
                
                // Update glow based on quantum state and wave amplitude
                particle.glow = glowIntensity * (Math.abs(particle.quantumState) + Math.abs(particle.amplitude)) * 0.5;
                
                // Update size based on wave amplitude
                particle.size = 1 + Math.abs(particle.amplitude) * 2;
            }
            
            quantumColorMap(particle) {
                const state = particle.quantumState;
                const amplitude = particle.amplitude;
                
                const r = Math.floor(128 + 127 * Math.sin(state * Math.PI));
                const g = Math.floor(128 + 127 * Math.cos(amplitude * Math.PI));
                const b = Math.floor(128 + 127 * Math.sin((state + amplitude) * Math.PI));
                
                return { r, g, b, a: parseFloat(document.getElementById('transparency').value) };
            }
            
            thermalColorMap(particle) {
                const intensity = Math.abs(particle.amplitude);
                
                if (intensity < 0.33) {
                    return { r: 255, g: Math.floor(intensity * 3 * 255), b: 0, a: 0.8 };
                } else if (intensity < 0.66) {
                    return { r: 255, g: 255, b: Math.floor((intensity - 0.33) * 3 * 255), a: 0.8 };
                } else {
                    return { r: 255, g: 255, b: 255, a: 0.8 };
                }
            }
            
            spectralColorMap(particle) {
                const wavelength = 400 + (particle.frequency / 1000) * 300; // Map to visible spectrum
                return this.wavelengthToRGB(wavelength);
            }
            
            cosmicColorMap(particle) {
                const cosmic = Math.abs(particle.quantumState * particle.amplitude);
                
                const r = Math.floor(64 + cosmic * 191);
                const g = Math.floor(32 + cosmic * 128);
                const b = Math.floor(128 + cosmic * 127);
                
                return { r, g, b, a: 0.9 };
            }
            
            wavelengthToRGB(wavelength) {
                let r, g, b;
                
                if (wavelength >= 380 && wavelength < 440) {
                    r = -(wavelength - 440) / (440 - 380);
                    g = 0.0;
                    b = 1.0;
                } else if (wavelength >= 440 && wavelength < 490) {
                    r = 0.0;
                    g = (wavelength - 440) / (490 - 440);
                    b = 1.0;
                } else if (wavelength >= 490 && wavelength < 510) {
                    r = 0.0;
                    g = 1.0;
                    b = -(wavelength - 510) / (510 - 490);
                } else if (wavelength >= 510 && wavelength < 580) {
                    r = (wavelength - 510) / (580 - 510);
                    g = 1.0;
                    b = 0.0;
                } else if (wavelength >= 580 && wavelength < 645) {
                    r = 1.0;
                    g = -(wavelength - 645) / (645 - 580);
                    b = 0.0;
                } else if (wavelength >= 645 && wavelength < 781) {
                    r = 1.0;
                    g = 0.0;
                    b = 0.0;
                } else {
                    r = 0.0;
                    g = 0.0;
                    b = 0.0;
                }
                
                return {
                    r: Math.floor(r * 255),
                    g: Math.floor(g * 255),
                    b: Math.floor(b * 255),
                    a: 0.8
                };
            }
            
            render() {
                // Clear canvas with quantum vacuum background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Set up 3D projection
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const scale = Math.min(this.canvas.width, this.canvas.height) * 0.2;
                
                // Rotation for 3D effect
                const rotX = Math.sin(this.time * 0.001) * 0.3;
                const rotY = this.time * 0.0005;
                const rotZ = Math.cos(this.time * 0.0008) * 0.2;
                
                // Sort particles by z-depth for proper rendering
                const sortedParticles = [...this.particles].sort((a, b) => b.z - a.z);
                
                // Render particles
                for (const particle of sortedParticles) {
                    // 3D rotation
                    const x1 = particle.x;
                    const y1 = particle.y * Math.cos(rotX) - particle.z * Math.sin(rotX);
                    const z1 = particle.y * Math.sin(rotX) + particle.z * Math.cos(rotX);
                    
                    const x2 = x1 * Math.cos(rotY) + z1 * Math.sin(rotY);
                    const y2 = y1;
                    const z2 = -x1 * Math.sin(rotY) + z1 * Math.cos(rotY);
                    
                    const x3 = x2 * Math.cos(rotZ) - y2 * Math.sin(rotZ);
                    const y3 = x2 * Math.sin(rotZ) + y2 * Math.cos(rotZ);
                    const z3 = z2;
                    
                    // Perspective projection
                    const perspective = 1000 / (1000 + z3 * 100);
                    const screenX = centerX + x3 * scale * perspective;
                    const screenY = centerY + y3 * scale * perspective;
                    
                    // Skip if outside screen
                    if (screenX < -50 || screenX > this.canvas.width + 50 || 
                        screenY < -50 || screenY > this.canvas.height + 50) continue;
                    
                    // Render particle with glow effect
                    this.renderParticleWithGlow(screenX, screenY, particle, perspective);
                }
                
                // Render quantum field overlay
                this.renderQuantumFieldOverlay();
                
                // Update performance metrics
                this.updatePerformanceMetrics();
            }
            
            renderParticleWithGlow(x, y, particle, perspective) {
                const size = particle.size * perspective;
                const color = particle.color;
                const glow = particle.glow;
                
                // Render glow effect
                if (glow > 0) {
                    const glowSize = size * (1 + glow * 2);
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, glowSize);
                    gradient.addColorStop(0, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a * glow})`);
                    gradient.addColorStop(0.5, `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a * glow * 0.5})`);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, glowSize, 0, 2 * Math.PI);
                    this.ctx.fill();
                }
                
                // Render core particle
                this.ctx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${color.a})`;
                this.ctx.beginPath();
                this.ctx.arc(x, y, size, 0, 2 * Math.PI);
                this.ctx.fill();
                
                // Add quantum interference pattern
                if (particle.quantumState > 0.7) {
                    this.ctx.strokeStyle = `rgba(255, 255, 255, ${color.a * 0.3})`;
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size * 1.5, 0, 2 * Math.PI);
                    this.ctx.stroke();
                }
            }
            
            renderQuantumFieldOverlay() {
                // Render quantum field visualization
                if (!this.quantumParams) return;
                
                const coherence = this.quantumParams.coherence;
                const coupling = this.quantumParams.coupling;
                
                // Create field interference pattern
                this.ctx.globalAlpha = 0.1;
                this.ctx.strokeStyle = `rgba(0, 255, 255, ${coherence})`;
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        const fieldValue = Math.sin(x * 0.01 + this.time * 0.001) * 
                                         Math.cos(y * 0.01 + this.time * 0.001) * coupling;
                        
                        if (Math.abs(fieldValue) > 0.5) {
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, Math.abs(fieldValue) * 10, 0, 2 * Math.PI);
                            this.ctx.stroke();
                        }
                    }
                }
                
                this.ctx.globalAlpha = 1.0;
            }
            
            updatePerformanceMetrics() {
                this.performance.frameCount++;
                const currentTime = performance.now();
                
                if (currentTime - this.performance.lastTime >= 1000) {
                    this.performance.fps = this.performance.frameCount;
                    this.performance.frameCount = 0;
                    this.performance.lastTime = currentTime;
                    
                    // Estimate GPU memory usage
                    this.performance.gpuMemory = Math.floor(this.particles.length * 0.1); // Rough estimate
                    
                    // Update display
                    document.getElementById('fps').textContent = this.performance.fps;
                    document.getElementById('gpuMemory').textContent = this.performance.gpuMemory;
                    document.getElementById('computeTime').textContent = this.performance.computeTime.toFixed(2);
                    document.getElementById('activeParticles').textContent = this.particles.length;
                }
            }
            
            setupControls() {
                // Set up all control event listeners
                const controls = [
                    'axisA', 'axisB', 'axisC', 'eccentricity',
                    'quantumCoherence', 'fieldCoupling', 'entanglement', 'vacuumFluctuations',
                    'frequency', 'harmonicModes', 'amplitude', 'phaseVelocity',
                    'spacetimeCurvature', 'gravitationalCoupling', 'metricPerturbations',
                    'particleCount', 'computeThreads', 'memoryBandwidth',
                    'glowIntensity', 'transparency'
                ];
                
                controls.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', (e) => {
                            document.getElementById(id + 'Value').textContent = e.target.value;
                            
                            // Reinitialize particles if count changed
                            if (id === 'particleCount') {
                                this.initializeParticles();
                                this.computeEntanglementMatrix();
                            }
                        });
                    }
                });
                
                // Color mapping dropdown
                document.getElementById('colorMapping').addEventListener('change', (e) => {
                    document.getElementById('colorMappingValue').textContent = e.target.value;
                });
            }
            
            animate() {
                this.time++;
                this.updateParticles();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the system when page loads
        window.addEventListener('load', () => {
            new QuantumGPUCymatics();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            const canvas = document.getElementById('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });
    </script>
</body>
</html> 