<!DOCTYPE html>
<!--
    Resonance is All You Need: A Bio-Cymatic Model of Cosmic Structure Formation
    MODIFIED FOR SCALAR FIELD LSS VISUALIZATION - AGENT 2
    
    Original Concept & Implementation by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Claude Opus 4 (AI Research Assistant & Code Architect) 
    - Gemini 2.5 Pro (AI Research Assistant & Mathematical Modeling)
    
    This version incorporates illustrative mathematics inspired by Scalar Field Dark Matter
    and its implications for Large Scale Structure (LSS) formation.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, Agent 2 (Scalar Field LSS Mod)">
    <meta name="description" content="Bio-Cymatic Model with Scalar Field LSS Theory - Original research by Aldrin Payopay, modified by Agent 2">
    <meta name="keywords" content="Aldrin Payopay, bio-cymatics, cosmic structure, scalar field, dark matter, LSS, resonance, wave theory">
    <title>Resonance: Scalar Field LSS Transformation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* CSS Styles - Preserved from origin-simple.html */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 360px; 
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }
        #controls-panel::-webkit-scrollbar { width: 8px; }
        #controls-panel::-webkit-scrollbar-track { background: rgba(25, 25, 45, 0.1); border-radius: 10px; }
        #controls-panel::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 10px; border: 1px solid rgba(25, 25, 45, 0.2); }
        #controls-panel::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #9F50E8 0%, #5D1DE0 100%); }
        #controls-panel { scrollbar-width: thin; scrollbar-color: #8A2BE2 rgba(25, 25, 45, 0.1); }
        @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        @keyframes slideInUp { to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        .control-group { margin-bottom: 20px; }
        #controls-panel .control-group { padding-right: 14px; }
        #controls-panel h2 { padding-right: 14px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-group label[title] { cursor: help; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; font-weight: 400; text-transform: none; letter-spacing: normal; margin-top: -8px; margin-bottom: 12px; }
        .info-icon { font-size: 0.7em; color: rgba(138, 43, 226, 0.7); font-weight: 400; margin-left: 8px; cursor: help; transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
        .info-icon:hover { color: rgba(138, 43, 226, 1); transform: scale(1.1); }
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; transition: background 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); transition: all 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        select, .ui-input-number { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; font-weight: 500; cursor: pointer; outline: none; transition: all 0.3s ease; -moz-appearance: textfield; }
        select:hover, .ui-input-number:hover { background: rgba(45, 45, 65, 0.15); border-color: rgba(120, 120, 220, 0.3); }
        select:focus, .ui-input-number:focus { border-color: #8A2BE2; box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2); }
        .ui-input-number::-webkit-outer-spin-button, .ui-input-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); transition: left 0.5s ease; }
        button:hover::before { left: 0; }
        button:active { transform: scale(0.98); box-shadow: 0 0 15px rgba(138, 43, 226, 0.5); }
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 18px; background: linear-gradient(135deg, #C38FFF 0%, #A56EFF 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 2px 10px rgba(138, 43, 226, 0.2); }
        #title-card {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto; /* Adjust width automatically */
            max-width: 400px; /* Max width before text wraps */
            padding: 20px; /* Slightly less padding */
            text-align: right; /* Align text to the right */
            opacity: 0;
            transform: translateX(20px);
            animation: slideInRight 0.6s ease forwards;
            animation-delay: 0.4s;
        }
        @keyframes slideInRight { to { opacity: 1; transform: translateX(0); } }
        #title-card h1 { font-size: 1.4rem; font-weight: 700; margin-bottom: 4px; line-height: 1.2; color: #fff; }
        #title-card p { font-size: 0.8rem; color: rgba(200, 200, 255, 0.7); margin-bottom: 12px; line-height: 1.4; }
        .author-credit { font-size: 0.7rem; color: rgba(150, 150, 200, 0.6); }
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
            color: white; font-size: 1.5rem;
        }
        .loading-spinner {
            border: 8px solid rgba(255,255,255,0.2);
            border-top: 8px solid #8A2BE2;
            border-radius: 50%;
            width: 60px; height: 60px;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        Initializing Scalar Field Simulation...
    </div>

    <div id="container"></div>

    <div id="controls-panel" class="ui-panel">
        <h2>Scalar Field LSS Controls</h2>
        
        <div class="control-group">
            <label for="particleCountSlider">Particles: <span id="particleCountValue" class="control-value">50000</span></label>
            <input type="range" id="particleCountSlider" min="1000" max="250000" step="1000" value="50000">
            <small>Number of particles in simulation.</small>
        </div>

        <div class="control-group">
            <label for="wavePotentialStrengthSlider">Potential Strength: <span id="wavePotentialStrengthValue" class="control-value">0.1</span></label>
            <input type="range" id="wavePotentialStrengthSlider" min="0.001" max="1.0" step="0.001" value="0.1">
            <small>Amplitude of the scalar field potential.</small>
        </div>

        <div class="control-group">
            <label for="particleMassSlider">Particle Mass: <span id="particleMassValue" class="control-value">0.01</span></label>
            <input type="range" id="particleMassSlider" min="0.001" max="0.1" step="0.001" value="0.01">
            <small>Inertial mass of particles.</small>
        </div>
        
        <div class="control-group">
            <label for="dampingFactorSlider">Damping: <span id="dampingFactorValue" class="control-value">0.98</span></label>
            <input type="range" id="dampingFactorSlider" min="0.8" max="1.0" step="0.001" value="0.98">
            <small>Velocity damping factor per step.</small>
        </div>

        <div class="control-group">
            <h3>Scalar Field Parameters</h3>
            <small>Base wave numbers (k) and frequency (omega) for the scalar field components.</small>
            <label for="waveKxSlider">Base k<sub>x</sub>: <span id="waveKxValue" class="control-value">1.5</span></label>
            <input type="range" id="waveKxSlider" min="0.1" max="5" step="0.1" value="1.5">
            
            <label for="waveKySlider">Base k<sub>y</sub>: <span id="waveKyValue" class="control-value">1.5</span></label>
            <input type="range" id="waveKySlider" min="0.1" max="5" step="0.1" value="1.5">

            <label for="waveKzSlider">Base k<sub>z</sub>: <span id="waveKzValue" class="control-value">1.5</span></label>
            <input type="range" id="waveKzSlider" min="0.1" max="5" step="0.1" value="1.5">

            <label for="waveOmegaSlider">Base &omega;: <span id="waveOmegaValue" class="control-value">0.5</span></label>
            <input type="range" id="waveOmegaSlider" min="0.0" max="3.0" step="0.05" value="0.5">
        </div>
        
        <button id="resetButton">Reset Simulation</button>
    </div>

    <div id="stats-bar" class="ui-panel">
        <div class="stat-item">
            <span class="stat-label">Time Elapsed</span>
            <span id="timeElapsed" class="stat-value">0.0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">FPS</span>
            <span id="fpsCounter" class="stat-value">0</span>
        </div>
         <div class="stat-item">
            <span class="stat-label">Particles</span>
            <span id="activeParticles" class="stat-value">0</span>
        </div>
    </div>

    <div id="title-card" class="ui-panel">
        <h1>Resonance: Scalar Field LSS</h1>
        <p>Interactive 3D simulation of particle dynamics under a scalar field potential, inspired by theories of Wave Dark Matter and Large Scale Structure formation. Observe emergent filamentary patterns and voids.</p>
        <p class="author-credit">Original Concept: Aldrin Payopay<br>AI Collaborators: Claude Opus 4, Gemini 2.5 Pro<br>Scalar Field LSS Mod: Agent 2</p>
    </div>

    <script>
        let scene, camera, renderer, particleSystem, controls, clock;
        let particles = [];
        let particleCount = 50000; // Default, will be set by slider
        const MAX_PARTICLES = 250000;


        const simConfig = {
            BOUNDS: 100,
            wavePotentialStrength: 0.1, // Renamed for clarity, was potentialStrength
            particleMass: 0.01,
            dampingFactor: 0.98,
            // waveParams now control base k and omega for scalar field components
            waveParams: { kx: 1.5, ky: 1.5, kz: 1.5, omega: 0.5 }, 
        };

        // Store phase offsets for scalar field components to ensure continuity
        const numScalarFieldComponents = 3; // Number of wave components for the scalar field
        let scalarFieldPhases = [];
        for(let i=0; i < numScalarFieldComponents; i++) {
            scalarFieldPhases.push(Math.random() * 2 * Math.PI); // Random initial phases
        }
        // Define slight variations for k and omega for each component to create interference
        const kVariations = [
            {x: 1.0, y: 1.0, z: 1.0},
            {x: 0.8, y: 1.1, z: 0.9},
            {x: 1.2, y: 0.9, z: 1.15}
        ];
        const omegaVariations = [1.0, 0.9, 1.1];


        let lastFrameTime = performance.now();
        let frameCount = 0;
        let simulationTime = 0;

        function init() {
            document.getElementById('loadingOverlay').style.display = 'flex';

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            clock = new THREE.Clock();

            initParticles();
            setupUI();
            
            window.addEventListener('resize', onWindowResize, false);
            
            setTimeout(() => {
                document.getElementById('loadingOverlay').style.display = 'none';
                animate();
            }, 100);
        }

        function initParticles() {
            if (particleSystem) scene.remove(particleSystem);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3); 

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3]     = (Math.random() * 2 - 1) * simConfig.BOUNDS;
                positions[i * 3 + 1] = (Math.random() * 2 - 1) * simConfig.BOUNDS;
                positions[i * 3 + 2] = (Math.random() * 2 - 1) * simConfig.BOUNDS;

                velocities[i * 3]     = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;

                color.setHSL(Math.random(), 0.7, 0.6); // Initial color, will be updated
                colors[i * 3]     = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointSize: { value: 1.5 } 
                },
                vertexShader: `
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    uniform float pointSize;
                    void main() {
                        vColor = customColor;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = pointSize * (200.0 / -mvPosition.z); 
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard; 
                        gl_FragColor = vec4(vColor, smoothstep(0.5, 0.4, dist)); 
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            document.getElementById('activeParticles').textContent = particleCount.toLocaleString();
        }
        
        // Scalar Field Potential - Inspired by Scalar Field Dark Matter / Wave Dark Matter
        // This function calculates a potential based on the superposition of multiple plane waves.
        function calculateScalarFieldPotential(x, y, z, time, config) {
            let totalPotential = 0;
            const A = config.wavePotentialStrength; // Amplitude
            const base_kx = config.waveParams.kx * Math.PI / config.BOUNDS;
            const base_ky = config.waveParams.ky * Math.PI / config.BOUNDS;
            const base_kz = config.waveParams.kz * Math.PI / config.BOUNDS;
            const base_omega = config.waveParams.omega * 0.1; // Slow down overall temporal evolution

            for (let i = 0; i < numScalarFieldComponents; i++) {
                const kx_i = base_kx * kVariations[i].x;
                const ky_i = base_ky * kVariations[i].y;
                const kz_i = base_kz * kVariations[i].z;
                const omega_i = base_omega * omegaVariations[i];
                
                totalPotential += Math.cos(
                    kx_i * x + 
                    ky_i * y + 
                    kz_i * z - 
                    omega_i * time * 0.001 + // time is in ms from main loop
                    scalarFieldPhases[i]
                );
            }
            return A * (totalPotential / numScalarFieldComponents); // Average potential
        }

        // Numerical gradient of the scalar field potential
        function calculateScalarFieldGradient(x, y, z, time, config) {
            const delta = 0.01; 
            const V0 = calculateScalarFieldPotential(x,y,z,time,config); // Avoid recomputing center point many times
            const gradX = (calculateScalarFieldPotential(x + delta, y, z, time, config) - V0) / delta; // Forward difference
            const gradY = (calculateScalarFieldPotential(x, y + delta, z, time, config) - V0) / delta;
            const gradZ = (calculateScalarFieldPotential(x, y, z + delta, time, config) - V0) / delta;
            // Or use central difference:
            // const gradX = (calculateScalarFieldPotential(x + delta, y, z, time, config) - calculateScalarFieldPotential(x - delta, y, z, time, config)) / (2 * delta);
            // const gradY = (calculateScalarFieldPotential(x, y + delta, z, time, config) - calculateScalarFieldPotential(x, y - delta, z, time, config)) / (2 * delta);
            // const gradZ = (calculateScalarFieldPotential(x, y, z + delta, time, config) - calculateScalarFieldPotential(x, y, z - delta, time, config)) / (2 * delta);
            return { x: gradX, y: gradY, z: gradZ };
        }


        function updateParticlesScalarField(deltaTime) { // Renamed from updateParticlesWaveTheory
            if (!particleSystem || !particleSystem.geometry) return;

            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            const customColors = particleSystem.geometry.attributes.customColor.array;

            const currentTime = simulationTime; 

            const currentConfig = { 
                BOUNDS: simConfig.BOUNDS,
                wavePotentialStrength: simConfig.wavePotentialStrength,
                particleMass: simConfig.particleMass,
                dampingFactor: simConfig.dampingFactor,
                waveParams: simConfig.waveParams
            };
            
            const dt = Math.min(deltaTime, 0.05); 

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];

                const gradient = calculateScalarFieldGradient(x, y, z, currentTime * 1000, currentConfig); 
                const forceX = -gradient.x; // Force is negative gradient of potential
                const forceY = -gradient.y;
                const forceZ = -gradient.z;

                velocities[i3]     += (forceX / currentConfig.particleMass) * dt;
                velocities[i3 + 1] += (forceY / currentConfig.particleMass) * dt;
                velocities[i3 + 2] += (forceZ / currentConfig.particleMass) * dt;

                velocities[i3]     *= currentConfig.dampingFactor;
                velocities[i3 + 1] *= currentConfig.dampingFactor;
                velocities[i3 + 2] *= currentConfig.dampingFactor;

                positions[i3]     += velocities[i3] * dt;
                positions[i3 + 1] += velocities[i3 + 1] * dt;
                positions[i3 + 2] += velocities[i3 + 2] * dt;

                // Boundary Conditions (simple reflection with some energy loss)
                const bound = currentConfig.BOUNDS;
                if (positions[i3] > bound || positions[i3] < -bound) { velocities[i3] *= -0.5; positions[i3] = Math.max(-bound, Math.min(bound, positions[i3]));}
                if (positions[i3+1] > bound || positions[i3+1] < -bound) { velocities[i3+1] *= -0.5; positions[i3+1] = Math.max(-bound, Math.min(bound, positions[i3+1]));}
                if (positions[i3+2] > bound || positions[i3+2] < -bound) { velocities[i3+2] *= -0.5; positions[i3+2] = Math.max(-bound, Math.min(bound, positions[i3+2]));}
                
                // Color particles based on the scalar field potential value
                const potentialValue = calculateScalarFieldPotential(positions[i3], positions[i3+1], positions[i3+2], currentTime * 1000, currentConfig);
                const normalizedPotential = (Math.tanh(potentialValue / (currentConfig.wavePotentialStrength * numScalarFieldComponents * 0.5)) + 1) / 2; // Normalize
                
                const color = new THREE.Color();
                // Color hue based on normalized potential, make high potential regions brighter/hotter
                // Example: map potential to hue (0=blue, 1=red) and lightness
                color.setHSL( (0.7 - normalizedPotential * 0.7) % 1.0, // Hue: Blue (low pot) to Red (high pot)
                              0.9, // Saturation
                              0.3 + normalizedPotential * 0.4 ); // Lightness: Dim (low pot) to Bright (high pot)

                customColors[i3]     = color.r;
                customColors[i3+1]   = color.g;
                customColors[i3+2]   = color.b;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.velocity.needsUpdate = true;
            particleSystem.geometry.attributes.customColor.needsUpdate = true;
        }

        function setupUI() {
            // Particle Count
            const pcSlider = document.getElementById('particleCountSlider');
            const pcValue = document.getElementById('particleCountValue');
            pcSlider.max = MAX_PARTICLES;
            pcSlider.value = particleCount;
            pcValue.textContent = particleCount.toLocaleString();
            pcSlider.addEventListener('input', (event) => {
                pcValue.textContent = parseInt(event.target.value).toLocaleString();
            });
            pcSlider.addEventListener('change', (event) => { 
                particleCount = parseInt(event.target.value);
                initParticles(); 
            });

            // Wave Potential Strength
            const wpsSlider = document.getElementById('wavePotentialStrengthSlider');
            const wpsValue = document.getElementById('wavePotentialStrengthValue');
            wpsSlider.value = simConfig.wavePotentialStrength;
            wpsValue.textContent = simConfig.wavePotentialStrength.toFixed(3);
            wpsSlider.addEventListener('input', (event) => {
                simConfig.wavePotentialStrength = parseFloat(event.target.value);
                wpsValue.textContent = simConfig.wavePotentialStrength.toFixed(3);
            });

            // Particle Mass
            const pmSlider = document.getElementById('particleMassSlider');
            const pmValue = document.getElementById('particleMassValue');
            pmSlider.value = simConfig.particleMass;
            pmValue.textContent = simConfig.particleMass.toFixed(3);
            pmSlider.addEventListener('input', (event) => {
                simConfig.particleMass = parseFloat(event.target.value);
                pmValue.textContent = simConfig.particleMass.toFixed(3);
            });
            
            // Damping Factor
            const dfSlider = document.getElementById('dampingFactorSlider');
            const dfValue = document.getElementById('dampingFactorValue');
            dfSlider.value = simConfig.dampingFactor;
            dfValue.textContent = simConfig.dampingFactor.toFixed(3);
            dfSlider.addEventListener('input', (event) => {
                simConfig.dampingFactor = parseFloat(event.target.value);
                dfValue.textContent = simConfig.dampingFactor.toFixed(3);
            });

            // Wave Params (now base for scalar field components)
            const wkxs = document.getElementById('waveKxSlider'); const wkxt = document.getElementById('waveKxValue');
            wkxs.value = simConfig.waveParams.kx; wkxt.textContent = simConfig.waveParams.kx.toFixed(1);
            wkxs.addEventListener('input', (e) => { simConfig.waveParams.kx = parseFloat(e.target.value); wkxt.textContent = simConfig.waveParams.kx.toFixed(1); });

            const wkys = document.getElementById('waveKySlider'); const wkyt = document.getElementById('waveKyValue');
            wkys.value = simConfig.waveParams.ky; wkyt.textContent = simConfig.waveParams.ky.toFixed(1);
            wkys.addEventListener('input', (e) => { simConfig.waveParams.ky = parseFloat(e.target.value); wkyt.textContent = simConfig.waveParams.ky.toFixed(1); });
            
            const wkzs = document.getElementById('waveKzSlider'); const wkzt = document.getElementById('waveKzValue');
            wkzs.value = simConfig.waveParams.kz; wkzt.textContent = simConfig.waveParams.kz.toFixed(1);
            wkzs.addEventListener('input', (e) => { simConfig.waveParams.kz = parseFloat(e.target.value); wkzt.textContent = simConfig.waveParams.kz.toFixed(1); });

            const wos = document.getElementById('waveOmegaSlider'); const wot = document.getElementById('waveOmegaValue');
            wos.value = simConfig.waveParams.omega; wot.textContent = simConfig.waveParams.omega.toFixed(2);
            wos.addEventListener('input', (e) => { simConfig.waveParams.omega = parseFloat(e.target.value); wot.textContent = simConfig.waveParams.omega.toFixed(2); });


            document.getElementById('resetButton').addEventListener('click', () => {
                simulationTime = 0; 
                // Re-initialize phases for a fresh pattern on reset
                for(let i=0; i < numScalarFieldComponents; i++) {
                    scalarFieldPhases[i] = Math.random() * 2 * Math.PI;
                }
                initParticles();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            simulationTime += deltaTime;

            updateParticlesScalarField(deltaTime); // Use the new update function
            
            controls.update();
            renderer.render(scene, camera);

            const currentTime = performance.now();
            frameCount++;
            if (currentTime >= lastFrameTime + 1000) {
                document.getElementById('fpsCounter').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
            }
            document.getElementById('timeElapsed').textContent = simulationTime.toFixed(1) + 's';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html> 