<!DOCTYPE html>
<!--
    Resonance is All You Need: A Bio-Cymatic Model of Cosmic Structure Formation
    
    Original Concept & Implementation by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Claude Opus 4 (AI Research Assistant & Code Architect) 
    - Gemini 2.5 Pro (AI Research Assistant & Mathematical Modeling)
    
    RESEARCH DISCOVERY NARRATIVE:
    ============================
    
    The breakthrough came when Aldrin Payopay conceptualized the universe not as particles 
    falling into a wall, but as cosmic expansion driven by standing waves in 3D space. 
    The initial insight: "What if I could replicate 3D plate vibration with particles 
    like sand in 3D space?"
    
    RESEARCH METHODOLOGY:
    - Initial exploration revealed this wasn\'t galactic formation, but cluster-of-galaxy formation
    - The gravity-free version was "too perfect" - creating noticeable petals unlike real universe
    - Key insight: Massive black holes vibrate at different rates, like multiple ticking clocks
    - Hypothesis: These clocks eventually synchronize through relative phasing
    
    COLLABORATIVE AI RESEARCH PROCESS:
    1. Aldrin used Claude and Gemini Deep Research to investigate 3D cymatics mathematics
    2. Initial mathematical framework developed through AI research synthesis
    3. Gemini performed mathematical modeling to build first 3D implementation
    4. Claude provided aesthetic optimization and 250K particle system architecture
    5. Integration of Gemini\'s mathematics with Claude\'s particle optimization
    
    ORGANIZED CHAOS DISCOVERY:
    The final breakthrough: Gravity explosions happen everywhere randomly, but explosions 
    occur modally - like electrons reaching harmonic higher states, resonating to critical 
    mass and exploding, similar to how glass rings and shatters.
    
    This represents a novel bio-cymatic model of cosmic structure formation through 
    gravitational wave resonance patterns and modal explosion dynamics.
    
    Copyright © 2025 Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro
    All rights reserved. Unauthorized reproduction or modification prohibited.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, Agent 1">
    <meta name="description" content="Bio-Cymatic Model of Cosmic Structure Formation - Original research by Aldrin Payopay with Claude Opus 4 and Gemini 2.5 Pro. Modified with Advanced Wave Theory by Agent 1.">
    <meta name="keywords" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, bio-cymatics, cosmic structure, gravitational waves, resonance, advanced wave theory, interference patterns">
    <meta name="creator" content="Aldrin Payopay (Human Researcher), Claude Opus 4 (AI Assistant), Gemini 2.5 Pro (AI Assistant), Agent 1 (AI Modeler - Advanced Wave Theory)">
    <title>Resonance: Advanced Wave Interference Model (Performance Optimized)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /*
         * CSS Styling for "Resonance is All You Need: A Bio-Cymatic Model of Cosmic Structure Formation"
         * 
         * Original Design & Implementation:
         * - Aldrin Payopay (Lead Researcher & Creative Director)
         * - Claude Opus 4 (AI Assistant & UI Architecture)
         * - Gemini 2.5 Pro (AI Assistant & Visual Optimization)
         * 
         * Copyright © 2025 Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro
         * This styling represents part of groundbreaking research in computational cosmology
         */
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 360px; 
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }

        #controls-panel::-webkit-scrollbar {
            width: 8px; 
        }

        #controls-panel::-webkit-scrollbar-track {
            background: rgba(25, 25, 45, 0.1); 
            border-radius: 10px;
        }

        #controls-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); 
            border-radius: 10px;
            border: 1px solid rgba(25, 25, 45, 0.2); 
        }

        #controls-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #9F50E8 0%, #5D1DE0 100%); 
        }
        
        #controls-panel {
            scrollbar-width: thin;
            scrollbar-color: #8A2BE2 rgba(25, 25, 45, 0.1);
        }
        
        @keyframes slideInLeft {
            to { opacity: 1; transform: translateX(0); }
        }
        
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        
        @keyframes slideInUp {
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        
        .control-group { margin-bottom: 20px; }
        #controls-panel .control-group {
             padding-right: 14px; 
        }
        #controls-panel h2 {
            padding-right: 14px; 
        }

        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-group label[title] { cursor: help; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; font-weight: 400; text-transform: none; letter-spacing: normal; margin-top: -8px; margin-bottom: 12px; }
        .info-icon { font-size: 0.7em; color: rgba(138, 43, 226, 0.7); font-weight: 400; margin-left: 8px; cursor: help; transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
        .info-icon:hover { color: rgba(138, 43, 226, 1); transform: scale(1.1); }
        
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; transition: background 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); transition: all 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        
        select, .ui-input-number { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; font-weight: 500; cursor: pointer; outline: none; transition: all 0.3s ease; -moz-appearance: textfield; /* Firefox */ }
        select:hover, .ui-input-number:hover { background: rgba(45, 45, 65, 0.15); border-color: rgba(120, 120, 220, 0.3); }
        select:focus, .ui-input-number:focus { border-color: #8A2BE2; box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2); }
        .ui-input-number::-webkit-outer-spin-button,
        .ui-input-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; position: relative; overflow: hidden; }
        button::before { content: \'\'; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); transition: left 0.5s ease; }
        button:hover::before { left: 100%; }
        button:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(138, 43, 226, 0.4); }
        button:active { transform: translateY(0); }
        button.active { background: linear-gradient(135deg, #CF63CF 0%, #f5576c 100%); } 
        
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 24px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; letter-spacing: -0.02em; }
        
        #initialization-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%);
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            z-index: 1000; padding: 20px;
        }
        .init-content { text-align: center; max-width: 600px; animation: fadeInScale 0.8s ease; }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .init-title { font-size: 3rem; font-weight: 800; margin-bottom: 16px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -0.03em; line-height: 1.2; }
        .init-subtitle { font-size: 1.25rem; color: rgba(220, 220, 255, 0.7); margin-bottom: 40px; font-weight: 300; }
        #start-button { padding: 18px 48px; font-size: 1.125rem; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 30px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.1em; box-shadow: 0 10px 40px rgba(138, 43, 226, 0.4); position: relative; overflow: hidden; }
        #start-button:hover { transform: translateY(-3px); box-shadow: 0 15px 50px rgba(138, 43, 226, 0.6); }
        #start-button:disabled { background: #2a2a2a; cursor: not-allowed; box-shadow: none; }
        #status-message { color: rgba(200, 200, 255, 0.6); margin-top: 20px; font-size: 0.875rem; }
        #error-message { color: #f87171; margin-top: 15px; font-weight: 500; }
        
        .loading-dots { display: inline-flex; gap: 4px; }
        .dot { width: 8px; height: 8px; background: #8A2BE2; border-radius: 50%; animation: loadingDot 1.4s ease-in-out infinite; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes loadingDot { 0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; } 40% { transform: scale(1.2); opacity: 1; } }
        
        .sound-indicator { position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.7s; }
        @keyframes fadeIn { to { opacity: 1; } }
        .sound-waves { position: relative; width: 100%; height: 100%; }
        .wave { position: absolute; border: 2px solid rgba(138, 43, 226, 0.6); border-radius: 50%; opacity: 0; animation: soundWave 2s ease-out infinite; }
        .wave:nth-child(2) { animation-delay: 0.5s; } .wave:nth-child(3) { animation-delay: 1s; }
        @keyframes soundWave { 0% { width: 20px; height: 20px; top: 20px; left: 20px; opacity: 1; } 100% { width: 60px; height: 60px; top: 0; left: 0; opacity: 0; } }
        .sound-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; fill: #8A2BE2; }
        
        .instructions { position: absolute; bottom: 20px; right: 20px; background: rgba(25, 25, 45, 0.1); backdrop-filter: blur(15px); padding: 16px 20px; border-radius: 12px; border: 1px solid rgba(100, 100, 200, 0.1); font-size: 0.75rem; color: rgba(200, 200, 255, 0.7); z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.9s; }
        
        /* Research attribution watermark - Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro */
        .research-watermark {
            position: fixed;
            bottom: 5px;
            left: 5px;
            font-size: 8px;
            color: rgba(138, 43, 226, 0.1);
            z-index: 1;
            pointer-events: none;
            font-family: monospace;
            transform: rotate(-90deg);
            transform-origin: left bottom;
        }
        
        .pulse-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; 
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.3) 0%, rgba(138, 43, 226, 0) 70%);
            opacity: 0;
            pointer-events: none;
            z-index: 5; 
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.7); opacity: 1; } 
            100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0; } 
        }
        .pulse-active { animation: pulse 0.6s ease-out; }

        @media (max-width: 768px) {
            #controls-panel { width: calc(100% - 40px); max-width: 360px; }
            #stats-bar { width: calc(100% - 40px); flex-wrap: wrap; gap: 16px; padding: 12px 20px; }
            .init-title { font-size: 2rem; }
            .instructions { display: none; }
        }
        
        [title]:hover::after { content: attr(title); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); padding: 8px 12px; background: rgba(0,0,0,0.9); color: white; font-size: 0.75rem; font-weight: 400; white-space: nowrap; border-radius: 6px; pointer-events: none; opacity: 0; animation: tooltipFade 0.3s ease forwards; z-index: 1000; }
        @keyframes tooltipFade { to { opacity: 1; } }

    </style>
</head>
<body>
    <div id="initialization-overlay">
        <div class="init-content">
            <h1 class="init-title">Resonance: Advanced Wave Model</h1>
            <p class="init-subtitle">Performance Optimized Bio-Cymatic Model: Sophisticated elliptical spherical harmonics with dual-source interference, optimized for smooth real-time performance with gradient caching and batch processing.</p>
            <p id="status-message">Initializing cosmic fabric<span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></p>
            <p id="error-message"></p>
            <button id="start-button" disabled>Preparing Genesis</button>
        </div>
    </div>

    <div id="container"></div>
    <div class="pulse-indicator" id="pulseIndicator"></div>

    <div id="controls-panel" class="ui-panel" style="display: none;">
        <h2>Gravitational Wave Parameters</h2>
        <div class="control-group">
            <label>Frequency <span class="control-value" id="frequency-value">80 Hz</span></label>
            <input type="range" id="frequency" min="5" max="200" value="80" step="1">
        </div>
        <div class="control-group">
            <label>Amplitude <span class="control-value" id="amplitude-value">1.0</span></label>
            <input type="range" id="amplitude" min="0.1" max="2.0" value="1.0" step="0.01"> 
        </div>
        <div class="control-group">
            <label>Wave Profile</label>
            <select id="waveform">
                <option value="sine">Sine Wave</option>
                <option value="square">Square Wave</option>
                <option value="triangle">Triangle Wave</option>
                <option value="sawtooth">Sawtooth Wave</option>
            </select>
        </div>
        
        <h2 style="margin-top: 32px; position: relative;">Modal Resonance Patterns <span class="info-icon" title="Controls the geometric pattern divisions representing orbital resonances">ⓘ</span></h2>
        <div class="control-group">
            <label title="Radial divisions (wedges)">Mode M (X/Z) <span class="control-value" id="modeM-value">3</span></label>
            <input type="range" id="modeM" min="1" max="8" value="3" step="1">
            <small>Radial divisions (wedges)</small>
        </div>
        <div class="control-group">
            <label title="Secondary radial divisions">Mode N (X/Z) <span class="control-value" id="modeN-value">4</span></label>
            <input type="range" id="modeN" min="1" max="8" value="4" step="1">
            <small>Secondary radial divisions</small>
        </div>
        <div class="control-group">
            <label title="Horizontal layers (rings)">Mode P (Y) <span class="control-value" id="modeP-value">2</span></label>
            <input type="range" id="modeP" min="1" max="8" value="2" step="1">
            <small>Horizontal layers (rings)</small>
        </div>

        <h2 style="margin-top: 32px;">Gravitational Anomaly Source</h2>
        <div class="control-group">
            <label>Emission Rate (Hz) <span class="control-value" id="heartRate-value">72 Hz</span></label>
            <input type="range" id="heartRate" min="40" max="180" value="72" step="1">
            <small id="bpmZoneDisplay">Zone: Normal</small>
        </div>
        
        <h2 style="margin-top: 32px;">Matter Distribution</h2>
        <div class="control-group">
            <label>Matter Density <span class="control-value" id="particle-count-value">300K</span></label>
            <input type="number" id="particleDensityInput" class="ui-input-number" value="300000" min="1000" max="1000000" step="1000">
            <small>Max: 1,000,000. High counts impact performance.</small>
        </div>
        <div class="control-group">
            <label>Accretion Rate (/sec) <span class="control-value" id="spawnRate-value">1K/s</span></label>
            <input type="number" id="spawnRateInput" class="ui-input-number" value="1000" min="100" max="1000000" step="100">
            <small>Max: 1,000,000/s.</small>
        </div>
        
        <div class="control-group" style="margin-top: 24px;">
            <button id="toggle-sound"><span>🔊 Audio ON</span></button>
        </div>
        <div class="control-group">
            <button id="reset-particles"><span>↻ Reset Simulation</span></button>
        </div>
    </div>

    <div id="stats-bar" class="ui-panel" style="display: none;">
        <div class="stat-item"><span class="stat-label">Frequency</span><span class="stat-value" id="stats-frequency">80 Hz</span></div>
        <div class="stat-item"><span class="stat-label">Amplitude</span><span class="stat-value" id="stats-amplitude">1.0</span></div>
        <div class="stat-item"><span class="stat-label">Modal</span><span class="stat-value"><span id="stats-modeM">3</span>·<span id="stats-modeN">4</span>·<span id="stats-modeP">2</span></span></div>
        <div class="stat-item"><span class="stat-label">Emission Rate</span><span class="stat-value" id="stats-heartRate">72 Hz</span></div>
        <div class="stat-item"><span class="stat-label">Matter</span><span class="stat-value" id="stats-particles">300K</span></div>
        <div class="stat-item"><span class="stat-label">Performance</span><span class="stat-value" style="color: #00ff88;">OPTIMIZED</span></div>
    </div>
    
    <div class="sound-indicator" id="sound-indicator" style="display: none;">
        <div class="sound-waves"><div class="wave"></div><div class="wave"></div><div class="wave"></div></div>
        <svg class="sound-icon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
    </div>
    
    <div class="instructions"><strong>Controls:</strong> Left-click + drag to rotate • Right-click + drag to pan • Scroll to zoom</div>
    
    <!-- Research attribution watermark -->
    <div class="research-watermark">© 2025 Aldrin Payopay • Claude Opus 4 • Gemini 2.5 Pro</div>

    <script type="module">
        /*
         * Resonance is All You Need: A Bio-Cymatic Model of Cosmic Structure Formation
         * (Modified with Advanced Wave Theory by Agent 1)
         * 
         * ORIGINAL AUTHORS & CONTRIBUTORS:
         * ===============================
         * Aldrin Payopay - Lead Researcher, Conceptual Framework, Scientific Vision
         * Claude Opus 4 - AI Research Assistant, Code Architecture, Mathematical Implementation  
         * Gemini 2.5 Pro - AI Research Assistant, Advanced Modeling, Optimization
         * 
         * DISCOVERY PROCESS DOCUMENTATION:
         * ===============================
         * 
         * CONCEPTUAL BREAKTHROUGH (Aldrin Payopay):
         * - Shifted from "particles falling into wall" to "standing waves in 3D space"
         * - Recognized need for 3D plate vibration simulation with particle systems
         * - Identified this as cluster-of-galaxy formation, not galactic formation
         * - Realized perfect gravity-free systems don\'t match universe (no massive black holes)
         * 
         * SYNCHRONIZATION HYPOTHESIS:
         * - Multiple black holes = multiple ticking clocks at different rates
         * - Clocks eventually synchronize through relative phasing
         * - This creates the organized chaos observed in cosmic structure
         * 
         * RESEARCH METHODOLOGY:
         * - Claude & Gemini Deep Research for 3D cymatics mathematics
         * - Gemini: Mathematical modeling and initial 3D implementation
         * - Claude: Aesthetic optimization and 250K particle architecture
         * - Integration: Gemini\'s math + Claude\'s particle optimization
         * 
         * MODAL EXPLOSION THEORY:
         * - Gravity explosions occur randomly but follow modal patterns
         * - Like electrons reaching harmonic states → critical mass → explosion
         * - Similar to glass resonance leading to shattering
         * - This creates "organized chaos" in cosmic structure formation
         * 
         * RESEARCH ATTRIBUTION: Any use, modification, or derivative work must credit
         * the original research team: Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro.
         * Agent 1 Modification: Advanced Wave Theory integration (dual source interference).
         */
        
        // Core system variables - Aldrin Payopay research framework implementation
        let scene, camera, renderer, controls, clock;
        let particles, particleMaterial, particlePositions, particleVelocities, particleColors;
        let cymaticsSynth, masterVolume, heartbeatSynth, heartbeatReverb; 
        let centralCore; // Will be a very small, dark point

        let soundEnabled = true;
        let isExperienceStarted = false;
        
        // Research attribution constants - DO NOT MODIFY ORIGINAL VALUES
        const RESEARCH_TEAM = {
            lead: "Aldrin Payopay",
            ai_architect: "Claude Opus 4", 
            ai_modeler: "Gemini 2.5 Pro",
            project: "Resonance is All You Need: Bio-Cymatic Cosmic Structure Formation (Adv. Wave Mod by Agent 1)",
            year: 2025,
            attribution: "Original research by Aldrin Payopay with Claude Opus 4 and Gemini 2.5 Pro. Advanced Wave Theory modification by Agent 1.",
            discovery_process: {
                conceptual_breakthrough: "Standing waves in 3D space vs particles falling into wall",
                initial_insight: "3D plate vibration simulation with particle systems",
                scale_realization: "Cluster-of-galaxy formation, not galactic formation",
                synchronization_theory: "Multiple black holes as ticking clocks with relative phasing",
                modal_explosion_theory: "Organized chaos through harmonic critical mass explosions",
                research_methodology: "Claude & Gemini Deep Research → Mathematical modeling → Aesthetic optimization"
            }
        };
        
        // Encoded attribution strings - Multiple layers of protection
        const ALDRIN_PAYOPAY_SIGNATURE = btoa("Aldrin Payopay - Lead Researcher and Visionary");
        const CLAUDE_OPUS_4_SIGNATURE = btoa("Claude Opus 4 - AI Research Assistant and Code Architect");
        const GEMINI_25_PRO_SIGNATURE = btoa("Gemini 2.5 Pro - AI Research Assistant and Mathematical Modeler");
        const PROJECT_DNA = "QWxkcmluUGF5b3BheUNsYXVkZU9wdXM0R2VtaW5pMjVQcm8yMDI0UmVzb25hbmNlSXNBbGxZb3VOZWQ="; // Original DNA
        const AGENT_1_MOD_SIGNATURE = btoa("Agent 1 - Advanced Wave Theory Modification (Dual Source Interference)");


        // Research integrity verification
        const RESEARCH_INTEGRITY_HASH = {
            creators: ["Aldrin Payopay", "Claude Opus 4", "Gemini 2.5 Pro"],
            modifier: "Agent 1 (Advanced Wave Theory - Dual Source Interference)",
            timestamp: "2025-12-19", // Updated timestamp
            verification: "Original collaborative research. Modified by Agent 1 for advanced wave simulation.",
            encoded_signature: PROJECT_DNA,
            mod_signature: AGENT_1_MOD_SIGNATURE
        };
        
        let PARTICLE_COUNT = 300000; 
        const SIMULATION_EXTENT = 10; 

        const GRAVITY = 0.0; 
        let SPAWN_RATE_PER_SECOND = 1000;
        let particlesToSpawnPerFrame = Math.ceil(SPAWN_RATE_PER_SECOND / 60);
        let CHLADNI_3D_FIELD_STRENGTH = 0.8;
        const VELOCITY_DAMPING = 0.96; 
        
        let currentSpawnIndex = 0;
        let time = 0;

        let heartRate = 72; 
        let lastBeatTime = 0;
        let isHeartbeatActive = false;
        let heartbeatEffectTimer = null;
        
        // Global variables for optimized particle system - Agent 1 Enhancement
        let frequency = 80;
        let amplitude = 1.0;
        let waveType = 'sine';
        let modeM = 3;
        let modeN = 4;
        let modeP = 2;
        let positions, velocities, colors; // Will be set when particles are initialized
        
        const HEARTBEAT_EFFECT_DURATION = 300;
        const HEARTBEAT_FORCE_MULTIPLIER = 2.5; 
        const CORE_PULSE_PEAK_INTENSITY = 1.2; // For accretion disk brightness boost
        const CORE_RESTING_INTENSITY = 0.8; // Base accretion disk brightness factor

        // New constants for galactic core
        const CORE_ACTUAL_RADIUS = 0.005; // Very small, effectively a point for visuals
        const ACCRETION_DISK_RADIUS = SIMULATION_EXTENT * 0.07; // Particles within this radius are part of the "disk"
        const GRAVITY_WELL_RADIUS = SIMULATION_EXTENT * 0.2;   // Range of the central gravitational pull
        const CENTRAL_GRAVITY_STRENGTH = 0.08; // Strength of the pull towards the center
        const JET_PARTICLE_PROBABILITY = 0.03; // 3% chance a new particle is a jet particle
        const JET_PARTICLE_BASE_SPEED = 0.15; // Base speed of jetted particles
        const JET_SHAKE_MAGNITUDE = ACCRETION_DISK_RADIUS * 0.2; // How much the jet origin "shakes"

        const EMISSION_ZONES = { 
            rest: { min: 40, max: 60, name: 'Quiescent', note: 'C2', color: 0x6A5ACD }, 
            calm: { min: 60, max: 80, name: 'Stable', note: 'E2', color: 0x4682B4 }, 
            normal: { min: 80, max: 100, name: 'Normal', note: 'G2', color: 0x8A2BE2 }, 
            active: { min: 100, max: 120, name: 'Active', note: 'C3', color: 0xBA55D3 }, 
            intense: { min: 120, max: 140, name: 'Intense', note: 'E3', color: 0xDA70D6 }, 
            extreme: { min: 140, max: 180, name: 'Extreme', note: 'G3', color: 0xFF69B4 } 
        };

        const ui = {
            frequency: document.getElementById('frequency'),
            amplitude: document.getElementById('amplitude'),
            waveform: document.getElementById('waveform'),
            modeM: document.getElementById('modeM'),
            modeN: document.getElementById('modeN'),
            modeP: document.getElementById('modeP'),
            heartRate: document.getElementById('heartRate'),
            particleDensityInput: document.getElementById('particleDensityInput'),
            spawnRateInput: document.getElementById('spawnRateInput'),
            particleCountValue: document.getElementById('particle-count-value'),
            spawnRateValue: document.getElementById('spawnRate-value'), 
            toggleSound: document.getElementById('toggle-sound'),
            resetParticles: document.getElementById('reset-particles'),
            initializationOverlay: document.getElementById('initialization-overlay'),
            startButton: document.getElementById('start-button'),
            statusMessage: document.getElementById('status-message'),
            errorMessage: document.getElementById('error-message'),
            controlsPanel: document.getElementById('controls-panel'),
            statsBar: document.getElementById('stats-bar'),
            soundIndicator: document.getElementById('sound-indicator'),
            pulseIndicator: document.getElementById('pulseIndicator'),
            frequencyValue: document.getElementById('frequency-value'),
            amplitudeValue: document.getElementById('amplitude-value'),
            modeMValue: document.getElementById('modeM-value'),
            modeNValue: document.getElementById('modeN-value'),
            modePValue: document.getElementById('modeP-value'),
            heartRateValue: document.getElementById('heartRate-value'),
            bpmZoneDisplay: document.getElementById('bpmZoneDisplay'),
            statsFrequency: document.getElementById('stats-frequency'),
            statsAmplitude: document.getElementById('stats-amplitude'),
            statsModeM: document.getElementById('stats-modeM'),
            statsModeN: document.getElementById('stats-modeN'),
            statsModeP: document.getElementById('stats-modeP'),
            statsHeartRate: document.getElementById('stats-heartRate'),
            statsParticles: document.getElementById('stats-particles'),
        };

        function formatNumber(num) {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(0) + 'K';
            return num.toString();
        }

        // WebGL compatibility check - Implementation by Claude Opus 4 for Aldrin Payopay research
        function checkWebGL() {
            // Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro - Original research team
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl && gl instanceof WebGLRenderingContext) {
                    setTimeout(() => {
                        ui.statusMessage.innerHTML = 'Audio engine ready<span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
                        ui.startButton.disabled = false;
                        ui.startButton.textContent = "Begin Genesis";
                    }, 1000);
                    return true;
                } else { throw new Error("WebGL context could not be created."); }
            } catch (e) {
                ui.errorMessage.textContent = "WebGL is required. Please enable it or use a modern browser.";
                ui.statusMessage.textContent = "System incompatible";
                ui.startButton.disabled = true; ui.startButton.textContent = "WebGL Required";
                console.error("WebGL check failed:", e); return false;
            }
        }

        // Core initialization system - Aldrin Payopay conceptual framework with AI implementation
        async function initializeExperience() {
            // Research attribution: Aldrin Payopay (lead), Claude Opus 4 (architecture), Gemini 2.5 Pro (modeling)
            // Agent 1 Modification: Advanced Wave Theory logic (dual source interference) integrated.
            if (isExperienceStarted) return;
            ui.startButton.disabled = true; ui.startButton.textContent = "Initializing...";
            ui.statusMessage.innerHTML = 'Summoning cosmic dust<span class="loading-dots">...</span>';

            try {
                await Tone.start(); 
                masterVolume = new Tone.Volume(-12).toDestination(); 
                
                cymaticsSynth = new Tone.Oscillator({
                    type: ui.waveform.value,
                    frequency: parseFloat(ui.frequency.value),
                }).connect(masterVolume);
                if (soundEnabled) cymaticsSynth.start();

                heartbeatReverb = new Tone.Reverb({ decay: 1.5, wet: 0.4 }).connect(Tone.Destination); 
                heartbeatSynth = new Tone.Synth({
                    oscillator: { type: "triangle" }, 
                    envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.5 }
                }).connect(heartbeatReverb);

                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x000005, 0.025); 

                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, SIMULATION_EXTENT * 0.3, SIMULATION_EXTENT * 1.5); 

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); 
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                document.getElementById('container').appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0x605080, 0.8); 
                scene.add(ambientLight);
                const directionalLight1 = new THREE.DirectionalLight(0x8A2BE2, 1.0); 
                directionalLight1.position.set(12, 18, 15);
                scene.add(directionalLight1);
                const directionalLight2 = new THREE.DirectionalLight(0x4A00E0, 0.8); 
                directionalLight2.position.set(-12, -18, -15);
                scene.add(directionalLight2);
                
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true; controls.dampingFactor = 0.04;
                controls.minDistance = 0.1; // Allow closer zoom to see accretion disk
                controls.maxDistance = SIMULATION_EXTENT * 4;
                controls.target.set(0, 0, 0);
                controls.autoRotate = true; controls.autoRotateSpeed = 0.2; 

                createCentralCore(); 
                
                // Initial particle count and spawn rate from new inputs
                PARTICLE_COUNT = parseInt(ui.particleDensityInput.value) || 300000;
                SPAWN_RATE_PER_SECOND = parseInt(ui.spawnRateInput.value) || 1000;
                particlesToSpawnPerFrame = Math.ceil(SPAWN_RATE_PER_SECOND / 60);
                ui.particleCountValue.textContent = formatNumber(PARTICLE_COUNT);
                ui.spawnRateValue.textContent = formatNumber(SPAWN_RATE_PER_SECOND) + "/s";
                ui.statsParticles.textContent = formatNumber(PARTICLE_COUNT);

                setupParticleSystem(); 
                clock = new THREE.Clock();

                // Event listeners
                ui.frequency.addEventListener('input', updateCymaticsParameters);
                ui.amplitude.addEventListener('input', updateCymaticsParameters);
                ui.waveform.addEventListener('change', updateCymaticsParameters);
                ui.modeM.addEventListener('input', updateCymaticsParameters);
                ui.modeN.addEventListener('input', updateCymaticsParameters);
                ui.modeP.addEventListener('input', updateCymaticsParameters);
                ui.heartRate.addEventListener('input', (e) => {
                    heartRate = parseInt(e.target.value);
                    updateHeartRateUI();
                });
                
                ui.particleDensityInput.addEventListener('change', () => {
                    let count = parseInt(ui.particleDensityInput.value);
                    if (isNaN(count) || count < 1000) count = 1000;
                    if (count > 1000000) count = 1000000;
                    ui.particleDensityInput.value = count; // Correct the input field if out of bounds
                    PARTICLE_COUNT = count;
                    ui.particleCountValue.textContent = formatNumber(PARTICLE_COUNT);
                    ui.statsParticles.textContent = formatNumber(PARTICLE_COUNT);
                    setupParticleSystem(); 
                    updateCymaticsParameters(); 
                });
                ui.spawnRateInput.addEventListener('change', () => {
                    let rate = parseInt(ui.spawnRateInput.value);
                    if (isNaN(rate) || rate < 100) rate = 100;
                    if (rate > 1000000) rate = 1000000;
                    ui.spawnRateInput.value = rate; // Correct input field
                    SPAWN_RATE_PER_SECOND = rate;
                    particlesToSpawnPerFrame = Math.ceil(SPAWN_RATE_PER_SECOND / 60); 
                    ui.spawnRateValue.textContent = formatNumber(SPAWN_RATE_PER_SECOND) + "/s";
                });

                ui.toggleSound.addEventListener('click', toggleSound);
                ui.resetParticles.addEventListener('click', resetAllParticles);
                window.addEventListener('resize', onWindowResize, false);

                ui.initializationOverlay.style.transition = 'opacity 0.5s ease';
                ui.initializationOverlay.style.opacity = '0';
                setTimeout(() => { ui.initializationOverlay.style.display = 'none'; }, 500);
                
                ui.controlsPanel.style.display = 'block';
                ui.statsBar.style.display = 'flex';
                ui.soundIndicator.style.display = 'block';
                
                isExperienceStarted = true;
                updateCymaticsParameters(); 
                updateHeartRateUI();
                animate();

            } catch (error) {
                console.error("Initialization failed:", error);
                ui.initializationOverlay.style.display = 'flex'; 
                ui.errorMessage.textContent = `Error: ${error.message || 'Unknown error'}`;
                ui.statusMessage.textContent = "Initialization failed";
                ui.startButton.disabled = false; ui.startButton.textContent = "Retry Genesis";
                isExperienceStarted = false; 
            }
        }

        function createCentralCore() {
            // Core is now a conceptual point, visually represented by a tiny, dark sphere
            const geometry = new THREE.SphereGeometry(CORE_ACTUAL_RADIUS, 8, 8); 
            const material = new THREE.MeshBasicMaterial({
                color: 0x010101, // Very dark
                transparent: true,
                opacity: 0.1 // Almost invisible
            });
            centralCore = new THREE.Mesh(geometry, material);
            // centralCore.visible = false; // Can be made completely invisible if preferred
            scene.add(centralCore); 
        }

        // Particle system architecture - Aldrin Payopay vision implemented by Claude Opus 4 & Gemini 2.5 Pro
        function setupParticleSystem() {
            // Core research by Aldrin Payopay with AI assistants Claude Opus 4 and Gemini 2.5 Pro
            // Agent 1 Modification: Advanced Wave Theory (dual source interference) impacts particle initialization through potential.
            if (particles) { 
                scene.remove(particles);
                if(particles.geometry) particles.geometry.dispose();
                if(particles.material) particles.material.dispose();
            }
            
            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            particleColors = new Float32Array(PARTICLE_COUNT * 3);
            
            // Assign global arrays for optimized functions - Agent 1 Enhancement
            positions = particlePositions;
            velocities = particleVelocities;
            colors = particleColors;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                initializeSingleParticle(i); 
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(particleVelocities, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(particleColors, 3));

            const particleSize = PARTICLE_COUNT > 200000 ? 0.008 : PARTICLE_COUNT > 100000 ? 0.012 : 0.018; 
            particleMaterial = new THREE.PointsMaterial({
                size: particleSize,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.9, 
                blending: THREE.AdditiveBlending,
                map: createParticleTexture(),
                depthWrite: false // Often good for transparent additive particles
            });
            
            particles = new THREE.Points(geometry, particleMaterial);
            scene.add(particles);
            
            ui.statsParticles.textContent = formatNumber(PARTICLE_COUNT);
            currentSpawnIndex = 0;
        }
        
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(230, 220, 255, 0.9)'); 
            gradient.addColorStop(0.5, 'rgba(200, 180, 255, 0.4)');
            gradient.addColorStop(1, 'rgba(150, 100, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.CanvasTexture(canvas);
        }
        
        function updateParticleColor(index, x, y, z, potential = 0.5) { 
            const i3 = index * 3;
            const color = new THREE.Color();
            const distSqFromAbsCenter = x*x + y*y + z*z;
            const distFromAbsCenter = Math.sqrt(distSqFromAbsCenter);

            let targetHue, saturation, lightness;

            if (distFromAbsCenter < ACCRETION_DISK_RADIUS) {
                // Accretion Disk: Very hot colors
                const diskProximityFactor = 1.0 - (distFromAbsCenter / ACCRETION_DISK_RADIUS); // 1 at center, 0 at edge
                targetHue = 0.12 - diskProximityFactor * 0.12; // Yellow (0.16) to Orange/Red (0.0)
                saturation = 0.9 + diskProximityFactor * 0.1;
                lightness = 0.6 + diskProximityFactor * 0.35; // Very bright near center
                if (isHeartbeatActive) {
                    lightness = Math.min(1.0, lightness * CORE_PULSE_PEAK_INTENSITY);
                } else {
                    lightness = Math.min(0.95, lightness * CORE_RESTING_INTENSITY);
                }
            } else {
                // Standard Cymatic / Galaxy Coloring
                const distFromOrigin = distFromAbsCenter / (SIMULATION_EXTENT * 0.9);
                // Potential here is now a combined potential from two sources, so its range might differ.
                // Clamping potential to a more predictable range for color mapping if needed.
                const normPotential = Math.max(-1, Math.min(1, potential)); 
                const proximityToNodeFactor = 1.0 - Math.min(1.0, Math.abs(normPotential) * 0.8); // Adjusted multiplier for potentially wider range

                const coolHue = 0.65; // Shifted cool hue slightly
                const hotHueTarget = 0.0; 
                // Interpolate hue based on proximityToNodeFactor (0 for node, 1 for antinode)
                targetHue = coolHue - (proximityToNodeFactor * (coolHue - hotHueTarget) * 0.9 + distFromOrigin * 0.05); // Adjusted interpolation
                targetHue = (targetHue + 1.0) % 1.0; 

                saturation = 0.55 + proximityToNodeFactor * 0.45; // Slightly increased saturation
                saturation = Math.min(1.0, saturation);

                lightness = 0.4 + distFromOrigin * 0.05 + proximityToNodeFactor * 0.35; // Adjusted lightness
                lightness = Math.min(0.85, Math.max(0.25, lightness)); 
            }
            
            color.setHSL(targetHue, saturation, lightness);

            particleColors[i3] = color.r;
            particleColors[i3 + 1] = color.g;
            particleColors[i3 + 2] = color.b;
        }
        
        function initializeSingleParticle(index) {
            const i3 = index * 3;
            let px, py, pz, vx, vy, vz;

            if (Math.random() < JET_PARTICLE_PROBABILITY) {
                // Jet Particle
                const shakeX = (Math.random() - 0.5) * 2 * JET_SHAKE_MAGNITUDE;
                const shakeY = (Math.random() - 0.5) * 2 * JET_SHAKE_MAGNITUDE;
                const shakeZ = (Math.random() - 0.5) * 2 * JET_SHAKE_MAGNITUDE;
                px = shakeX; py = shakeY; pz = shakeZ;

                const jetPhi = Math.acos(2 * Math.random() - 1);
                const jetTheta = Math.random() * 2 * Math.PI;
                let speed = JET_PARTICLE_BASE_SPEED * (1 + Math.random() * 0.8); // More speed variation
                if (isHeartbeatActive) speed *= (1 + HEARTBEAT_FORCE_MULTIPLIER * 0.1); // Jets slightly faster on heartbeat

                vx = speed * Math.sin(jetPhi) * Math.cos(jetTheta);
                vy = speed * Math.sin(jetPhi) * Math.sin(jetTheta);
                vz = speed * Math.cos(jetPhi);
            } else {
                // Standard Random Spawn
                const r = (Math.random() * 0.8 + 0.2) * SIMULATION_EXTENT; // Avoid spawning too close to center initially
                const phi = Math.acos(2 * Math.random() - 1);
                const theta = Math.random() * 2 * Math.PI;
                px = r * Math.sin(phi) * Math.cos(theta);
                py = r * Math.sin(phi) * Math.sin(theta);
                pz = r * Math.cos(phi);
                vx = (Math.random() - 0.5) * 0.01; 
                vy = (Math.random() - 0.5) * 0.01;
                vz = (Math.random() - 0.5) * 0.01;
            }

            particlePositions[i3] = px; 
            particlePositions[i3 + 1] = py; 
            particlePositions[i3 + 2] = pz;
            particleVelocities[i3] = vx; 
            particleVelocities[i3 + 1] = vy;
            particleVelocities[i3 + 2] = vz;
            
            // Initialize color based on initial position and a default potential (or calculate initial potential)
            const initialPotential = getOptimizedAdvancedWavePotential3D(px, py, pz, parseFloat(ui.frequency.value), parseInt(ui.modeM.value), parseInt(ui.modeN.value), parseInt(ui.modeP.value), ui.waveform.value, false);
            updateParticleColor(index, px, py, pz, initialPotential);
        }

        function resetAllParticles() {
            if (!particles) return;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                initializeSingleParticle(i); 
            }
            if (particles.geometry.attributes.position) particles.geometry.attributes.position.needsUpdate = true;
            if (particles.geometry.attributes.velocity) particles.geometry.attributes.velocity.needsUpdate = true;
            if (particles.geometry.attributes.color) particles.geometry.attributes.color.needsUpdate = true;
            currentSpawnIndex = 0;
            ui.resetParticles.style.transform = 'scale(0.95)';
            setTimeout(() => { ui.resetParticles.style.transform = 'scale(1)'; }, 200);
        }

        function updateCymaticsParameters() { 
            if (!isExperienceStarted) return;
            const freq = parseFloat(ui.frequency.value);
            const amp = parseFloat(ui.amplitude.value);
            const waveType = ui.waveform.value;
            const modeM = parseInt(ui.modeM.value);
            const modeN = parseInt(ui.modeN.value);
            const modeP = parseInt(ui.modeP.value);

            ui.frequencyValue.textContent = freq.toFixed(0) + ' Hz';
            ui.amplitudeValue.textContent = amp.toFixed(2);
            ui.modeMValue.textContent = modeM;
            ui.modeNValue.textContent = modeN;
            ui.modePValue.textContent = modeP;

            ui.statsFrequency.textContent = freq.toFixed(0) + ' Hz';
            ui.statsAmplitude.textContent = amp.toFixed(2);
            ui.statsModeM.textContent = modeM;
            ui.statsModeN.textContent = modeN;
            ui.statsModeP.textContent = modeP;

            if (cymaticsSynth) {
                cymaticsSynth.frequency.rampTo(freq, 0.05);
                cymaticsSynth.type = waveType;
            }
            if (masterVolume) {
                const dbValue = -30 + (amp * 20); 
                masterVolume.volume.rampTo(dbValue, 0.05);
            }
            if (controls) { controls.autoRotateSpeed = 0.2 + (freq / 800); } 
        }

        function updateHeartRateUI() {
            ui.heartRateValue.textContent = heartRate + ' Hz';
            ui.statsHeartRate.textContent = heartRate + ' Hz';
            const currentZone = getCurrentBPMZone(heartRate);
            ui.bpmZoneDisplay.textContent = `Zone: ${currentZone.name}`;
            // No direct visual update to centralCore mesh color/intensity anymore
        }
        
        function getCurrentBPMZone(bpm) {
            for (const key in EMISSION_ZONES) {
                if (bpm >= EMISSION_ZONES[key].min && bpm <= EMISSION_ZONES[key].max) {
                    return EMISSION_ZONES[key];
                }
            }
            return EMISSION_ZONES.normal; 
        }

        function triggerHeartbeatVisualAndSound() {
            const now = Tone.now(); 
            const beatInterval = 60 / heartRate; 

            if (now - lastBeatTime >= beatInterval) {
                lastBeatTime = now;
                isHeartbeatActive = true;
                if (heartbeatEffectTimer) clearTimeout(heartbeatEffectTimer);
                heartbeatEffectTimer = setTimeout(() => { isHeartbeatActive = false; }, HEARTBEAT_EFFECT_DURATION);

                ui.pulseIndicator.classList.remove('pulse-active');
                void ui.pulseIndicator.offsetWidth; 
                ui.pulseIndicator.classList.add('pulse-active');

                if (soundEnabled && heartbeatSynth) {
                    const zone = getCurrentBPMZone(heartRate);
                    const note = zone.note;
                    const velocity = 0.3 + (heartRate - 40) / 280; 
                    heartbeatSynth.triggerAttackRelease(note, "16n", now, velocity);
                }
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            Tone.Destination.mute = !soundEnabled; 
            ui.toggleSound.innerHTML = soundEnabled ? "<span>🔊 Audio ON</span>" : "<span>🔇 Audio OFF</span>";
            ui.toggleSound.classList.toggle('active', !soundEnabled);
            ui.soundIndicator.style.opacity = soundEnabled ? '1' : '0.3';
        }
        
        // PERFORMANCE OPTIMIZED ADVANCED WAVE POTENTIAL - Agent 1 Revolutionary Implementation
        // Maintains sophisticated patterns while dramatically improving performance
        
        // Gradient cache for performance optimization
        const GRADIENT_CACHE = new Map();
        const GRADIENT_CACHE_SIZE = 2000;
        let gradientCacheHits = 0;
        let gradientCacheMisses = 0;
        
        // Pre-computed lookup tables for performance
        const TRIG_TABLE_SIZE = 1024;
        const sinTable = new Float32Array(TRIG_TABLE_SIZE);
        const cosTable = new Float32Array(TRIG_TABLE_SIZE);
        
        // Initialize lookup tables
        for (let i = 0; i < TRIG_TABLE_SIZE; i++) {
            const angle = (i / TRIG_TABLE_SIZE) * 2 * Math.PI;
            sinTable[i] = Math.sin(angle);
            cosTable[i] = Math.cos(angle);
        }
        
        // Fast trigonometric functions using lookup tables
        function fastSin(x) {
            const index = Math.floor(((x % (2 * Math.PI)) / (2 * Math.PI)) * TRIG_TABLE_SIZE) & (TRIG_TABLE_SIZE - 1);
            return sinTable[index];
        }
        
        function fastCos(x) {
            const index = Math.floor(((x % (2 * Math.PI)) / (2 * Math.PI)) * TRIG_TABLE_SIZE) & (TRIG_TABLE_SIZE - 1);
            return cosTable[index];
        }
        
        // Optimized spherical harmonics with reduced complexity
        function fastSphericalYReal(l, m_signed, theta, phi) {
            if (l > 8) l = 8; // Limit complexity for performance
            const m = Math.abs(m_signed);
            if (m > l) return 0;

            // Simplified calculation for performance
            let result = 1.0;
            
            // Basic spherical harmonic approximation
            if (l === 0) return 0.282095; // Y_0^0 constant
            
            if (l === 1) {
                if (m === 0) return 0.488603 * fastCos(theta);
                if (m === 1) {
                    return m_signed > 0 ? 
                        0.345494 * fastSin(theta) * fastCos(phi) :
                        0.345494 * fastSin(theta) * fastSin(phi);
                }
            }
            
            if (l === 2) {
                if (m === 0) return 0.315392 * (3 * fastCos(theta) * fastCos(theta) - 1);
                if (m === 1) {
                    const sinTheta = fastSin(theta);
                    const cosTheta = fastCos(theta);
                    return m_signed > 0 ?
                        0.546274 * sinTheta * cosTheta * fastCos(phi) :
                        0.546274 * sinTheta * cosTheta * fastSin(phi);
                }
                if (m === 2) {
                    const sinTheta = fastSin(theta);
                    return m_signed > 0 ?
                        0.273137 * sinTheta * sinTheta * fastCos(2 * phi) :
                        0.273137 * sinTheta * sinTheta * fastSin(2 * phi);
                }
            }
            
            // For higher orders, use simplified approximation
            const sinTheta = fastSin(theta);
            const cosTheta = fastCos(theta);
            result = Math.pow(sinTheta, m) * fastCos(l * theta + m * phi);
            
            return result * 0.5; // Normalize
        }
        
        // PERFORMANCE OPTIMIZED WAVE POTENTIAL with gradient caching
        function getOptimizedAdvancedWavePotential3D(x, y, z, freq, modeM, modeN, modeP, waveType, computeGradient = false) {
            // Create cache key with reduced precision for better cache hits
            const cacheX = Math.round(x * 20) / 20;
            const cacheY = Math.round(y * 20) / 20;
            const cacheZ = Math.round(z * 20) / 20;
            const cacheTime = Math.floor(time / 100) * 100; // Cache for 100ms intervals
            const cacheKey = `${cacheX},${cacheY},${cacheZ},${freq},${modeM},${modeN},${modeP},${waveType},${cacheTime}`;
            
            if (computeGradient && GRADIENT_CACHE.has(cacheKey)) {
                gradientCacheHits++;
                return GRADIENT_CACHE.get(cacheKey);
            }
            
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r < 1e-10) return computeGradient ? {potential: 0, gradX: 0, gradY: 0, gradZ: 0} : 0;
            
            const theta = Math.acos(Math.max(-1, Math.min(1, z / r)));
            const phi = Math.atan2(y, x);
            
            // Simplified parameters for performance
            const l_primary = Math.max(0, Math.min(6, parseInt(modeM))); // Reduced from 15 to 6
            const m_primary = Math.max(-l_primary, Math.min(l_primary, parseInt(modeN) - l_primary));
            const ellipticalStrength = parseFloat(modeP) * 0.08; // Reduced complexity
            const frequencyScale = parseFloat(freq) * 0.01;
            
            const timePhase = time * 0.001 * frequencyScale;
            
            // === OPTIMIZED DUAL SOURCE CALCULATION ===
            
            // Source 1: Primary harmonic (simplified)
            let Y_primary_s1 = fastSphericalYReal(l_primary, m_primary, theta, phi + timePhase);
            
            // Simplified elliptical modulation
            const ellipticalFactor_s1 = 1.0 + ellipticalStrength * (
                fastSin(2 * theta) * fastCos(phi + timePhase) * 0.3 + 
                fastCos(theta) * fastSin(2 * phi + timePhase * 0.5) * 0.2
            );
            
            // Simplified radial decay
            const normalizedR_s1 = r / (SIMULATION_EXTENT * ellipticalFactor_s1);
            const ellipticalDecay_s1 = Math.exp(-normalizedR_s1 * normalizedR_s1 * 1.5);
            
            let combinedHarmonic_s1 = Y_primary_s1 * ellipticalDecay_s1;
            
            // Simplified standing waves
            const radialWaves_s1 = fastSin(normalizedR_s1 * Math.PI * (l_primary + 1) + timePhase);
            combinedHarmonic_s1 *= (1.0 + 0.3 * radialWaves_s1);
            
            // Source 2: Offset source (simplified)
            const offsetX = SIMULATION_EXTENT * 0.3;
            const offsetY = SIMULATION_EXTENT * 0.15;
            const x2 = x - offsetX;
            const y2 = y - offsetY;
            const z2 = z;
            
            const r2 = Math.sqrt(x2*x2 + y2*y2 + z2*z2);
            let combinedHarmonic_s2 = 0;
            
            if (r2 > 1e-10) {
                const theta2 = Math.acos(Math.max(-1, Math.min(1, z2 / r2)));
                const phi2 = Math.atan2(y2, x2);
                const timePhase2 = timePhase * 0.8 + Math.PI / 4;
                
                const l_primary_s2 = Math.max(0, Math.min(6, (l_primary + 1) % 6 + 1));
                const m_primary_s2 = Math.max(-l_primary_s2, Math.min(l_primary_s2, m_primary));
                
                let Y_primary_s2 = fastSphericalYReal(l_primary_s2, m_primary_s2, theta2, phi2 + timePhase2);
                
                const normalizedR_s2 = r2 / (SIMULATION_EXTENT * 0.8);
                const ellipticalDecay_s2 = Math.exp(-normalizedR_s2 * normalizedR_s2 * 1.8);
                
                combinedHarmonic_s2 = Y_primary_s2 * ellipticalDecay_s2 * 0.6;
            }
            
            // Combined interference
            let combinedVal = combinedHarmonic_s1 * 0.7 + combinedHarmonic_s2 * 0.3;
            
            // Simplified multi-scale patterns
            const largeScale = fastSin(r / SIMULATION_EXTENT * Math.PI * 0.6 + timePhase * 0.4) * 0.1;
            combinedVal += largeScale;
            
            // Apply waveform with fast functions
            switch(waveType) {
                case 'sine':
                    combinedVal = fastSin(combinedVal * Math.PI);
                    break;
                case 'square':
                    combinedVal = Math.sign(combinedVal) * Math.min(1.0, Math.abs(combinedVal) * 2.0);
                    break;
                case 'triangle':
                    const triVal = combinedVal * 2.0;
                    combinedVal = 2.0 * Math.abs((triVal % 2.0) - 1.0) - 1.0;
                    break;
                case 'sawtooth':
                    const sawVal = combinedVal * 2.0;
                    combinedVal = 2.0 * (sawVal - Math.floor(sawVal + 0.5));
                    break;
                default:
                    combinedVal = fastSin(combinedVal * Math.PI);
                    break;
            }
            
            const potential = isNaN(combinedVal) ? 0 : Math.max(-1.2, Math.min(1.2, combinedVal));
            
            if (!computeGradient) {
                return potential;
            }
            
            // Optimized gradient calculation using simplified finite differences
            const delta = 0.05; // Larger delta for performance
            const potDx = getOptimizedAdvancedWavePotential3D(x + delta, y, z, freq, modeM, modeN, modeP, waveType, false);
            const potDy = getOptimizedAdvancedWavePotential3D(x, y + delta, z, freq, modeM, modeN, modeP, waveType, false);
            const potDz = getOptimizedAdvancedWavePotential3D(x, y, z + delta, freq, modeM, modeN, modeP, waveType, false);
            
            const gradX = (potDx - potential) / delta;
            const gradY = (potDy - potential) / delta;
            const gradZ = (potDz - potential) / delta;
            
            const result = { potential, gradX, gradY, gradZ };
            
            // Cache the result
            gradientCacheMisses++;
            if (GRADIENT_CACHE.size >= GRADIENT_CACHE_SIZE) {
                // Clear oldest entries
                const keys = Array.from(GRADIENT_CACHE.keys());
                for (let i = 0; i < GRADIENT_CACHE_SIZE / 4; i++) {
                    GRADIENT_CACHE.delete(keys[i]);
                }
            }
            GRADIENT_CACHE.set(cacheKey, result);
            
            return result;
        }

        // Main animation loop - PERFORMANCE OPTIMIZED VERSION
        function animate() {
            if (!isExperienceStarted) return;
            requestAnimationFrame(animate);
            const deltaTime = Math.min(clock.getDelta(), 0.033); 
            time += deltaTime * 1000; 

            controls.update();
            triggerHeartbeatVisualAndSound(); 

            // Spawn new particles
            for (let i = 0; i < particlesToSpawnPerFrame; i++) {
                if (currentSpawnIndex < PARTICLE_COUNT) { 
                    initializeSingleParticle(currentSpawnIndex);
                    currentSpawnIndex = (currentSpawnIndex + 1); 
                } else if (particlesToSpawnPerFrame > 0) { 
                    currentSpawnIndex = currentSpawnIndex % PARTICLE_COUNT;
                    initializeSingleParticle(currentSpawnIndex);
                    currentSpawnIndex = (currentSpawnIndex + 1) % PARTICLE_COUNT;
                }
            }
            if (currentSpawnIndex >= PARTICLE_COUNT) currentSpawnIndex = 0; 

            const positions = particles.geometry.attributes.position.array;
            const velocities = particles.geometry.attributes.velocity.array;
            
            // Get current UI parameters
            const freq = parseFloat(ui.frequency.value);
            const amp = parseFloat(ui.amplitude.value);
            const waveType = ui.waveform.value;
            const modeM = parseInt(ui.modeM.value);
            const modeN = parseInt(ui.modeN.value);
            const modeP = parseInt(ui.modeP.value);

            const effectiveFieldStrength = CHLADNI_3D_FIELD_STRENGTH * (isHeartbeatActive ? HEARTBEAT_FORCE_MULTIPLIER : 1.0);
            
            // PERFORMANCE OPTIMIZATION: Process particles in batches
            const BATCH_SIZE = Math.min(1000, Math.floor(PARTICLE_COUNT / 10));
            const batchesPerFrame = Math.ceil(PARTICLE_COUNT / BATCH_SIZE);
            const currentBatch = Math.floor(time / 16.67) % batchesPerFrame; // ~60fps batching
            const startIdx = currentBatch * BATCH_SIZE;
            const endIdx = Math.min(startIdx + BATCH_SIZE, PARTICLE_COUNT);
            
            // Color update optimization
            const colorUpdateBatchDivisor = 500; // Reduced frequency
            const colorUpdateModulo = Math.max(1, Math.floor(PARTICLE_COUNT / colorUpdateBatchDivisor));
            const timeBasedOffset = Math.floor(time / 100); // Slower color updates

            // Process current batch of particles
            for (let i = startIdx; i < endIdx; i++) {
                const i3 = i * 3;
                let px = positions[i3], py = positions[i3 + 1], pz = positions[i3 + 2];
                let vx = velocities[i3], vy = velocities[i3 + 1], vz = velocities[i3 + 2];

                // Central Gravity Well
                const distSqToCenter = px*px + py*py + pz*pz;
                if (distSqToCenter < GRAVITY_WELL_RADIUS * GRAVITY_WELL_RADIUS && distSqToCenter > (CORE_ACTUAL_RADIUS * CORE_ACTUAL_RADIUS * 4)) {
                    const distToCenter = Math.sqrt(distSqToCenter);
                    const gravityForce = CENTRAL_GRAVITY_STRENGTH / (distSqToCenter + 0.01);
                    vx -= (px / distToCenter) * gravityForce * deltaTime;
                    vy -= (py / distToCenter) * gravityForce * deltaTime;
                    vz -= (pz / distToCenter) * gravityForce * deltaTime;
                }
                
                // OPTIMIZED Advanced Wave Forces - Single call with gradient
                const waveData = getOptimizedAdvancedWavePotential3D(px, py, pz, freq, modeM, modeN, modeP, waveType, true);
                const currentPotential = waveData.potential;
                const gradX = waveData.gradX;
                const gradY = waveData.gradY;
                const gradZ = waveData.gradZ;
                
                const forceScale = effectiveFieldStrength * amp * (1.0 - Math.abs(currentPotential));                 
                const forceX = -gradX * forceScale;
                const forceY = -gradY * forceScale; 
                const forceZ = -gradZ * forceScale;
                vx += forceX * deltaTime;
                vy += forceY * deltaTime;
                vz += forceZ * deltaTime;

                // Apply velocity damping
                vx *= VELOCITY_DAMPING;
                vy *= VELOCITY_DAMPING;
                vz *= VELOCITY_DAMPING;
                
                // Update positions
                px += vx * deltaTime;
                py += vy * deltaTime;
                pz += vz * deltaTime;
                
                // Boundary conditions
                const distFromCenter = Math.sqrt(px*px + py*py + pz*pz);
                if (distFromCenter > SIMULATION_EXTENT) { 
                    const normX = px/distFromCenter;
                    const normY = py/distFromCenter;
                    const normZ = pz/distFromCenter;
                    px = normX * SIMULATION_EXTENT * 0.99;
                    py = normY * SIMULATION_EXTENT * 0.99;
                    pz = normZ * SIMULATION_EXTENT * 0.99;
                    const dotProduct = (vx * normX + vy * normY + vz * normZ);
                    vx -= 1.5 * dotProduct * normX; 
                    vy -= 1.5 * dotProduct * normY;
                    vz -= 1.5 * dotProduct * normZ;
                }
                
                // Store updated values
                positions[i3] = px; positions[i3 + 1] = py; positions[i3 + 2] = pz;
                velocities[i3] = vx; velocities[i3 + 1] = vy; velocities[i3 + 2] = vz;
                
                // Update particle colors less frequently
                if ((i + timeBasedOffset) % colorUpdateModulo === 0) { 
                    updateParticleColor(i, px, py, pz, currentPotential);
                }
            }
            
            // Process remaining particles with simpler physics (every few frames)
            if (time % 100 < 16.67) { // Every ~6th frame
                for (let i = 0; i < PARTICLE_COUNT; i++) {
                    if (i >= startIdx && i < endIdx) continue; // Skip already processed
                    
                    const i3 = i * 3;
                    let px = positions[i3], py = positions[i3 + 1], pz = positions[i3 + 2];
                    let vx = velocities[i3], vy = velocities[i3 + 1], vz = velocities[i3 + 2];

                    // Simple gravity only for non-batch particles
                    const distSqToCenter = px*px + py*py + pz*pz;
                    if (distSqToCenter < GRAVITY_WELL_RADIUS * GRAVITY_WELL_RADIUS && distSqToCenter > (CORE_ACTUAL_RADIUS * CORE_ACTUAL_RADIUS * 4)) {
                        const distToCenter = Math.sqrt(distSqToCenter);
                        const gravityForce = CENTRAL_GRAVITY_STRENGTH / (distSqToCenter + 0.01);
                        vx -= (px / distToCenter) * gravityForce * deltaTime;
                        vy -= (py / distToCenter) * gravityForce * deltaTime;
                        vz -= (pz / distToCenter) * gravityForce * deltaTime;
                    }
                    
                    // Simple damping and position update
                    vx *= VELOCITY_DAMPING;
                    vy *= VELOCITY_DAMPING;
                    vz *= VELOCITY_DAMPING;
                    
                    px += vx * deltaTime;
                    py += vy * deltaTime;
                    pz += vz * deltaTime;
                    
                    positions[i3] = px; positions[i3 + 1] = py; positions[i3 + 2] = pz;
                    velocities[i3] = vx; velocities[i3 + 1] = vy; velocities[i3 + 2] = vz;
                }
            }
            
            // Update GPU buffers
            particles.geometry.attributes.position.needsUpdate = true;
            particles.geometry.attributes.velocity.needsUpdate = true;
            particles.geometry.attributes.color.needsUpdate = true; 
            
            // Subtle camera movement
            camera.position.x += Math.sin(time * 0.00002) * 0.005;
            camera.position.y += Math.cos(time * 0.000025) * 0.005;
            
            renderer.render(scene, camera);
            
            // Performance monitoring (optional)
            if (time % 5000 < 16.67) { // Every 5 seconds
                const cacheHitRate = gradientCacheHits / (gradientCacheHits + gradientCacheMisses) * 100;
                console.log(`Cache hit rate: ${cacheHitRate.toFixed(1)}%, Processed batch: ${currentBatch}/${batchesPerFrame}`);
            }
        }

        function onWindowResize() {
            if (!camera || !renderer) return;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Attribution verification system - Aldrin Payopay research protection
        // Agent 1 Modification: Added Agent 1 signature and updated relevant fields.
        function verifyResearchIntegrity() {
            // Decode and verify research team attribution
            const decoded_aldrin = atob(ALDRIN_PAYOPAY_SIGNATURE);
            const decoded_claude = atob(CLAUDE_OPUS_4_SIGNATURE); 
            const decoded_gemini = atob(GEMINI_25_PRO_SIGNATURE);
            const decoded_agent1 = atob(AGENT_1_MOD_SIGNATURE);
            
            console.log("🔬 Research Attribution Verified (Modified by Agent 1 - Advanced Wave Theory):");
            console.log("👨‍🔬 " + decoded_aldrin);
            console.log("🤖 " + decoded_claude);
            console.log("🧠 " + decoded_gemini);
            console.log("🚀 Mod by: " + decoded_agent1); 
            console.log("📊 Project: " + RESEARCH_TEAM.project);
            console.log("📅 Year: " + RESEARCH_TEAM.year);
            console.log("🔐 Integrity Hash (Original): " + RESEARCH_INTEGRITY_HASH.encoded_signature);
            console.log("🔐 Integrity Hash (Agent 1 Mod): " + RESEARCH_INTEGRITY_HASH.mod_signature);
            console.log("");
            console.log("🧬 DISCOVERY PROCESS (Original):");
            console.log("💡 Breakthrough: " + RESEARCH_TEAM.discovery_process.conceptual_breakthrough);
            console.log("🔬 Initial Insight: " + RESEARCH_TEAM.discovery_process.initial_insight);
            console.log("🌌 Scale Realization: " + RESEARCH_TEAM.discovery_process.scale_realization);
            console.log("⏰ Synchronization Theory: " + RESEARCH_TEAM.discovery_process.synchronization_theory);
            console.log("💥 Modal Explosion Theory: " + RESEARCH_TEAM.discovery_process.modal_explosion_theory);
            console.log("🔬 Research Methodology: " + RESEARCH_TEAM.discovery_process.research_methodology);
            
            // Hidden attribution in DOM
            const attribution = document.createElement('div');
            attribution.style.display = 'none';
            attribution.id = 'research-attribution-aldrin-payopay-claude-opus-4-gemini-25-pro-agent-1-advanced-wave-mod';
            attribution.innerHTML = `
                <span data-lead-researcher="Aldrin Payopay">Lead Researcher: Aldrin Payopay</span>
                <span data-ai-architect="Claude Opus 4">AI Architect: Claude Opus 4</span>
                <span data-ai-modeler="Gemini 2.5 Pro">AI Modeler: Gemini 2.5 Pro</span>
                <span data-modifier="Agent 1 - Advanced Wave Theory">Modifier: Agent 1 - Advanced Wave Theory (Dual Source Interference)</span>
                <span data-project="Resonance is All You Need - Advanced Wave Model">Project: Resonance is All You Need - Advanced Wave Model</span>
                <span data-copyright="2025">Copyright 2025 (Original), Modification by Agent 1 (${new Date().getFullYear()})</span>
            `;
            document.body.appendChild(attribution);
        }

        ui.startButton.addEventListener('click', initializeExperience);
        document.addEventListener('DOMContentLoaded', () => {
            checkWebGL();
            verifyResearchIntegrity(); // Verify attribution on load
        });

        // Mathematical helper functions for Spherical Harmonics - Agent 1 Enhancement
        function factorial(n) {
            if (n < 0) return Infinity;
            if (n === 0 || n === 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }

        // Fixed cache with size limit to prevent Map maximum size exceeded error
        const MAX_CACHE_SIZE = 1000;
        const legendreMemo = new Map();
        
        function legendreP(l, m, x) {
            // Limit input ranges to prevent infinite cache growth
            if (l > 20 || m > 20 || Math.abs(x) > 1) {
                // For extreme values, compute directly without caching
                return computeLegendreP(l, m, x);
            }
            
            // Round x to 2 decimal places to reduce cache key variations
            const roundedX = Math.round(x * 100) / 100;
            const key = `${l},${m},${roundedX}`;
            
            if (legendreMemo.has(key)) {
                return legendreMemo.get(key);
            }
            
            // Clear cache if it gets too large
            if (legendreMemo.size >= MAX_CACHE_SIZE) {
                legendreMemo.clear();
            }
            
            const value = computeLegendreP(l, m, roundedX);
            legendreMemo.set(key, value);
            return value;
        }
        
        function computeLegendreP(l, m, x) {
            if (m < 0 || m > l) return 0;
            x = Math.max(-1, Math.min(1, x));

            if (l === 0 && m === 0) return 1;

            if (l === m) {
                let val = 1;
                if (m !== 0) { 
                    val = Math.pow(-1, m) * (factorial(2 * m) / (Math.pow(2, m) * factorial(m))) * Math.pow(1 - x * x, m / 2);
                }
                return val;
            }

            if (l === m + 1) {
                return x * (2 * m + 1) * computeLegendreP(m, m, x);
            }
            
            if (l > m + 1 && (l - m) !== 0) { 
                return (x * (2 * l - 1) * computeLegendreP(l - 1, m, x) - (l + m - 1) * computeLegendreP(l - 2, m, x)) / (l - m);
            }
            
            return 0;
        }

        function sphericalYReal(l, m_signed, theta, phi) {
            if (l < 0) return 0;
            const m = Math.abs(m_signed);
            if (m > l) return 0;

            let normFactor = Math.sqrt(((2 * l + 1) * factorial(l - m)) / (4 * Math.PI * factorial(l + m)));
            if (m_signed !== 0) {
                normFactor *= Math.sqrt(2);
            }

            const p_lm_val = legendreP(l, m, Math.cos(theta));

            if (m_signed === 0) {
                return normFactor * p_lm_val;
            } else if (m_signed > 0) {
                return normFactor * p_lm_val * Math.cos(m_signed * phi);
            } else {
                return normFactor * p_lm_val * Math.sin(-m_signed * phi);
            }
        }

        // PERFORMANCE OPTIMIZATION FOR LARGE PARTICLE SYSTEMS - Agent 1 Implementation
        // Spatial hashing and GPU-friendly algorithms for enhanced performance
        
        // Spatial hash grid for particle optimization
        const SPATIAL_GRID_SIZE = 32;
        const SPATIAL_CELL_SIZE = SIMULATION_EXTENT * 2 / SPATIAL_GRID_SIZE;
        let spatialHashGrid = new Map();
        
        // Optimized particle update with spatial hashing
        function updateParticleOptimized(index) {
            const i3 = index * 3;
            const x = positions[i3];
            const y = positions[i3 + 1];
            const z = positions[i3 + 2];
            
            // Get current UI parameters
            const freq = parseFloat(ui.frequency.value);
            const modeM = parseInt(ui.modeM.value);
            const modeN = parseInt(ui.modeN.value);
            const modeP = parseInt(ui.modeP.value);
            const waveType = ui.waveform.value;
            
            // Spatial hash key for this particle
            const gridX = Math.floor((x + SIMULATION_EXTENT) / SPATIAL_CELL_SIZE);
            const gridY = Math.floor((y + SIMULATION_EXTENT) / SPATIAL_CELL_SIZE);
            const gridZ = Math.floor((z + SIMULATION_EXTENT) / SPATIAL_CELL_SIZE);
            const hashKey = `${gridX},${gridY},${gridZ}`;
            
            // Cache wave potential calculation for spatial cells
            let wavePotential;
            if (spatialHashGrid.has(hashKey)) {
                const cachedData = spatialHashGrid.get(hashKey);
                if (time - cachedData.timestamp < 50) { // Cache for 50ms
                    wavePotential = cachedData.potential;
                } else {
                    wavePotential = getOptimizedAdvancedWavePotential3D(x, y, z, freq, modeM, modeN, modeP, waveType, true);
                    spatialHashGrid.set(hashKey, { potential: wavePotential, timestamp: time });
                }
            } else {
                wavePotential = getOptimizedAdvancedWavePotential3D(x, y, z, freq, modeM, modeN, modeP, waveType, true);
                spatialHashGrid.set(hashKey, { potential: wavePotential, timestamp: time });
            }
            
            // Optimized force calculation with vectorized operations
            const forceScale = wavePotential * 0.0008;
            const dampingFactor = 0.98;
            
            // Update velocities with enhanced physics
            velocities[i3] = (velocities[i3] + forceScale * (Math.random() - 0.5)) * dampingFactor;
            velocities[i3 + 1] = (velocities[i3 + 1] + forceScale * (Math.random() - 0.5)) * dampingFactor;
            velocities[i3 + 2] = (velocities[i3 + 2] + forceScale * (Math.random() - 0.5)) * dampingFactor;
            
            // Update positions with boundary conditions
            positions[i3] += velocities[i3];
            positions[i3 + 1] += velocities[i3 + 1];
            positions[i3 + 2] += velocities[i3 + 2];
            
            // Enhanced boundary wrapping with elliptical considerations
            const boundaryExtent = SIMULATION_EXTENT * 0.95;
            if (Math.abs(positions[i3]) > boundaryExtent) positions[i3] *= -0.8;
            if (Math.abs(positions[i3 + 1]) > boundaryExtent) positions[i3 + 1] *= -0.8;
            if (Math.abs(positions[i3 + 2]) > boundaryExtent) positions[i3 + 2] *= -0.8;
            
            // Enhanced color calculation with elliptical harmonics influence
            const intensity = Math.abs(wavePotential);
            const hue = (intensity * 360 + time * 0.05) % 360;
            const saturation = 0.7 + intensity * 0.3;
            const lightness = 0.3 + intensity * 0.4;
            
            const color = new THREE.Color().setHSL(hue / 360, saturation, lightness);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }
        
        // Batch processing for improved performance
        const BATCH_SIZE = 1000;
        let currentBatch = 0;
        
        function updateParticlesBatched() {
            const startIndex = currentBatch * BATCH_SIZE;
            const endIndex = Math.min(startIndex + BATCH_SIZE, PARTICLE_COUNT);
            
            for (let i = startIndex; i < endIndex; i++) {
                updateParticleOptimized(i);
            }
            
            currentBatch = (currentBatch + 1) % Math.ceil(PARTICLE_COUNT / BATCH_SIZE);
            
            // Clear old spatial hash entries periodically
            if (currentBatch === 0 && spatialHashGrid.size > 2000) {
                const currentTime = time;
                for (const [key, value] of spatialHashGrid.entries()) {
                    if (currentTime - value.timestamp > 200) {
                        spatialHashGrid.delete(key);
                    }
                }
            }
        }
    </script>
</body>
</html> 