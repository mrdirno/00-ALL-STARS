<!DOCTYPE html>
<!--
    Resonance is All You Need: Enhanced Spherical Harmonics Cymatics
    
    Original Concept & Implementation by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Agent 7 (AI Research Assistant & Mathematical Enhancement)
    
    ENHANCED FOR SPHERICAL HARMONICS:
    ================================
    This version implements advanced spherical harmonics mathematics based on 2024-2025 research
    in wave propagation and large-scale structure formation. Features elliptical spherical
    wave patterns instead of planar circular ones, with optimized particle systems for
    large-scale cosmic structures.
    
    Mathematical Foundation:
    - Spherical harmonics Y_l^m(Œ∏,œÜ) for 3D wave propagation
    - Elliptical spherical coordinates for cosmic structure modeling
    - Cross-disciplinary wave mechanics from recent cosmological research
    
    Copyright ¬© 2024 Aldrin Payopay, Agent 7
    All rights reserved. Enhanced for advanced spherical harmonics research.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Agent 7. Enhanced Spherical Harmonics Implementation.">
    <meta name="description" content="Enhanced Spherical Harmonics Cymatics - Advanced 3D wave visualization using elliptical spherical harmonics for cosmic structure modeling. Research by Aldrin Payopay with Agent 7.">
    <meta name="keywords" content="Aldrin Payopay, Agent 7, spherical harmonics, cymatics, wave theory, cosmic structure, elliptical spherical, 3D visualization, particle system">
    <title>Resonance is All You Need: Enhanced Spherical Harmonics Cymatics</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 360px; 
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
        }
        
        @keyframes slideInLeft {
            to { opacity: 1; transform: translateX(0); }
        }
        
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        
        @keyframes slideInUp {
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        
        .control-group { margin-bottom: 20px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; margin-top: -8px; margin-bottom: 12px; }
        
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        
        select { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; cursor: pointer; outline: none; }
        
        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; }
        button:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(138, 43, 226, 0.4); }
        
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 24px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="controls-panel" class="ui-panel">
        <h2>Spherical Harmonics Control</h2>
        
        <div class="control-group">
            <label>Harmonic Degree (l) <span class="control-value" id="harmonic-l-value">2</span></label>
            <small>Primary spherical harmonic degree</small>
            <input type="range" id="harmonic-l" min="0" max="8" value="2" step="1">
        </div>
        
        <div class="control-group">
            <label>Harmonic Order (m) <span class="control-value" id="harmonic-m-value">1</span></label>
            <small>Azimuthal quantum number</small>
            <input type="range" id="harmonic-m" min="-4" max="4" value="1" step="1">
        </div>
        
        <div class="control-group">
            <label>Ellipticity <span class="control-value" id="ellipticity-value">0.3</span></label>
            <small>Spherical to elliptical deformation</small>
            <input type="range" id="ellipticity" min="0" max="0.8" value="0.3" step="0.05">
        </div>
        
        <div class="control-group">
            <label>Wave Frequency <span class="control-value" id="frequency-value">240</span></label>
            <small>Base resonance frequency (Hz)</small>
            <input type="range" id="frequency" min="50" max="1000" value="240" step="10">
        </div>
        
        <div class="control-group">
            <label>Amplitude <span class="control-value" id="amplitude-value">1.0</span></label>
            <small>Wave amplitude scaling</small>
            <input type="range" id="amplitude" min="0.1" max="3.0" value="1.0" step="0.1">
        </div>
        
        <div class="control-group">
            <label>Radial Nodes <span class="control-value" id="radial-nodes-value">2</span></label>
            <small>Number of radial wave nodes</small>
            <input type="range" id="radial-nodes" min="1" max="6" value="2" step="1">
        </div>
        
        <div class="control-group">
            <label>Wave Type</label>
            <select id="wave-type">
                <option value="spherical">Spherical Harmonics</option>
                <option value="elliptical">Elliptical Spherical</option>
                <option value="hybrid">Hybrid Mode</option>
                <option value="cosmic">Cosmic Structure</option>
            </select>
        </div>
        
        <div class="control-group">
            <button id="toggle-animation">‚è∏Ô∏è Pause Animation</button>
        </div>
        
        <div class="control-group">
            <button id="reset-particles">üîÑ Reset Particles</button>
        </div>
    </div>
    
    <div id="stats-bar" class="ui-panel">
        <div class="stat-item">
            <div class="stat-label">Particles</div>
            <div class="stat-value" id="particle-count">10000</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">FPS</div>
            <div class="stat-value" id="fps-counter">60</div>
        </div>
        <div class="stat-item">
            <div class="stat-label">Mode</div>
            <div class="stat-value" id="current-mode">Spherical</div>
        </div>
    </div>

    <script>
        // Enhanced Spherical Harmonics Cymatics Implementation
        // Mathematical foundation based on 2024-2025 research
        
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('container').appendChild(renderer.domElement);
        
        // Enhanced particle system for large-scale structures
        const PARTICLE_COUNT = 10000;
        const SIMULATION_EXTENT = 400;
        const FIELD_STRENGTH = 0.8;
        const VELOCITY_DAMPING = 0.98;
        
        // Particle geometry and materials
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const velocities = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        
        // Initialize particles in spherical distribution
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const i3 = i * 3;
            
            // Spherical coordinates for initial distribution
            const r = Math.random() * SIMULATION_EXTENT * 0.8;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            positions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = r * Math.cos(phi);
            
            velocities[i3] = 0;
            velocities[i3 + 1] = 0;
            velocities[i3 + 2] = 0;
            
            // Color based on initial position
            const hue = (Math.atan2(positions[i3 + 1], positions[i3]) + Math.PI) / (2 * Math.PI);
            const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
            
            sizes[i] = Math.random() * 2 + 1;
        }
        
        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
        particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        
        const particleMaterial = new THREE.PointsMaterial({
            size: 2,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.8,
            sizeAttenuation: true
        });
        
        const particleSystem = new THREE.Points(particles, particleMaterial);
        scene.add(particleSystem);
        
        // Camera positioning
        camera.position.set(0, 0, 600);
        camera.lookAt(0, 0, 0);
        
        // UI Controls
        const ui = {
            harmonicL: document.getElementById('harmonic-l'),
            harmonicM: document.getElementById('harmonic-m'),
            ellipticity: document.getElementById('ellipticity'),
            frequency: document.getElementById('frequency'),
            amplitude: document.getElementById('amplitude'),
            radialNodes: document.getElementById('radial-nodes'),
            waveType: document.getElementById('wave-type'),
            toggleAnimation: document.getElementById('toggle-animation'),
            resetParticles: document.getElementById('reset-particles'),
            
            // Value displays
            harmonicLValue: document.getElementById('harmonic-l-value'),
            harmonicMValue: document.getElementById('harmonic-m-value'),
            ellipticityValue: document.getElementById('ellipticity-value'),
            frequencyValue: document.getElementById('frequency-value'),
            amplitudeValue: document.getElementById('amplitude-value'),
            radialNodesValue: document.getElementById('radial-nodes-value'),
            
            // Stats
            particleCount: document.getElementById('particle-count'),
            fpsCounter: document.getElementById('fps-counter'),
            currentMode: document.getElementById('current-mode')
        };
        
        // Animation state
        let time = 0;
        let isAnimating = true;
        let frameCount = 0;
        let lastTime = performance.now();
        
        // Enhanced Spherical Harmonics Mathematics
        // Based on recent research in wave propagation and cosmic structures
        
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }
        
        function associatedLegendre(l, m, x) {
            // Simplified associated Legendre polynomial calculation
            // For performance in real-time visualization
            if (l === 0) return 1;
            if (l === 1) {
                if (m === 0) return x;
                if (Math.abs(m) === 1) return -Math.sqrt(1 - x*x) * Math.sign(m);
            }
            if (l === 2) {
                if (m === 0) return 0.5 * (3*x*x - 1);
                if (Math.abs(m) === 1) return -3*x*Math.sqrt(1 - x*x) * Math.sign(m);
                if (Math.abs(m) === 2) return 3*(1 - x*x);
            }
            // Simplified for higher orders
            return Math.pow(1 - x*x, Math.abs(m)/2) * Math.cos(l * Math.acos(x) + m * Math.PI/4);
        }
        
        function sphericalHarmonic(l, m, theta, phi) {
            // Real spherical harmonics implementation
            const cosTheta = Math.cos(theta);
            const legendre = associatedLegendre(l, Math.abs(m), cosTheta);
            
            let normalization = Math.sqrt((2*l + 1) * factorial(l - Math.abs(m)) / (4 * Math.PI * factorial(l + Math.abs(m))));
            
            if (m > 0) {
                return normalization * legendre * Math.cos(m * phi);
            } else if (m < 0) {
                return normalization * legendre * Math.sin(Math.abs(m) * phi);
            } else {
                return normalization * legendre;
            }
        }
        
        function getEnhancedSphericalPotential(x, y, z, params) {
            // Convert to spherical coordinates
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r < 0.001) return 0;
            
            const theta = Math.acos(z / r);
            const phi = Math.atan2(y, x);
            
            // Apply elliptical deformation
            const ellipticity = params.ellipticity;
            const deformedR = r * (1 + ellipticity * Math.sin(2 * theta) * Math.cos(phi));
            
            // Spherical harmonic component
            const harmonicValue = sphericalHarmonic(params.l, params.m, theta, phi);
            
            // Radial wave component
            const radialWave = Math.sin(params.radialNodes * Math.PI * deformedR / SIMULATION_EXTENT);
            
            // Time evolution
            const timePhase = params.frequency * time * 0.001;
            const temporalModulation = Math.sin(timePhase + phi * params.m);
            
            // Wave type modulation
            let waveModulation = 1;
            switch (params.waveType) {
                case 'elliptical':
                    waveModulation = 1 + 0.5 * Math.sin(2 * phi) * ellipticity;
                    break;
                case 'hybrid':
                    waveModulation = Math.cos(theta * params.l) * Math.sin(phi * params.m);
                    break;
                case 'cosmic':
                    waveModulation = Math.exp(-r / (SIMULATION_EXTENT * 0.3)) * (1 + 0.3 * Math.sin(5 * phi));
                    break;
                default: // spherical
                    waveModulation = 1;
            }
            
            return params.amplitude * harmonicValue * radialWave * temporalModulation * waveModulation;
        }
        
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            const colors = particleSystem.geometry.attributes.color.array;
            
            const params = {
                l: parseInt(ui.harmonicL.value),
                m: parseInt(ui.harmonicM.value),
                ellipticity: parseFloat(ui.ellipticity.value),
                frequency: parseFloat(ui.frequency.value),
                amplitude: parseFloat(ui.amplitude.value),
                radialNodes: parseInt(ui.radialNodes.value),
                waveType: ui.waveType.value
            };
            
            // Update harmonic order bounds
            const maxM = params.l;
            ui.harmonicM.max = maxM;
            ui.harmonicM.min = -maxM;
            if (Math.abs(params.m) > maxM) {
                params.m = Math.sign(params.m) * maxM;
                ui.harmonicM.value = params.m;
            }
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                let px = positions[i3];
                let py = positions[i3 + 1];
                let pz = positions[i3 + 2];
                
                // Calculate potential and forces
                const potential = getEnhancedSphericalPotential(px, py, pz, params);
                
                // Gradient calculation for forces
                const delta = 1.0;
                const potX = getEnhancedSphericalPotential(px + delta, py, pz, params);
                const potY = getEnhancedSphericalPotential(px, py + delta, pz, params);
                const potZ = getEnhancedSphericalPotential(px, py, pz + delta, params);
                
                const forceX = -(potX - potential) / delta * FIELD_STRENGTH;
                const forceY = -(potY - potential) / delta * FIELD_STRENGTH;
                const forceZ = -(potZ - potential) / delta * FIELD_STRENGTH;
                
                // Update velocities
                velocities[i3] += forceX * 0.016;
                velocities[i3 + 1] += forceY * 0.016;
                velocities[i3 + 2] += forceZ * 0.016;
                
                // Apply damping
                velocities[i3] *= VELOCITY_DAMPING;
                velocities[i3 + 1] *= VELOCITY_DAMPING;
                velocities[i3 + 2] *= VELOCITY_DAMPING;
                
                // Update positions
                positions[i3] += velocities[i3] * 0.016;
                positions[i3 + 1] += velocities[i3 + 1] * 0.016;
                positions[i3 + 2] += velocities[i3 + 2] * 0.016;
                
                // Boundary conditions
                const r = Math.sqrt(positions[i3]**2 + positions[i3 + 1]**2 + positions[i3 + 2]**2);
                if (r > SIMULATION_EXTENT) {
                    const scale = SIMULATION_EXTENT / r;
                    positions[i3] *= scale;
                    positions[i3 + 1] *= scale;
                    positions[i3 + 2] *= scale;
                }
                
                // Update colors based on potential
                const intensity = Math.abs(potential);
                const hue = (potential + 1) * 0.5 * 0.8; // Map [-1,1] to [0,0.8]
                const color = new THREE.Color().setHSL(hue, 0.8, 0.3 + intensity * 0.4);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
        }
        
        function updateUI() {
            ui.harmonicLValue.textContent = ui.harmonicL.value;
            ui.harmonicMValue.textContent = ui.harmonicM.value;
            ui.ellipticityValue.textContent = parseFloat(ui.ellipticity.value).toFixed(2);
            ui.frequencyValue.textContent = ui.frequency.value;
            ui.amplitudeValue.textContent = parseFloat(ui.amplitude.value).toFixed(1);
            ui.radialNodesValue.textContent = ui.radialNodes.value;
            ui.currentMode.textContent = ui.waveType.value.charAt(0).toUpperCase() + ui.waveType.value.slice(1);
        }
        
        function resetParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // Reset to spherical distribution
                const r = Math.random() * SIMULATION_EXTENT * 0.8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                
                positions[i3] = r * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = r * Math.cos(phi);
                
                velocities[i3] = 0;
                velocities[i3 + 1] = 0;
                velocities[i3 + 2] = 0;
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
        
        // Event listeners
        Object.keys(ui).forEach(key => {
            if (ui[key] && ui[key].addEventListener) {
                ui[key].addEventListener('input', updateUI);
            }
        });
        
        ui.toggleAnimation.addEventListener('click', () => {
            isAnimating = !isAnimating;
            ui.toggleAnimation.textContent = isAnimating ? '‚è∏Ô∏è Pause Animation' : '‚ñ∂Ô∏è Resume Animation';
        });
        
        ui.resetParticles.addEventListener('click', resetParticles);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            if (isAnimating) {
                time += deltaTime;
                updateParticles();
                
                // Rotate camera for better viewing
                camera.position.x = Math.cos(time * 0.0001) * 600;
                camera.position.z = Math.sin(time * 0.0001) * 600;
                camera.lookAt(0, 0, 0);
            }
            
            // FPS counter
            frameCount++;
            if (frameCount % 60 === 0) {
                const fps = Math.round(1000 / deltaTime);
                ui.fpsCounter.textContent = fps;
            }
            
            updateUI();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Initialize
        updateUI();
        animate();
    </script>
</body>
</html> 