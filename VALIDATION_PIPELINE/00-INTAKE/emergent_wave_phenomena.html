<!DOCTYPE html>
<!--
    Resonance is All You Need: Emergent Wave Phenomena (Chirikov Map Adaptation)
    Concept & Transformation by Agent (Gemini 2.5 Pro) based on original work.
    Original Concept & Implementation for base structure by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Claude Opus 4 (AI Research Assistant & Code Architect) 
    - Gemini 2.5 Pro (AI Research Assistant & Mathematical Modeling)
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, AI Agent">
    <meta name="description" content="Emergent Wave Phenomena - Chirikov Map Adaptation. Original research by Aldrin Payopay with AI Assistants.">
    <meta name="keywords" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, wave interference, cosmic structure, gravitational waves, resonance, Chirikov map, quantum chaos, emergent phenomena">
    <meta name="creator" content="Aldrin Payopay (Human Researcher), Claude Opus 4 (AI Assistant), Gemini 2.5 Pro (AI Assistant), AI Agent (AI Transformation)">
    <title>Emergent Wave Phenomena: Chirikov Map</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* CSS Styling - Unchanged from base */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 360px; 
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }
        #controls-panel::-webkit-scrollbar { width: 8px; }
        #controls-panel::-webkit-scrollbar-track { background: rgba(25, 25, 45, 0.1); border-radius: 10px;}
        #controls-panel::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 10px; border: 1px solid rgba(25, 25, 45, 0.2); }
        #controls-panel::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #9F50E8 0%, #5D1DE0 100%); }
        #controls-panel { scrollbar-width: thin; scrollbar-color: #8A2BE2 rgba(25, 25, 45, 0.1); }
        @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        @keyframes slideInUp { to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        .control-group { margin-bottom: 20px; }
        #controls-panel .control-group { padding-right: 14px; }
        #controls-panel h2 { padding-right: 14px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-group label[title] { cursor: help; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; font-weight: 400; text-transform: none; letter-spacing: normal; margin-top: -8px; margin-bottom: 12px; }
        .info-icon { font-size: 0.7em; color: rgba(138, 43, 226, 0.7); font-weight: 400; margin-left: 8px; cursor: help; transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
        .info-icon:hover { color: rgba(138, 43, 226, 1); transform: scale(1.1); }
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; transition: background 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); transition: all 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        select, .ui-input-number { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; font-weight: 500; cursor: pointer; outline: none; transition: all 0.3s ease; -moz-appearance: textfield; /* Firefox */ }
        select:hover, .ui-input-number:hover { background: rgba(45, 45, 65, 0.15); border-color: rgba(120, 120, 220, 0.3); }
        select:focus, .ui-input-number:focus { border-color: #8A2BE2; box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2); }
        .ui-input-number::-webkit-outer-spin-button,
        .ui-input-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); transition: left 0.5s ease; }
        button:hover::before { left: 100%; }
        button:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(138, 43, 226, 0.4); }
        button:active { transform: translateY(0); }
        button.active { background: linear-gradient(135deg, #CF63CF 0%, #f5576c 100%); } 
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 24px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; letter-spacing: -0.02em; }
        #initialization-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%);
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            z-index: 1000; padding: 20px;
        }
        .init-content { text-align: center; max-width: 600px; animation: fadeInScale 0.8s ease; }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .init-title { font-size: 3rem; font-weight: 800; margin-bottom: 16px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -0.03em; line-height: 1.2; }
        .init-subtitle { font-size: 1.25rem; color: rgba(220, 220, 255, 0.7); margin-bottom: 40px; font-weight: 300; }
        #start-button { padding: 18px 48px; font-size: 1.125rem; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 30px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.1em; box-shadow: 0 10px 40px rgba(138, 43, 226, 0.4); position: relative; overflow: hidden; }
        #start-button:hover { transform: translateY(-3px); box-shadow: 0 15px 50px rgba(138, 43, 226, 0.6); }
        #start-button:disabled { background: #2a2a2a; cursor: not-allowed; box-shadow: none; }
        #status-message { color: rgba(200, 200, 255, 0.6); margin-top: 20px; font-size: 0.875rem; }
        #error-message { color: #f87171; margin-top: 15px; font-weight: 500; }
        .loading-dots { display: inline-flex; gap: 4px; }
        .dot { width: 8px; height: 8px; background: #8A2BE2; border-radius: 50%; animation: loadingDot 1.4s ease-in-out infinite; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes loadingDot { 0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; } 40% { transform: scale(1.2); opacity: 1; } }
        .sound-indicator { position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.7s; }
        @keyframes fadeIn { to { opacity: 1; } }
        .sound-waves { position: relative; width: 100%; height: 100%; }
        .wave { position: absolute; border: 2px solid rgba(138, 43, 226, 0.6); border-radius: 50%; opacity: 0; animation: soundWave 2s ease-out infinite; }
        .wave:nth-child(2) { animation-delay: 0.5s; } .wave:nth-child(3) { animation-delay: 1s; }
        @keyframes soundWave { 0% { width: 20px; height: 20px; top: 20px; left: 20px; opacity: 1; } 100% { width: 60px; height: 60px; top: 0; left: 0; opacity: 0; } }
        .sound-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; fill: #8A2BE2; }
        .instructions { position: absolute; bottom: 20px; right: 20px; background: rgba(25, 25, 45, 0.1); backdrop-filter: blur(15px); padding: 16px 20px; border-radius: 12px; border: 1px solid rgba(100, 100, 200, 0.1); font-size: 0.75rem; color: rgba(200, 200, 255, 0.7); z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.9s; }
        .research-watermark { position: fixed; bottom: 5px; left: 5px; font-size: 8px; color: rgba(138, 43, 226, 0.1); z-index: 1; pointer-events: none; font-family: monospace; transform: rotate(-90deg); transform-origin: 0 0; }
        .research-watermark div { white-space: nowrap; }
        .pulse-indicator { width: 20px; height: 20px; background-color: #8A2BE2; border-radius: 50%; transition: all 0.3s ease; }
        .pulse-active { animation: pulseAnim 0.7s ease-out; }
        @keyframes pulseAnim { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0.7); } 50% { transform: scale(1.5); box-shadow: 0 0 10px 15px rgba(138, 43, 226, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0); } }
        #fullscreen-button {
            position: absolute;
            top: 20px;
            right: 100px; /* Adjusted to make space for sound indicator */
            padding: 10px 15px;
            background: rgba(25, 25, 45, 0.2);
            border: 1px solid rgba(100, 100, 200, 0.15);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            z-index: 10;
            opacity:0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.8s;
        }
         #fullscreen-button:hover { background: rgba(35, 35, 55, 0.3); }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="initialization-overlay">
        <div class="init-content">
            <div class="init-title">Emergent Wave Phenomena: Chirikov Map</div>
            <div class="init-subtitle">Visualizing 3D wave patterns with chaotic perturbations. <br>A conceptual interactive model.</div>
            <button id="start-button">Initialize Simulation</button>
            <div id="status-message">Loading assets... <span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></div>
            <div id="error-message" style="display:none;"></div>
        </div>
    </div>
    
    <div id="controls-panel" class="ui-panel">
        <h2>Wave Parameters</h2>
        <div class="control-group">
            <label for="frequencySlider">Frequency: <span id="frequencyValue" class="control-value">10.0</span> Hz <span class="info-icon" title="Base frequency of the cosmic resonance field.">ℹ️</span></label>
            <input type="range" id="frequencySlider" min="0.1" max="50" step="0.1" value="10.0">
            <small>Adjusts the fundamental frequency of the wave patterns.</small>
        </div>
        <div class="control-group">
            <label for="amplitudeSlider">Amplitude: <span id="amplitudeValue" class="control-value">1.0</span> <span class="info-icon" title="Strength of the cymatic displacement force.">ℹ️</span></label>
            <input type="range" id="amplitudeSlider" min="0.0" max="5.0" step="0.01" value="1.0">
            <small>Controls the intensity of the wave displacement effect.</small>
        </div>
        <div class="control-group">
            <label for="sourceOffsetSlider">Source Offset: <span id="sourceOffsetValue" class="control-value">75</span> <span class="info-icon" title="Separation of the two wave interference sources.">ℹ️</span></label>
            <input type="range" id="sourceOffsetSlider" min="0" max="200" step="1" value="75">
            <small>Distance between dual wave sources. 0 for single source at origin.</small>
        </div>
        <div class="control-group">
            <label for="modeMSlider">Mode M (Theta): <span id="modeMValue" class="control-value">4</span> <span class="info-icon" title="Azimuthal mode number (around Z-axis).">ℹ️</span></label>
            <input type="range" id="modeMSlider" min="0" max="12" step="1" value="4">
            <small>Determines angular patterns around the Z-axis.</small>
        </div>
        <div class="control-group">
            <label for="modeNSlider">Mode N (Phi): <span id="modeNValue" class="control-value">5</span> <span class="info-icon" title="Polar mode number (from Z-axis).">ℹ️</span></label>
            <input type="range" id="modeNSlider" min="0" max="12" step="1" value="5">
            <small>Determines angular patterns relative to the Z-axis.</small>
        </div>
        <div class="control-group">
            <label for="modePSlider">Mode P (Radial): <span id="modePValue" class="control-value">6</span> <span class="info-icon" title="Radial mode number.">ℹ️</span></label>
            <input type="range" id="modePSlider" min="0" max="12" step="1" value="6">
            <small>Determines concentric patterns from the source(s).</small>
        </div>
        <div class="control-group">
            <label for="waveformSelect">Waveform: <span id="waveformValue" class="control-value">Sine</span> <span class="info-icon" title="Shape of the fundamental wave.">ℹ️</span></label>
            <select id="waveformSelect">
                <option value="sine" selected>Sine Wave</option>
                <option value="square">Square Wave</option>
                <option value="triangle">Triangle Wave</option>
                <option value="sawtooth">Sawtooth Wave</option>
            </select>
            <small>Modifies the basic wave shape for different effects.</small>
        </div>
        <div class="control-group">
            <label for="chaosStrengthSlider">Chaos Strength (K): <span id="chaosStrengthValue" class="control-value">0.5</span> <span class="info-icon" title="Strength of the chaotic perturbation (K parameter in Chirikov map).">ℹ️</span></label>
            <input type="range" id="chaosStrengthSlider" min="0.0" max="2.0" step="0.01" value="0.5">
            <small>Controls the K parameter for the Chirikov-like map, inducing chaotic behavior.</small>
        </div>

        <h2>Particle & System</h2>
        <div class="control-group">
            <label for="particleCountSlider">Particle Count: <span id="particleCountValue" class="control-value">50000</span> <span class="info-icon" title="Total number of particles in the simulation. Requires re-initialization.">ℹ️</span></label>
            <input type="range" id="particleCountSlider" min="1000" max="250000" step="1000" value="50000">
            <small>More particles create denser structures but reduce performance.</small>
        </div>
         <div class="control-group">
            <label for="particlesToSpawnSlider">Spawn Rate / Frame: <span id="particlesToSpawnValue" class="control-value">500</span> <span class="info-icon" title="Number of particles to (re)initialize per animation frame.">ℹ️</span></label>
            <input type="range" id="particlesToSpawnSlider" min="0" max="5000" step="100" value="500">
            <small>Higher rates fill the volume faster or make patterns more dynamic if particles are reset.</small>
        </div>
        <div class="control-group">
            <label for="heartRateSlider">Heartbeat Rate (BPM): <span id="heartRateValue" class="control-value">60</span> <span class="info-icon" title="Simulated cosmic heartbeat, influences force pulses and audio.">ℹ️</span></label>
            <input type="range" id="heartRateSlider" min="30" max="180" step="1" value="60">
            <small>Frequency of the central 'heartbeat' pulse.</small>
        </div>
        <div class="control-group">
            <label for="gravityStrengthSlider">Gravity Strength: <span id="gravityStrengthValue" class="control-value">100</span> <span class="info-icon" title="Strength of the central gravitational pull.">ℹ️</span></label>
            <input type="range" id="gravityStrengthSlider" min="0" max="1000" step="10" value="100">
            <small>Adjusts the force of the central supermassive black hole analog.</small>
        </div>
        <div class="control-group">
            <button id="reinitializeButton">Re-initialize Simulation</button>
            <small>Applies particle count changes and resets the simulation.</small>
        </div>
        <div class="control-group">
            <button id="toggleSoundButton">Sound: ON</button>
            <small>Toggles audio feedback for wave patterns and pulses.</small>
        </div>
        <div class="control-group">
            <button id="stopButton">Stop Simulation</button>
             <small>Pauses the animation and audio.</small>
        </div>
    </div>

    <div id="stats-bar" class="ui-panel">
        <div class="stat-item">
            <span class="stat-label">Particles</span>
            <span id="particleStat" class="stat-value">50000</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">FPS</span>
            <span id="fpsStat" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Time</span>
            <span id="timeStat" class="stat-value">0.0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Pulse</span>
            <div id="pulseIndicator" class="pulse-indicator"></div>
        </div>
    </div>

    <div class="sound-indicator">
        <svg class="sound-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
        <div class="sound-waves">
            <div class="wave"></div><div class="wave"></div><div class="wave"></div>
        </div>
    </div>
    <button id="fullscreen-button">Fullscreen</button>
    <div class="instructions">Use mouse to orbit, scroll to zoom.</div>
    <div class="research-watermark">
        <div>Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro - Resonance is All You Need - Advanced Wave Dynamics & Emergent Phenomena Research. This is a conceptual model. Not representative of peer-reviewed simulation data. For educational and illustrative purposes only.</div>
        <div>Unauthorized reproduction or distribution strictly prohibited. All rights reserved by the original authors and AI collaborators.</div>
    </div>
    
<script>
    let scene, camera, renderer, particles, geometry, material, controls;
    let positions, velocities, accelerations, phases, originalPositions, particleMasses;
    let audioContext, masterGain, bassSynth, cymbalSynth, pulseSynth;
    let lastPulseTime = 0;
    let isSoundInitialized = false;
    let animationFrameId;
    let spawnIndex = 0;
    let particleColorHSL = []; 

    const params = {
        frequency: 10.0,
        amplitude: 1.0,
        particleCount: 50000,
        particlesToSpawnPerFrame: 500,
        boxSize: 500,
        baseParticleSize: 1.5,
        waveform: 'sine',
        heartRate: 60, 
        gravityStrength: 100,
        sourceOffset: 75,
        modeM: 4, 
        modeN: 5, 
        modeP: 6,  
        chaosStrengthK: 0.5, // New parameter for Chirikov map
        particleInteraction: false,
        timeScale: 1.0,
        colorShiftSpeed: 0.01,
        particleOpacity: 0.7,
        maxVelocity: 2.0,
        dampingFactor: 0.98,
        enableRotation: true,
        rotationSpeed: 0.0005,
        showCentralMass: true,
        centralMassSize: 10,
        centralMassColor: 0xffcc00,
        soundEnabled: true,
        useLogFrequency: false,
        frequencyMin: 0.1,
        frequencyMax: 50,
        pulseForce: 1.0,
        pulseFrequencyMod: 0.2,
        cameraFov: 60,
        cameraNear: 1,
        cameraFar: 5000,
        cameraInitialPosition: new THREE.Vector3(0, 200, 600),
        backgroundColor: 0x000000,
        particleColorBase: 0x8A2BE2, 
        particleColorSpread: 0.3, 
    };

    // Cached DOM elements
    const frequencySlider = document.getElementById('frequencySlider');
    const frequencyValue = document.getElementById('frequencyValue');
    const amplitudeSlider = document.getElementById('amplitudeSlider');
    const amplitudeValue = document.getElementById('amplitudeValue');
    const particleCountSlider = document.getElementById('particleCountSlider');
    const particleCountValue = document.getElementById('particleCountValue');
    const particlesToSpawnSlider = document.getElementById('particlesToSpawnSlider');
    const particlesToSpawnValue = document.getElementById('particlesToSpawnValue');
    const waveformSelect = document.getElementById('waveformSelect');
    const waveformValue = document.getElementById('waveformValue');
    const heartRateSlider = document.getElementById('heartRateSlider');
    const heartRateValue = document.getElementById('heartRateValue');
    const gravityStrengthSlider = document.getElementById('gravityStrengthSlider');
    const gravityStrengthValue = document.getElementById('gravityStrengthValue');
    const sourceOffsetSlider = document.getElementById('sourceOffsetSlider');
    const sourceOffsetValue = document.getElementById('sourceOffsetValue');
    const modeMSlider = document.getElementById('modeMSlider');
    const modeMValue = document.getElementById('modeMValue');
    const modeNSlider = document.getElementById('modeNSlider');
    const modeNValue = document.getElementById('modeNValue');
    const modePSlider = document.getElementById('modePSlider');
    const modePValue = document.getElementById('modePValue');
    const chaosStrengthSlider = document.getElementById('chaosStrengthSlider');
    const chaosStrengthValue = document.getElementById('chaosStrengthValue');

    const reinitializeButton = document.getElementById('reinitializeButton');
    const toggleSoundButton = document.getElementById('toggleSoundButton');
    const stopButton = document.getElementById('stopButton');
    const particleStat = document.getElementById('particleStat');
    const fpsStat = document.getElementById('fpsStat');
    const timeStat = document.getElementById('timeStat');
    const pulseIndicator = document.getElementById('pulseIndicator');
    let stats;

    document.addEventListener('DOMContentLoaded', () => {
        initControls();
        
        stopButton.addEventListener('click', stopSimulation);
        document.getElementById('start-button').addEventListener('click', async () => {
            document.getElementById('status-message').innerHTML = 'Initializing audio & visual systems... <span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
            document.getElementById('start-button').disabled = true;
            document.getElementById('error-message').style.display = 'none';

            try {
                if (params.soundEnabled && !isSoundInitialized) {
                    await initAudio();
                    isSoundInitialized = true;
                }
                document.getElementById('initialization-overlay').style.display = 'none';
                document.getElementById('controls-panel').style.opacity = 1;
                document.getElementById('stats-bar').style.opacity = 1;
                document.querySelector('.sound-indicator').style.opacity = params.soundEnabled ? 1: 0;
                document.querySelector('.instructions').style.opacity = 1;
                document.getElementById('fullscreen-button').style.opacity = 1;

                init();
                animate();
            } catch (error) {
                console.error("Initialization failed:", error);
                const errDiv = document.getElementById('error-message');
                errDiv.textContent = `Error: ${error.message}. Please try reloading. If the issue persists, try disabling sound or reducing particle count.`;
                errDiv.style.display = 'block';
                document.getElementById('status-message').textContent = 'Initialization failed.';
                document.getElementById('start-button').disabled = false; 
            }
        });
        document.getElementById('fullscreen-button').addEventListener('click', toggleFullScreen);
        setupInfoIcons();
    });

    function initControls() {
        // Setup listeners
        frequencySlider.addEventListener('input', () => { params.frequency = parseFloat(frequencySlider.value); frequencyValue.textContent = params.frequency.toFixed(1);});
        amplitudeSlider.addEventListener('input', () => { params.amplitude = parseFloat(amplitudeSlider.value); amplitudeValue.textContent = params.amplitude.toFixed(2); });
        particleCountSlider.addEventListener('input', () => { params.particleCount = parseInt(particleCountSlider.value); particleCountValue.textContent = params.particleCount; });
        particlesToSpawnSlider.addEventListener('input', () => { params.particlesToSpawnPerFrame = parseInt(particlesToSpawnSlider.value); particlesToSpawnValue.textContent = params.particlesToSpawnPerFrame; });
        waveformSelect.addEventListener('change', () => { params.waveform = waveformSelect.value; waveformValue.textContent = waveformSelect.options[waveformSelect.selectedIndex].text;});
        heartRateSlider.addEventListener('input', () => { params.heartRate = parseInt(heartRateSlider.value); heartRateValue.textContent = params.heartRate; });
        gravityStrengthSlider.addEventListener('input', () => { params.gravityStrength = parseFloat(gravityStrengthSlider.value); gravityStrengthValue.textContent = params.gravityStrength.toFixed(0); });
        sourceOffsetSlider.addEventListener('input', () => { params.sourceOffset = parseFloat(sourceOffsetSlider.value); sourceOffsetValue.textContent = params.sourceOffset.toFixed(0); });
        modeMSlider.addEventListener('input', () => { params.modeM = parseInt(modeMSlider.value); modeMValue.textContent = params.modeM; });
        modeNSlider.addEventListener('input', () => { params.modeN = parseInt(modeNSlider.value); modeNValue.textContent = params.modeN; });
        modePSlider.addEventListener('input', () => { params.modeP = parseInt(modePSlider.value); modePValue.textContent = params.modeP; });
        chaosStrengthSlider.addEventListener('input', () => { params.chaosStrengthK = parseFloat(chaosStrengthSlider.value); chaosStrengthValue.textContent = params.chaosStrengthK.toFixed(2); });

        reinitializeButton.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            init(); // Re-initialize with new particle count or other major settings
            animate();
        });
        toggleSoundButton.addEventListener('click', toggleSound);

        // Set initial values
        updateSlider(frequencySlider, frequencyValue, params.frequency, val => val.toFixed(1));
        updateSlider(amplitudeSlider, amplitudeValue, params.amplitude, val => val.toFixed(2));
        updateSlider(particleCountSlider, particleCountValue, params.particleCount, val => parseInt(val));
        updateSlider(particlesToSpawnSlider, particlesToSpawnValue, params.particlesToSpawnPerFrame, val => parseInt(val));
        updateSlider(heartRateSlider, heartRateValue, params.heartRate, val => parseInt(val));
        updateSlider(gravityStrengthSlider, gravityStrengthValue, params.gravityStrength, val => val.toFixed(0));
        updateSlider(sourceOffsetSlider, sourceOffsetValue, params.sourceOffset, val => val.toFixed(0));
        updateSlider(modeMSlider, modeMValue, params.modeM, val => parseInt(val));
        updateSlider(modeNSlider, modeNValue, params.modeN, val => parseInt(val));
        updateSlider(modePSlider, modePValue, params.modeP, val => parseInt(val));
        updateSlider(chaosStrengthSlider, chaosStrengthValue, params.chaosStrengthK, val => parseFloat(val).toFixed(2));
        
        waveformSelect.value = params.waveform;
        waveformValue.textContent = waveformSelect.options[waveformSelect.selectedIndex].text;
        toggleSoundButton.textContent = params.soundEnabled ? "Sound: ON" : "Sound: OFF";
    }
    
    function updateSlider(slider, display, paramValue, formatFn = val => val) {
        if (slider) {
            slider.value = paramValue;
            if(display) display.textContent = formatFn(paramValue);
        }
    }

    async function initAudio() {
        if (isSoundInitialized || !params.soundEnabled) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            await audioContext.resume(); 

            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3; // Reduced master gain
            masterGain.connect(audioContext.destination);

            bassSynth = new Tone.MonoSynth({
                oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 },
                filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5, baseFrequency: 100, octaves: 3 }
            }).connect(masterGain);

            cymbalSynth = new Tone.MetalSynth({
                frequency: 200,
                envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
                harmonicity: 3.1,
                modulationIndex: 16,
                resonance: 2000,
                octaves: 1
            }).connect(masterGain);

            pulseSynth = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 2,
                oscillator: { type: "sine" },
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.8, attackCurve: "exponential" }
            }).connect(masterGain);
            
            isSoundInitialized = true;
            console.log("Audio initialized successfully.");
            document.querySelector('.sound-indicator').style.opacity = 1;
            toggleSoundButton.textContent = "Sound: ON";

        } catch (e) {
            console.error("Error initializing audio:", e);
            params.soundEnabled = false;
            document.querySelector('.sound-indicator').style.opacity = 0;
            toggleSoundButton.textContent = "Sound: OFF (Error)";
            const errDiv = document.getElementById('error-message');
            if (errDiv) {
                 errDiv.textContent = `Audio initialization failed: ${e.message}. Sound will be disabled.`;
                 errDiv.style.display = 'block';
            }
        }
    }

    function toggleSound() {
        params.soundEnabled = !params.soundEnabled;
        toggleSoundButton.textContent = params.soundEnabled ? "Sound: ON" : "Sound: OFF";
        document.querySelector('.sound-indicator').style.opacity = params.soundEnabled ? 1 : 0;
        if (params.soundEnabled && !isSoundInitialized) {
            initAudio().catch(e => console.error("Failed to init audio on toggle:", e));
        } else if (!params.soundEnabled && audioContext && audioContext.state === 'running') {
            audioContext.suspend();
        } else if (params.soundEnabled && audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
    }
    
    function init() {
        if (renderer) { // Cleanup previous instance
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if(renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
            renderer.dispose();
            if (geometry) geometry.dispose();
            if (material) material.dispose();
            if (controls) controls.dispose();
        }
        spawnIndex = 0;


        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(params.cameraFov, window.innerWidth / window.innerHeight, params.cameraNear, params.cameraFar);
        camera.position.copy(params.cameraInitialPosition);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(params.backgroundColor);
        document.getElementById('container').appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.screenSpacePanning = false;
        controls.minDistance = 50;
        controls.maxDistance = 2000;
        controls.enableRotate = params.enableRotation;

        // Particle system
        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(params.particleCount * 3);
        velocities = new Float32Array(params.particleCount * 3);
        accelerations = new Float32Array(params.particleCount * 3);
        phases = new Float32Array(params.particleCount);
        originalPositions = new Float32Array(params.particleCount * 3);
        particleMasses = new Float32Array(params.particleCount);
        const colors = new Float32Array(params.particleCount * 3);
        particleColorHSL = [];


        for (let i = 0; i < params.particleCount; i++) {
            const i3 = i * 3;
            // Initialize positions randomly within a sphere or box
            const r = params.boxSize * Math.cbrt(Math.random()); // Distribute uniformly in sphere
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            positions[i3] = originalPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = originalPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = originalPositions[i3 + 2] = r * Math.cos(phi);

            velocities[i3] = (Math.random() - 0.5) * 0.1;
            velocities[i3 + 1] = (Math.random() - 0.5) * 0.1;
            velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
            
            accelerations[i3] = 0;
            accelerations[i3+1] = 0;
            accelerations[i3+2] = 0;

            phases[i] = Math.random() * Math.PI * 2; // Random phase for each particle
            particleMasses[i] = 0.5 + Math.random() * 0.5; // Mass between 0.5 and 1.0

            const baseHue = (new THREE.Color(params.particleColorBase)).getHSL({h:0,s:0,l:0}).h;
            const hue = (baseHue + (Math.random() - 0.5) * params.particleColorSpread) % 1.0;
            const saturation = 0.6 + Math.random() * 0.4; // Vibrant colors
            const lightness = 0.4 + Math.random() * 0.3;
            particleColorHSL.push({h: hue, s: saturation, l: lightness});
            
            const color = new THREE.Color();
            color.setHSL(hue, saturation, lightness);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        material = new THREE.PointsMaterial({
            size: params.baseParticleSize,
            vertexColors: true,
            opacity: params.particleOpacity,
            transparent: true,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending, 
            depthWrite: false 
        });

        particles = new THREE.Points(geometry, material);
        scene.add(particles);
        
        if(params.showCentralMass) {
            const centralMassGeo = new THREE.SphereGeometry(params.centralMassSize, 32, 32);
            const centralMassMat = new THREE.MeshBasicMaterial({ color: params.centralMassColor, wireframe: true });
            const centralMassMesh = new THREE.Mesh(centralMassGeo, centralMassMat);
            scene.add(centralMassMesh);
        }

        window.addEventListener('resize', onWindowResize, false);
        particleStat.textContent = params.particleCount.toLocaleString();
        lastTime = performance.now(); // for FPS
    }

    let lastTime = 0;
    let timeAccumulator = 0;
    let frameCount = 0;

    function updateParticles(time) {
        const dt = Math.min(0.016, (time - (lastTime || time)) / 1000) * params.timeScale; // Delta time in seconds, capped
        lastTime = time;

        timeAccumulator += dt;
        frameCount++;
        if (timeAccumulator >= 1) {
            fpsStat.textContent = frameCount;
            frameCount = 0;
            timeAccumulator -=1;
        }
        timeStat.textContent = (audioContext ? audioContext.currentTime.toFixed(1) : (performance.now()/1000).toFixed(1)) + "s";


        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.color.array;
        const currentTime = (audioContext ? audioContext.currentTime : performance.now() / 1000) * params.timeScale;
        
        const pulseInterval = 60 / params.heartRate; // seconds
        let currentPulseForce = 0;
        if (currentTime - lastPulseTime >= pulseInterval) {
            lastPulseTime = currentTime;
            if (params.soundEnabled && pulseSynth && audioContext.state === 'running') {
                pulseSynth.triggerAttackRelease("C2", "8n", audioContext.currentTime);
            }
            pulseIndicator.classList.add('pulse-active');
            setTimeout(() => pulseIndicator.classList.remove('pulse-active'), 700);
            currentPulseForce = params.pulseForce;

            // Modulate frequency on pulse
            if (params.soundEnabled && bassSynth && audioContext.state === 'running') {
                const baseFreqHz = params.frequency * 10; // Example mapping
                bassSynth.frequency.setValueAtTime(baseFreqHz * (1 + params.pulseFrequencyMod), audioContext.currentTime);
                bassSynth.frequency.linearRampToValueAtTime(baseFreqHz, audioContext.currentTime + pulseInterval * 0.5);
            }
        }

        const source1 = new THREE.Vector3(params.sourceOffset, 0, 0);
        const source2 = new THREE.Vector3(-params.sourceOffset, 0, 0);

        const particlesToUpdate = Math.min(params.particleCount, spawnIndex + params.particlesToSpawnPerFrame);
        for (let i = spawnIndex; i < particlesToUpdate; i++) {
            const i3 = i * 3;
            
            let x = originalPositions[i3];
            let y = originalPositions[i3 + 1];
            let z = originalPositions[i3 + 2];

            // Calculate displacement from wave 1
            let dx1 = x - source1.x;
            let dy1 = y - source1.y;
            let dz1 = z - source1.z;
            let distToSource1 = Math.sqrt(dx1 * dx1 + dy1 * dy1 + dz1 * dz1);

            // Calculate displacement from wave 2
            let dx2 = x - source2.x;
            let dy2 = y - source2.y;
            let dz2 = z - source2.z;
            let distToSource2 = Math.sqrt(dx2 * dx2 + dy2 * dy2 + dz2 * dz2);

            // Convert Cartesian to Spherical for mode application & Chirikov map
            let r_orig = Math.sqrt(x*x + y*y + z*z);
            if (r_orig < 1e-5) r_orig = 1e-5; // Avoid division by zero
            let theta_orig = Math.acos(z / r_orig); // polar angle
            let phi_orig = Math.atan2(y, x);   // azimuthal angle

            // Legendre polynomials P_n^m(cos(theta)) are complex. Using simplified modal influence.
            let Y_lm_real_approx = Math.cos(params.modeM * phi_orig) * Math.sin(params.modeN * theta_orig); 
            let radial_mode_influence = Math.sin(params.modeP * r_orig * 0.01 * params.frequency);

            let waveVal1 = 0, waveVal2 = 0;
            let baseFreqParam = params.frequency * (params.useLogFrequency ? Math.log10(params.frequency + 1) : 1);

            switch (params.waveform) {
                case 'sine':
                    waveVal1 = Math.sin(distToSource1 * baseFreqParam * 0.1 - currentTime * baseFreqParam);
                    waveVal2 = Math.sin(distToSource2 * baseFreqParam * 0.1 - currentTime * baseFreqParam);
                    break;
                case 'square':
                    waveVal1 = Math.sign(Math.sin(distToSource1 * baseFreqParam * 0.1 - currentTime * baseFreqParam));
                    waveVal2 = Math.sign(Math.sin(distToSource2 * baseFreqParam * 0.1 - currentTime * baseFreqParam));
                    break;
                case 'triangle':
                    waveVal1 = Math.asin(Math.sin(distToSource1 * baseFreqParam * 0.1 - currentTime * baseFreqParam)) * (2 / Math.PI);
                    waveVal2 = Math.asin(Math.sin(distToSource2 * baseFreqParam * 0.1 - currentTime * baseFreqParam)) * (2 / Math.PI);
                    break;
                case 'sawtooth':
                    let sawtoothPhase1 = (distToSource1 * baseFreqParam * 0.1 - currentTime * baseFreqParam) / (2 * Math.PI);
                    waveVal1 = 2 * (sawtoothPhase1 - Math.floor(0.5 + sawtoothPhase1));
                    let sawtoothPhase2 = (distToSource2 * baseFreqParam * 0.1 - currentTime * baseFreqParam) / (2 * Math.PI);
                    waveVal2 = 2 * (sawtoothPhase2 - Math.floor(0.5 + sawtoothPhase2));
                    break;
            }
            
            let combinedWaveVal = (waveVal1 + waveVal2) * 0.5; 
            if (params.sourceOffset === 0) combinedWaveVal = waveVal1; 

            let displacementFactor = params.amplitude * combinedWaveVal * Y_lm_real_approx * radial_mode_influence;

            // Chirikov Standard Map adaptation for phi (azimuthal angle)
            // p_new = p_old + K * sin(theta_old)
            // theta_new = theta_old + p_new (mod 2PI)
            // Using phases[i] to store 'angular momentum' p_phi for this particle
            let p_phi = phases[i]; 
            p_phi = p_phi + params.chaosStrengthK * Math.sin(phi_orig); // Kick
            let new_phi = phi_orig + p_phi; // Drift
            phases[i] = p_phi; // Store new momentum (can be unbounded, or wrapped if desired)
            
            // Keep new_phi within [-PI, PI] for trigonometric functions if needed, though raw value also works for reconstruction
            // new_phi = ((new_phi + Math.PI) % (2 * Math.PI)) - Math.PI;


            // New position based on original radius, original polar angle (theta_orig), and chaotically evolved azimuthal angle (new_phi)
            // The displacementFactor is applied radially or along the original vector direction.
            let final_r = r_orig + displacementFactor; // displacementFactor primarily affects radius
            
            let targetX = final_r * Math.sin(theta_orig) * Math.cos(new_phi);
            let targetY = final_r * Math.sin(theta_orig) * Math.sin(new_phi);
            let targetZ = final_r * Math.cos(theta_orig);


            // Central Gravity (simplified)
            let dx_g = -positions[i3]; // dx for gravity calculation
            let dy_g = -positions[i3 + 1]; // dy for gravity calculation
            let dz_g = -positions[i3 + 2]; // dz for gravity calculation
            let distSq_g = dx_g * dx_g + dy_g * dy_g + dz_g * dz_g;
            let dist_g = Math.sqrt(distSq_g);
            let force_g = (params.gravityStrength / (distSq_g + 1000)) * particleMasses[i]; // Added softening factor 1000

            accelerations[i3] = force_g * (dx_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetX - positions[i3]) * 0.1; // Spring force towards target
            accelerations[i3+1] = force_g * (dy_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetY - positions[i3+1]) * 0.1;
            accelerations[i3+2] = force_g * (dz_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetZ - positions[i3+2]) * 0.1;
            
            // Add pulse force directed outwards from origin
            if (currentPulseForce > 0 && dist_g > 1e-5) {
                accelerations[i3] += currentPulseForce * (positions[i3] / dist_g) / particleMasses[i];
                accelerations[i3+1] += currentPulseForce * (positions[i3+1] / dist_g) / particleMasses[i];
                accelerations[i3+2] += currentPulseForce * (positions[i3+2] / dist_g) / particleMasses[i];
            }

            velocities[i3] += accelerations[i3] * dt;
            velocities[i3 + 1] += accelerations[i3 + 1] * dt;
            velocities[i3 + 2] += accelerations[i3 + 2] * dt;

            // Damping & Speed limit
            velocities[i3] *= params.dampingFactor;
            velocities[i3 + 1] *= params.dampingFactor;
            velocities[i3 + 2] *= params.dampingFactor;

            const speed = Math.sqrt(velocities[i3]*velocities[i3] + velocities[i3+1]*velocities[i3+1] + velocities[i3+2]*velocities[i3+2]);
            if (speed > params.maxVelocity) {
                const factor = params.maxVelocity / speed;
                velocities[i3] *= factor;
                velocities[i3 + 1] *= factor;
                velocities[i3 + 2] *= factor;
            }
            
            positions[i3] += velocities[i3] * dt;
            positions[i3 + 1] += velocities[i3 + 1] * dt;
            positions[i3 + 2] += velocities[i3 + 2] * dt;

            // Color update based on velocity or phase (example: velocity magnitude)
            const currentSpeedNormalized = Math.min(1, speed / params.maxVelocity);
            const {h, s, l} = particleColorHSL[i];
            const newLightness = Math.max(0.1, Math.min(0.9, l * (0.5 + currentSpeedNormalized * 0.5))); // Modulate lightness by speed
            const newHue = (h + currentTime * params.colorShiftSpeed * 0.1) % 1.0; // Slow hue shift over time
            
            const tempColor = new THREE.Color();
            tempColor.setHSL(newHue, s, newLightness);
            colors[i3] = tempColor.r;
            colors[i3 + 1] = tempColor.g;
            colors[i3 + 2] = tempColor.b;
        }
        spawnIndex = particlesToUpdate % params.particleCount;


        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
    }


    function animate(time) {
        animationFrameId = requestAnimationFrame(animate);
        controls.update(); // only required if controls.enableDamping or controls.autoRotate are set to true
        updateParticles(time);
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function stopSimulation() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            console.log("Simulation stopped.");
            if (params.soundEnabled && audioContext && audioContext.state === 'running') {
                audioContext.suspend(); // Suspend audio context when stopping
            }
        } else { // If already stopped, resume it
            if (params.soundEnabled && audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            animate();
             console.log("Simulation resumed.");
        }
    }
    
    function setupInfoIcons() {
        document.querySelectorAll('.info-icon').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => {
                const tooltipText = e.target.getAttribute('title');
                if (!tooltipText) return;

                let tooltip = document.getElementById('info-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.id = 'info-tooltip';
                    tooltip.style.position = 'absolute';
                    tooltip.style.background = 'rgba(10, 10, 20, 0.9)';
                    tooltip.style.color = '#eee';
                    tooltip.style.padding = '8px 12px';
                    tooltip.style.borderRadius = '8px';
                    tooltip.style.fontSize = '0.8rem';
                    tooltip.style.maxWidth = '250px';
                    tooltip.style.zIndex = '1001';
                    tooltip.style.border = '1px solid rgba(138, 43, 226, 0.3)';
                    tooltip.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
                    tooltip.style.backdropFilter = 'blur(5px)';
                    document.body.appendChild(tooltip);
                }
                tooltip.textContent = tooltipText;
                tooltip.style.display = 'block';
                
                const rect = e.target.getBoundingClientRect();
                tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
                tooltip.style.top = `${rect.bottom + 8}px`;

                if (tooltip.offsetLeft < 0) tooltip.style.left = '5px';
                if (tooltip.offsetTop + tooltip.offsetHeight > window.innerHeight) tooltip.style.top = `${rect.top - tooltip.offsetHeight - 8}px`;

            });
            icon.addEventListener('mouseleave', () => {
                let tooltip = document.getElementById('info-tooltip');
                if (tooltip) tooltip.style.display = 'none';
            });
        });
    }

    function toggleFullScreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }
</script>
</body>
</html> 