<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modal Resonance Framework Validator</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
        }
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
        }
        .control-panel {
            background: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 25px;
        }
        .control-group {
            display: inline-block; 
            align-items: center;
            margin: 10px 20px 10px 0;
            vertical-align: top;
        }
        label {
            display: inline-block; 
            min-width: 180px; 
            font-weight: 500;
            color: #34495e;
            margin-right: 10px; 
            vertical-align: middle;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            min-width: 150px;
        }
        .value-display {
            display: inline-block;
            width: 80px;
            text-align: right;
            font-family: monospace;
            color: #3498db;
            vertical-align: middle;
            padding-left: 5px; 
        }
        .plot-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr)); 
            gap: 20px;
            margin-bottom: 20px;
        }
        .plot-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 10px;
            background-color: #fff; 
            min-height: 300px; 
        }
        .results-section {
            background: #e8f4f8;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            line-height: 1.5; 
        }
        .pass {
            background: #d4edda;
            color: #155724;
            border-left: 5px solid #155724;
        }
        .fail { 
            background: #f8d7da; 
            color: #721c24; 
            border-left: 5px solid #721c24; 
        }
        .info {
            background: #d1ecf1;
            color: #0c5460;
            border-left: 5px solid #0c5460;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            max-height: 350px;
            overflow-y: auto;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: background-color 0.2s ease-in-out; 
        }
        button:hover {
            background: #2980b9;
        }
        .formula {
            background: #f8f9fa;
            padding: 15px; 
            margin: 15px 0; 
            border-radius: 5px;
            font-size: 1.1em; 
            border-left: 3px solid #3498db;
            overflow-x: auto; 
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Modal Resonance Framework Validator</h1>
        <p class="subtitle">Testing acoustic resonance enhancement of cosmic structure formation</p>
        
        <div class="control-panel">
            <h3>Model Parameters</h3>
            <div class="control-group">
                <label>Modal Amplitude ($A$):</label>
                <input type="range" id="amplitude" min="0" max="0.5" step="0.01" value="0.20">
                <span class="value-display" id="amplitudeValue">0.20</span>
            </div>
            <div class="control-group">
                <label>Phase Shift ($\phi/\pi$):</label>
                <input type="range" id="phase" min="0" max="2" step="0.1" value="0.5">
                <span class="value-display" id="phaseValue">0.5</span>
            </div>
            <div class="control-group">
                <label>Sound Horizon ($r_s$, Mpc):</label>
                <input type="range" id="soundHorizon" min="100" max="200" step="5" value="150">
                <span class="value-display" id="soundHorizonValue">150</span>
            </div>
            <div class="control-group">
                <label>Redshift ($z$):</label>
                <input type="range" id="redshift" min="0" max="3" step="0.1" value="1.0">
                <span class="value-display" id="redshiftValue">1.0</span>
            </div>
            <div class="control-group">
                <label>Modal Order ($n_{\text{max}}$):</label>
                <input type="range" id="modalOrder" min="1" max="5" step="1" value="4">
                <span class="value-display" id="modalOrderValue">4</span>
            </div>
            <div class="control-group">
                <label>Wave Type:</label>
                <select id="waveType">
                    <option value="sine">Sine</option>
                    <option value="square">Square</option>
                    <option value="triangle">Triangle</option>
                    <option value="sawtooth" selected>Sawtooth</option>
                </select>
            </div>
            <br>
            <button onclick="updatePlotsAndResults()">Update Analysis & Results</button>
            </div>
        
        <div class="plot-grid">
            <div id="powerSpectrumPlot" class="plot-container"></div>
            <div id="scaleRatioPlot" class="plot-container"></div>
            <div id="biasPlot" class="plot-container"></div>
            <div id="evolutionPlot" class="plot-container"></div>
        </div>
        
        <div class="results-section">
            <h3>Validation Results & Detected Ratios</h3>
            <div id="testResults"></div> 
            <h3>Key Formulas Being Tested</h3>
            <div class="formula">
                $P(k) = P_{\text{standard}}(k) [1 + A \times f_{\text{wave}}(k r_s + \phi)]$
            </div>
            <div class="formula">
                $\lambda(z) = \lambda_0 (1+z)^\alpha [\Omega_m(z)/\Omega_{m,0}]^\beta$
            </div>
            <div class="formula">
                $b(k,z) = b_0(z) [1 + A_b f_{\text{modal}}(k)]$
            </div>
        </div>
    </div>

    <script>
        const H0 = 70; 
        const OMEGA_M0 = 0.3;
        const OMEGA_LAMBDA = 0.7;
        
        const amplitudeSlider = document.getElementById('amplitude');
        const phaseSlider = document.getElementById('phase');
        const soundHorizonSlider = document.getElementById('soundHorizon');
        const redshiftSlider = document.getElementById('redshift');
        const modalOrderSlider = document.getElementById('modalOrder');
        const waveTypeSelector = document.getElementById('waveType');
        
        const testResultsDiv = document.getElementById('testResults');

        function setupSliderListener(slider) {
            const display = slider.nextElementSibling;
            slider.oninput = function() {
                const step = parseFloat(this.step);
                let decimals = 0;
                if (Math.floor(step) !== step) { decimals = (step.toString().split(".")[1] || "").length; }
                if(display) display.textContent = parseFloat(this.value).toFixed(decimals);
            };
        }
        document.querySelectorAll('.control-group input[type="range"]').forEach(setupSliderListener);
        
        function hubbleParameter(z) { return H0 * Math.sqrt(OMEGA_M0 * Math.pow(1 + z, 3) + OMEGA_LAMBDA); }
        function matterDensityParameter(z) { const H_z = hubbleParameter(z); return OMEGA_M0 * Math.pow(1 + z, 3) * Math.pow(H0 / H_z, 2); }
        function P_standard(k) { const n_s = 0.96; const A_s = 2.1e-9; const k_pivot = 0.05; return A_s * Math.pow(k / k_pivot, n_s - 1); }
        
        // --- Fourier series approximations for different waveforms ---
        function sineWave(x) { return Math.sin(x); }
        function squareWave(x) {
            let sum = 0;
            for (let n = 1; n <= 9; n += 2) { sum += (1 / n) * Math.sin(n * x); }
            return (4 / Math.PI) * sum; 
        }
        function triangleWave(x) {
            let sum = 0;
            for (let n = 1; n <= 9; n += 2) {
                const sign = ((n - 1) / 2) % 2 === 0 ? 1 : -1;
                sum += sign * (1 / (n * n)) * Math.sin(n * x);
            }
            return (8 / (Math.PI * Math.PI)) * sum;
        }
        function sawtoothWave(x) {
            let sum = 0;
            for (let n = 1; n <= 10; n++) { sum += (1 / n) * Math.sin(n * x); }
            return (2 / Math.PI) * sum;
        }
        // --- End of Waveform Functions ---
        
        function modalEnhancementFactor(k, A, r_s, phi, waveType) {
            const x = k * r_s + phi;
            let waveValue = 0;
            switch(waveType) {
                case 'square': waveValue = squareWave(x); break;
                case 'triangle': waveValue = triangleWave(x); break;
                case 'sawtooth': waveValue = sawtoothWave(x); break;
                case 'sine': default: waveValue = sineWave(x); break;
            }
            return 1 + A * waveValue;
        }
        
        function P_enhanced(k, A, r_s, phi, waveType) { return P_standard(k) * modalEnhancementFactor(k, A, r_s, phi, waveType); }
        function galaxyBias(k, z, A_b_modal) { const b0_z = 1 + 0.84 * z; const r_s_current = parseFloat(soundHorizonSlider.value); const k_modal_peak = 2 * Math.PI / r_s_current; const f_modal_bias = Math.exp(-Math.pow((k - k_modal_peak) / (0.1 * k_modal_peak), 2)); return b0_z * (1 + A_b_modal * f_modal_bias); }
        function findPeaks(k_array, P_array) { const peaks = []; if (k_array.length < 3) return peaks; for (let i = 1; i < k_array.length - 1; i++) { if (P_array[i] > P_array[i-1] && P_array[i] > P_array[i+1] && P_array[i] > 1e-10) { peaks.push({k: k_array[i], P: P_array[i], index: i, lambda: (2*Math.PI/k_array[i])}); } } return peaks; }
        
        function plotPowerSpectrum() {
            const A = parseFloat(amplitudeSlider.value); const phi = parseFloat(phaseSlider.value) * Math.PI; const r_s = parseFloat(soundHorizonSlider.value); const waveType = waveTypeSelector.value;
            const k_values = [], P_std_values = [], P_enh_values = [];
            for (let logk = -3; logk <= 0; logk += 0.01) { const k_val = Math.pow(10, logk); k_values.push(k_val); P_std_values.push(P_standard(k_val)); P_enh_values.push(P_enhanced(k_val, A, r_s, phi, waveType)); }
            const trace_std = { x: k_values, y: P_std_values, name: '$P_{\\text{standard}}(k)$', type: 'scatter', mode: 'lines', line: {color: 'blue', width: 2} };
            const trace_enh = { x: k_values, y: P_enh_values, name: '$P_{\\text{enhanced}}(k)$', type: 'scatter', mode: 'lines', line: {color: 'red', width: 2} };
            const layout = { title: `Power Spectrum (${waveType.charAt(0).toUpperCase() + waveType.slice(1)} Wave)`, xaxis: {title: '$k$ (h/Mpc)', type: 'log', autorange: true}, yaxis: {title: '$P(k)$', type: 'log', autorange: true}, showlegend: true, legend: {x: 0.05, y: 0.95, bgcolor: 'rgba(255,255,255,0.5)'} };
            Plotly.newPlot('powerSpectrumPlot', [trace_std, trace_enh], layout, {responsive: true});
        }
        
        function plotScaleRatios() {
            const n_max = parseInt(modalOrderSlider.value); const A = parseFloat(amplitudeSlider.value); const phi = parseFloat(phaseSlider.value) * Math.PI; const r_s = parseFloat(soundHorizonSlider.value); const waveType = waveTypeSelector.value;
            const theoretical_ratios_k = [], theoretical_labels_k = [];
            if (n_max > 1) { for (let i = 1; i < n_max; i++) { for (let j = i + 1; j <= n_max; j++) { theoretical_ratios_k.push(j / i); theoretical_labels_k.push(`$k_{${j}}/k_{${i}}$ (Th)`); } } }
            const k_spectrum = [], P_enh_spectrum = [];
            for (let logk = -3; logk <= 0; logk += 0.005) { const k_val = Math.pow(10, logk); k_spectrum.push(k_val); P_enh_spectrum.push(P_enhanced(k_val, A, r_s, phi, waveType)); }
            const detected_peaks = findPeaks(k_spectrum, P_enh_spectrum);
            const detected_ratios_k = [], detected_labels_k = [];
            if (detected_peaks.length >= 2) { for (let i = 0; i < detected_peaks.length -1; i++) { for (let j = i + 1; j < detected_peaks.length; j++) { if (detected_ratios_k.length >= theoretical_ratios_k.length + 5) break; detected_ratios_k.push(detected_peaks[j].k / detected_peaks[i].k); detected_labels_k.push(`$k_{p${j+1}}/k_{p${i+1}}$ (Det)`); } if (detected_ratios_k.length >= theoretical_ratios_k.length + 5) break; } }
            const trace_theoretical = { x: theoretical_labels_k, y: theoretical_ratios_k, name: 'Theoretical ($k_j/k_i$)', type: 'bar', marker: {color: 'steelblue'} };
            const trace_detected = { x: detected_labels_k, y: detected_ratios_k, name: 'Detected from Peaks', type: 'bar', marker: {color: 'orange'} };
            const layout = { title: 'Wavenumber Ratio Analysis ($k_j/k_i$)', xaxis: {title: 'Ratio Pair', type: 'category', tickangle: -45}, yaxis: {title: 'Ratio Value', autorange: true}, barmode: 'group', showlegend: true, legend: {bgcolor: 'rgba(255,255,255,0.5)'} };
            Plotly.newPlot('scaleRatioPlot', [trace_theoretical, trace_detected], layout, {responsive: true});
        }

        function plotBias() { const z_current = parseFloat(redshiftSlider.value); const A_b_modal = 0.2; const k_values = [], bias_modal_values = [], bias_std_values = []; for (let logk = -2; logk <= 0; logk += 0.02) { const k_val = Math.pow(10, logk); k_values.push(k_val); bias_modal_values.push(galaxyBias(k_val, z_current, A_b_modal)); bias_std_values.push(galaxyBias(k_val, z_current, 0)); } const trace_std_bias = { x: k_values, y: bias_std_values, name: 'Standard Bias $b(k,z)$', type: 'scatter', mode: 'lines', line: {color: 'blue', width: 2} }; const trace_modal_bias = { x: k_values, y: bias_modal_values, name: 'Modal Bias $b(k,z)$', type: 'scatter', mode: 'lines', line: {color: 'red', width: 2} }; const layout = { title: `Scale-Dependent Galaxy Bias at $z=${z_current.toFixed(1)}$`, xaxis: {title: '$k$ (h/Mpc)', type: 'log', autorange: true}, yaxis: {title: '$b(k)$', autorange: true}, showlegend: true, legend: {bgcolor: 'rgba(255,255,255,0.5)'} }; Plotly.newPlot('biasPlot', [trace_std_bias, trace_modal_bias], layout, {responsive: true}); }
        function plotEvolution() { const r_s0 = parseFloat(soundHorizonSlider.value); const z_values = [], lambda_modal_values = [], lambda_standard_expansion_values = []; for (let z_val = 0; z_val <= 3; z_val += 0.1) { z_values.push(z_val); const alpha_exp = 1.0; const beta_dens = 0.3; const Om_z = matterDensityParameter(z_val); const lambda_modal = r_s0 * Math.pow(1 + z_val, alpha_exp) * Math.pow(Om_z / OMEGA_M0, beta_dens); lambda_modal_values.push(lambda_modal); lambda_standard_expansion_values.push(r_s0 * (1 + z_val)); } const trace_std_evo = { x: z_values, y: lambda_standard_expansion_values, name: 'Proper Scale ($r_{s0}(1+z)$)', type: 'scatter', mode: 'lines', line: {color: 'blue', width: 2} }; const trace_modal_evo = { x: z_values, y: lambda_modal_values, name: 'Modal Scale $\\lambda(z)$', type: 'scatter', mode: 'lines', line: {color: 'red', width: 2} }; const layout = { title: 'Characteristic Scale Evolution with Redshift', xaxis: {title: 'Redshift ($z$)', autorange: true}, yaxis: {title: '$\\lambda(z)$ (Mpc)', autorange: true}, showlegend: true, legend: {bgcolor: 'rgba(255,255,255,0.5)'} }; Plotly.newPlot('evolutionPlot', [trace_modal_evo, trace_std_evo], layout, {responsive: true}); }
        function updatePlots() { plotPowerSpectrum(); plotScaleRatios(); plotBias(); plotEvolution(); }
        
        function runValidationTests() {
            const results = []; const A = parseFloat(amplitudeSlider.value); const r_s = parseFloat(soundHorizonSlider.value); const z_current = parseFloat(redshiftSlider.value); const n_max = parseInt(modalOrderSlider.value); const phi = parseFloat(phaseSlider.value) * Math.PI; const waveType = waveTypeSelector.value;
            const test1_pass = A < 0.3; results.push({ name: "Homogeneity Preservation", pass: test1_pass, details: `Modal amplitude $A=${A.toFixed(2)}$. ${test1_pass ? 'Value suggests perturbation is sub-dominant ($A < 0.3$)' : 'Value is large ($A \\ge 0.3$), may impact homogeneity assumption.'}` });
            const k_char = 2 * Math.PI / r_s; results.push({ name: "Characteristic Scale Definition", pass: r_s > 0, details: `Fundamental wavenumber $k_s = 2\\pi/r_s = ${k_char.toFixed(4)}$ h/Mpc (for $r_s = ${r_s.toFixed(0)}$ Mpc).` });
            const H_z = hubbleParameter(z_current); const Om_z = matterDensityParameter(z_current); results.push({ name: "Cosmological Parameter Check", pass: true, details: `At $z=${z_current.toFixed(1)}$: $H(z)=${H_z.toFixed(1)}$ km/s/Mpc, $\\Omega_m(z)=${Om_z.toFixed(3)}$` });
            const expected_k_ratios_text = []; if (n_max > 1) { for (let i = 1; i < n_max; i++) { expected_k_ratios_text.push(`${i+1}:${i}`); } } results.push({ name: "Expected Modal Wavenumber Ratios ($k_{n+1}/k_n$)", pass: n_max >= 2, details: `For $n_{\\text{max}}=${n_max}$, expect fundamental ratios like ${expected_k_ratios_text.join(', ') || 'N/A'}.` });
            const enhancement_at_k_char = modalEnhancementFactor(k_char, A, r_s, phi, waveType); const test5_pass = Math.abs(enhancement_at_k_char - 1.0) > 1e-3; results.push({ name: "Enhancement at Fundamental Scale", pass: test5_pass, details: `At $k_s$: enhancement factor = ${enhancement_at_k_char.toFixed(3)}. ${test5_pass ? 'Enhancement is present.' : 'No significant enhancement at this scale with current parameters.'}` });
            let html = '<h4>Validation Checks:</h4>'; results.forEach(result => { const className = result.pass ? 'pass' : 'fail'; html += `<div class="test-result ${className}"><strong>${result.name}:</strong> ${result.pass ? 'PASSED' : 'FAILED'}<br>${result.details}</div>`; }); return html; 
        }
        
        function detectRatiosFromPeaks() {
            const A = parseFloat(amplitudeSlider.value); const phi = parseFloat(phaseSlider.value) * Math.PI; const r_s = parseFloat(soundHorizonSlider.value); const waveType = waveTypeSelector.value;
            const k_spectrum = [], P_enh_spectrum = []; for (let logk = -3; logk <= 0; logk += 0.005) { const k_val = Math.pow(10, logk); k_spectrum.push(k_val); P_enh_spectrum.push(P_enhanced(k_val, A, r_s, phi, waveType)); } const peaks = findPeaks(k_spectrum, P_enh_spectrum); 
            let html = '<div class="info"><h4>Detected Peaks and Wavenumber Ratios:</h4>';
            if (peaks.length < 2) { html += 'Insufficient peaks detected to calculate ratios. Try adjusting amplitude or phase for more distinct features.'; } else { html += `Found ${peaks.length} peaks:<br>`; peaks.forEach((peak, i) => { html += `Peak ${i+1}: $k = ${peak.k.toFixed(4)}$ h/Mpc, ($\\lambda = ${peak.lambda.toFixed(1)}$ Mpc)<br>`; }); html += '<br>Wavenumber Ratios ($k_j/k_i$, $j>i$):<br>'; let ratioCount = 0; for (let i = 0; i < peaks.length -1 && ratioCount < 10; i++) { for (let j = i + 1; j < peaks.length && ratioCount < 10; j++) { if (j > i + 3 && peaks.length > 5) continue; const ratio_kj_ki = peaks[j].k / peaks[i].k; html += `$k_{\\text{peak }${j+1}}/k_{\\text{peak }${i+1}} = ${ratio_kj_ki.toFixed(3)}$<br>`; ratioCount++; } } }
            html += '</div>'; return html; 
        }

        function updatePlotsAndResults() {
            updatePlots();
            let validationHtml = runValidationTests();
            let ratioHtml = detectRatiosFromPeaks();
            testResultsDiv.innerHTML = validationHtml + ratioHtml;
            
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([testResultsDiv]).catch((err) => console.error('MathJax typesetting error on dynamic update: ', err));
            } else {
                 console.warn("MathJax not available for dynamic content in testResultsDiv.");
            }
        }
        
        function initializeDisplays() {
            document.querySelectorAll('.control-group input[type="range"]').forEach(slider => {
                const display = slider.nextElementSibling;
                if (display && display.classList.contains('value-display')) {
                    const step = parseFloat(slider.step);
                    let decimals = 0;
                    if (Math.floor(step) !== step) { decimals = (step.toString().split(".")[1] || "").length; }
                    display.textContent = parseFloat(slider.value).toFixed(decimals);
                }
            });
        }
        
        window.addEventListener('load', () => {
            console.log("Window fully loaded.");
            initializeDisplays(); 
            if (window.MathJax && typeof MathJax.startup !== 'undefined' && MathJax.startup.ready) {
                MathJax.startup.ready.then(() => {
                    console.log("MathJax is ready. Performing initial plot and results.");
                    updatePlotsAndResults();
                }).catch(err => {
                    console.error("MathJax failed to become ready:", err);
                    updatePlotsAndResults(); 
                });
            } else {
                console.warn("MathJax or MathJax.startup.ready not available on window load. Plotting without MathJax for dynamic content.");
                updatePlotsAndResults(); 
            }
        });

    </script>
</body>
</html>
