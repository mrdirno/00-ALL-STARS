<!DOCTYPE html>
<!--
    Resonance is All You Need: A Bio-Cymatic Model of Cosmic Structure Formation
    MODIFIED FOR ADVANCED WAVE THEORY VISUALIZATION - AGENT 1
    
    Original Concept & Implementation by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Claude Opus 4 (AI Research Assistant & Code Architect) 
    - Gemini 2.5 Pro (AI Research Assistant & Mathematical Modeling)
    
    This version incorporates illustrative advanced wave theory mathematics for particle dynamics.
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, Agent 1 (Wave Theory Mod)">
    <meta name="description" content="Bio-Cymatic Model with Advanced Wave Theory - Original research by Aldrin Payopay, modified by Agent 1">
    <meta name="keywords" content="Aldrin Payopay, bio-cymatics, cosmic structure, gravitational waves, resonance, wave theory">
    <title>Resonance: Wave Theory Transformation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* CSS Styles - Preserved from origin-simple.html */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 360px; 
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }
        #controls-panel::-webkit-scrollbar { width: 8px; }
        #controls-panel::-webkit-scrollbar-track { background: rgba(25, 25, 45, 0.1); border-radius: 10px; }
        #controls-panel::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 10px; border: 1px solid rgba(25, 25, 45, 0.2); }
        #controls-panel::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #9F50E8 0%, #5D1DE0 100%); }
        #controls-panel { scrollbar-width: thin; scrollbar-color: #8A2BE2 rgba(25, 25, 45, 0.1); }
        @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        @keyframes slideInUp { to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        .control-group { margin-bottom: 20px; }
        #controls-panel .control-group { padding-right: 14px; }
        #controls-panel h2 { padding-right: 14px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-group label[title] { cursor: help; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; font-weight: 400; text-transform: none; letter-spacing: normal; margin-top: -8px; margin-bottom: 12px; }
        .info-icon { font-size: 0.7em; color: rgba(138, 43, 226, 0.7); font-weight: 400; margin-left: 8px; cursor: help; transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
        .info-icon:hover { color: rgba(138, 43, 226, 1); transform: scale(1.1); }
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; transition: background 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); transition: all 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        select, .ui-input-number { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; font-weight: 500; cursor: pointer; outline: none; transition: all 0.3s ease; -moz-appearance: textfield; }
        select:hover, .ui-input-number:hover { background: rgba(45, 45, 65, 0.15); border-color: rgba(120, 120, 220, 0.3); }
        select:focus, .ui-input-number:focus { border-color: #8A2BE2; box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2); }
        .ui-input-number::-webkit-outer-spin-button, .ui-input-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); transition: left 0.5s ease; }
        button:hover::before { left: 0; }
        button:active { transform: scale(0.98); box-shadow: 0 0 15px rgba(138, 43, 226, 0.5); }
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 18px; background: linear-gradient(135deg, #C38FFF 0%, #A56EFF 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: 0 2px 10px rgba(138, 43, 226, 0.2); }
        #title-card {
            position: absolute;
            top: 20px;
            right: 20px;
            width: auto; /* Adjust width automatically */
            max-width: 400px; /* Max width before text wraps */
            padding: 20px; /* Slightly less padding */
            text-align: right; /* Align text to the right */
            opacity: 0;
            transform: translateX(20px);
            animation: slideInRight 0.6s ease forwards;
            animation-delay: 0.4s;
        }
        @keyframes slideInRight { to { opacity: 1; transform: translateX(0); } }
        #title-card h1 { font-size: 1.4rem; font-weight: 700; margin-bottom: 4px; line-height: 1.2; color: #fff; }
        #title-card p { font-size: 0.8rem; color: rgba(200, 200, 255, 0.7); margin-bottom: 12px; line-height: 1.4; }
        .author-credit { font-size: 0.7rem; color: rgba(150, 150, 200, 0.6); }
        .loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1000;
            color: white; font-size: 1.5rem;
        }
        .loading-spinner {
            border: 8px solid rgba(255,255,255,0.2);
            border-top: 8px solid #8A2BE2;
            border-radius: 50%;
            width: 60px; height: 60px;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        Initializing Wave Simulation...
    </div>

    <div id="container"></div>

    <div id="controls-panel" class="ui-panel">
        <h2>Wave Theory Controls</h2>
        
        <div class="control-group">
            <label for="particleCountSlider">Particles: <span id="particleCountValue" class="control-value">50000</span></label>
            <input type="range" id="particleCountSlider" min="1000" max="250000" step="1000" value="50000">
            <small>Number of particles in simulation.</small>
        </div>

        <div class="control-group">
            <label for="wavePotentialStrengthSlider">Potential Strength: <span id="wavePotentialStrengthValue" class="control-value">0.1</span></label>
            <input type="range" id="wavePotentialStrengthSlider" min="0.001" max="1.0" step="0.001" value="0.1">
            <small>Amplitude of the wave potential field.</small>
        </div>

        <div class="control-group">
            <label for="particleMassSlider">Particle Mass: <span id="particleMassValue" class="control-value">0.01</span></label>
            <input type="range" id="particleMassSlider" min="0.001" max="0.1" step="0.001" value="0.01">
            <small>Inertial mass of particles.</small>
        </div>
        
        <div class="control-group">
            <label for="dampingFactorSlider">Damping: <span id="dampingFactorValue" class="control-value">0.98</span></label>
            <input type="range" id="dampingFactorSlider" min="0.8" max="1.0" step="0.001" value="0.98">
            <small>Velocity damping factor per step.</small>
        </div>

        <div class="control-group">
            <h3>Wave Parameters (k<sub>x</sub>, k<sub>y</sub>, k<sub>z</sub>, &omega;)</h3>
            <label for="waveKxSlider">k<sub>x</sub>: <span id="waveKxValue" class="control-value">2</span></label>
            <input type="range" id="waveKxSlider" min="0.1" max="10" step="0.1" value="2">
            <small>Wave number for X-axis.</small>

            <label for="waveKySlider">k<sub>y</sub>: <span id="waveKyValue" class="control-value">2</span></label>
            <input type="range" id="waveKySlider" min="0.1" max="10" step="0.1" value="2">
            <small>Wave number for Y-axis.</small>

            <label for="waveKzSlider">k<sub>z</sub>: <span id="waveKzValue" class="control-value">2</span></label>
            <input type="range" id="waveKzSlider" min="0.1" max="10" step="0.1" value="2">
            <small>Wave number for Z-axis.</small>

            <label for="waveOmegaSlider">&omega; (Time Factor): <span id="waveOmegaValue" class="control-value">1.0</span></label>
            <input type="range" id="waveOmegaSlider" min="0.0" max="5.0" step="0.05" value="1.0">
            <small>Temporal frequency of the wave potential.</small>
        </div>
        
        <button id="resetButton">Reset Simulation</button>
    </div>

    <div id="stats-bar" class="ui-panel">
        <div class="stat-item">
            <span class="stat-label">Time Elapsed</span>
            <span id="timeElapsed" class="stat-value">0.0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">FPS</span>
            <span id="fpsCounter" class="stat-value">0</span>
        </div>
         <div class="stat-item">
            <span class="stat-label">Particles</span>
            <span id="activeParticles" class="stat-value">0</span>
        </div>
    </div>

    <div id="title-card" class="ui-panel">
        <h1>Resonance: Wave Theory Transformation</h1>
        <p>An interactive 3D simulation demonstrating particle dynamics under an advanced wave-based potential field. This explores emergent patterns from fundamental wave interactions, inspired by theories of large-scale cosmic structure formation.</p>
        <p class="author-credit">Original Concept: Aldrin Payopay<br>AI Collaborators: Claude Opus 4, Gemini 2.5 Pro<br>Wave Theory Mod: Agent 1</p>
    </div>

    <script>
        let scene, camera, renderer, particleSystem, controls, clock;
        let particles = [];
        let particleCount = 50000; // Default, will be set by slider
        const MAX_PARTICLES = 250000;


        const simConfig = {
            BOUNDS: 100,
            wavePotentialStrength: 0.1,
            particleMass: 0.01,
            dampingFactor: 0.98,
            waveParams: { kx: 2, ky: 2, kz: 2, omega: 1.0 },
        };

        let lastFrameTime = performance.now();
        let frameCount = 0;
        let simulationTime = 0;

        function init() {
            document.getElementById('loadingOverlay').style.display = 'flex';

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            clock = new THREE.Clock();

            initParticles();
            setupUI();
            
            window.addEventListener('resize', onWindowResize, false);
            
            // Short delay to allow initial rendering before hiding overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').style.display = 'none';
                animate();
            }, 100);
        }

        function initParticles() {
            if (particleSystem) scene.remove(particleSystem);

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3); // Added velocities array

            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() * 2 - 1) * simConfig.BOUNDS;
                positions[i * 3 + 1] = (Math.random() * 2 - 1) * simConfig.BOUNDS;
                positions[i * 3 + 2] = (Math.random() * 2 - 1) * simConfig.BOUNDS;

                // Initial velocities (can be zero or random)
                velocities[i * 3] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;

                color.setHSL(Math.random(), 0.7, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3)); // Set velocity attribute

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    pointSize: { value: 1.5 } // Adjust point size as needed
                },
                vertexShader: `
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    uniform float pointSize;
                    void main() {
                        vColor = customColor;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = pointSize * (200.0 / -mvPosition.z); // Size attenuation
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard; // circular points
                        gl_FragColor = vec4(vColor, smoothstep(0.5, 0.4, dist)); // alpha falloff
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            document.getElementById('activeParticles').textContent = particleCount.toLocaleString();
        }
        
        // Advanced Wave Theory Potential - MODIFIED BY AGENT 1
        function calculateAdvancedWavePotential(x, y, z, time, config) {
            const kx_norm = config.waveParams.kx * Math.PI / config.BOUNDS;
            const ky_norm = config.waveParams.ky * Math.PI / config.BOUNDS;
            const kz_norm = config.waveParams.kz * Math.PI / config.BOUNDS;
            
            // Use omega for temporal evolution of phases
            const omega_base = config.waveParams.omega * 0.1; // Slow down overall temporal evolution for visual clarity
            
            const wx_t = omega_base * 0.5 * time * 0.001;
            const wy_t = omega_base * 0.7 * time * 0.001;
            const wz_t = omega_base * 0.9 * time * 0.001;
            const wd1_t = omega_base * 1.1 * time * 0.001;
            const wd2_t = omega_base * 1.3 * time * 0.001;

            const A = config.wavePotentialStrength;
            const sqrt3 = Math.sqrt(3);

            let potential = 0;
            potential += Math.cos(kx_norm * x + wx_t);
            potential += Math.cos(ky_norm * y + wy_t);
            potential += Math.cos(kz_norm * z + wz_t);
            
            // Diagonal waves for more complex structure
            const k_diag_factor = 0.8; // Adjust spatial frequency of diagonal waves
            potential += 0.5 * Math.cos(k_diag_factor * (kx_norm * x + ky_norm * y + kz_norm * z) / sqrt3 + wd1_t);
            potential += 0.5 * Math.cos(k_diag_factor * (kx_norm * x - ky_norm * y + kz_norm * z * 0.5) / sqrt3 + wd2_t); // Another diagonal

            return A * potential;
        }

        function calculateAdvancedPotentialGradient(x, y, z, time, config) {
            const delta = 0.01; // Small step for numerical differentiation
            // Note: Using the new potential function for gradient calculation
            const gradX = (calculateAdvancedWavePotential(x + delta, y, z, time, config) - calculateAdvancedWavePotential(x - delta, y, z, time, config)) / (2 * delta);
            const gradY = (calculateAdvancedWavePotential(x, y + delta, z, time, config) - calculateAdvancedWavePotential(x, y - delta, z, time, config)) / (2 * delta);
            const gradZ = (calculateAdvancedWavePotential(x, y, z + delta, time, config) - calculateAdvancedWavePotential(x, y, z - delta, time, config)) / (2 * delta);
            return { x: gradX, y: gradY, z: gradZ };
        }

        // OLD POTENTIAL FUNCTIONS - KEPT FOR REFERENCE IF NEEDED
        function calculateOriginalWavePotential(x, y, z, time, config) {
            const kx = config.waveParams.kx * Math.PI / config.BOUNDS;
            const ky = config.waveParams.ky * Math.PI / config.BOUNDS;
            const kz = config.waveParams.kz * Math.PI / config.BOUNDS;
            const omega = config.waveParams.omega;
            const A_factor = config.wavePotentialStrength;

            let potential = Math.sin(kx * x) * Math.sin(ky * y) * Math.sin(kz * z);
            potential *= Math.cos(omega * time * 0.001); 
            return A_factor * potential;
        }

        function calculateOriginalPotentialGradient(x, y, z, time, config) {
            const delta = 0.01; 
            const gradX = (calculateOriginalWavePotential(x + delta, y, z, time, config) - calculateOriginalWavePotential(x - delta, y, z, time, config)) / (2 * delta);
            const gradY = (calculateOriginalWavePotential(x, y + delta, z, time, config) - calculateOriginalWavePotential(x, y - delta, z, time, config)) / (2 * delta);
            const gradZ = (calculateOriginalWavePotential(x, y, z + delta, time, config) - calculateOriginalWavePotential(x, y, z - delta, time, config)) / (2 * delta);
            return { x: gradX, y: gradY, z: gradZ };
        }


        function updateParticlesWaveTheory(deltaTime) {
            if (!particleSystem || !particleSystem.geometry) return;

            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.geometry.attributes.velocity.array;
            const customColors = particleSystem.geometry.attributes.customColor.array;

            const currentTime = simulationTime; // Use accumulated simulation time for potential

            const currentConfig = { // Use simConfig directly as it's updated by UI
                BOUNDS: simConfig.BOUNDS,
                wavePotentialStrength: simConfig.wavePotentialStrength,
                particleMass: simConfig.particleMass,
                dampingFactor: simConfig.dampingFactor,
                waveParams: simConfig.waveParams
            };
            
            const dt = Math.min(deltaTime, 0.05); // Cap delta time to prevent instability

            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const x = positions[i3];
                const y = positions[i3 + 1];
                const z = positions[i3 + 2];

                // USE THE NEW ADVANCED POTENTIAL AND GRADIENT
                const gradient = calculateAdvancedPotentialGradient(x, y, z, currentTime * 1000, currentConfig); // time in ms
                const forceX = -gradient.x;
                const forceY = -gradient.y;
                const forceZ = -gradient.z;

                velocities[i3] += (forceX / currentConfig.particleMass) * dt;
                velocities[i3 + 1] += (forceY / currentConfig.particleMass) * dt;
                velocities[i3 + 2] += (forceZ / currentConfig.particleMass) * dt;

                velocities[i3] *= currentConfig.dampingFactor;
                velocities[i3 + 1] *= currentConfig.dampingFactor;
                velocities[i3 + 2] *= currentConfig.dampingFactor;

                positions[i3] += velocities[i3] * dt;
                positions[i3 + 1] += velocities[i3 + 1] * dt;
                positions[i3 + 2] += velocities[i3 + 2] * dt;

                const bound = currentConfig.BOUNDS;
                if (positions[i3] > bound || positions[i3] < -bound) { velocities[i3] *= -0.5; positions[i3] = Math.max(-bound, Math.min(bound, positions[i3]));}
                if (positions[i3+1] > bound || positions[i3+1] < -bound) { velocities[i3+1] *= -0.5; positions[i3+1] = Math.max(-bound, Math.min(bound, positions[i3+1]));}
                if (positions[i3+2] > bound || positions[i3+2] < -bound) { velocities[i3+2] *= -0.5; positions[i3+2] = Math.max(-bound, Math.min(bound, positions[i3+2]));}
                
                // Color particles based on the new potential
                const potentialValue = calculateAdvancedWavePotential(positions[i3], positions[i3+1], positions[i3+2], currentTime * 1000, currentConfig);
                // Simplified coloring based on potential magnitude and a time-varying component for dynamism
                const heat = (Math.tanh(potentialValue / (currentConfig.wavePotentialStrength * 2)) + 1) / 2; // Normalize with tanh
                const timeColorShift = (Math.sin(currentTime * currentConfig.waveParams.omega * 0.05) + 1) / 2 * 0.2; // Slow color pulse
                
                const color = new THREE.Color();
                // Color hue based on heat, saturation relatively high, lightness varies with |potential| and time
                color.setHSL( (heat * 0.6 + 0.6 + timeColorShift) % 1.0, 0.85, Math.max(0.15, Math.min(0.8, 0.4 + Math.abs(potentialValue * 0.1) )) );

                customColors[i3] = color.r;
                customColors[i3+1] = color.g;
                customColors[i3+2] = color.b;
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.velocity.needsUpdate = true;
            particleSystem.geometry.attributes.customColor.needsUpdate = true;
        }

        function setupUI() {
            // Particle Count
            const pcSlider = document.getElementById('particleCountSlider');
            const pcValue = document.getElementById('particleCountValue');
            pcSlider.max = MAX_PARTICLES; // Ensure slider max is correct
            pcSlider.value = particleCount;
            pcValue.textContent = particleCount.toLocaleString();
            pcSlider.addEventListener('input', (event) => {
                pcValue.textContent = parseInt(event.target.value).toLocaleString();
            });
            pcSlider.addEventListener('change', (event) => { // Update on release
                particleCount = parseInt(event.target.value);
                initParticles(); 
            });

            // Wave Potential Strength
            const wpsSlider = document.getElementById('wavePotentialStrengthSlider');
            const wpsValue = document.getElementById('wavePotentialStrengthValue');
            wpsSlider.value = simConfig.wavePotentialStrength;
            wpsValue.textContent = simConfig.wavePotentialStrength.toFixed(3);
            wpsSlider.addEventListener('input', (event) => {
                simConfig.wavePotentialStrength = parseFloat(event.target.value);
                wpsValue.textContent = simConfig.wavePotentialStrength.toFixed(3);
            });

            // Particle Mass
            const pmSlider = document.getElementById('particleMassSlider');
            const pmValue = document.getElementById('particleMassValue');
            pmSlider.value = simConfig.particleMass;
            pmValue.textContent = simConfig.particleMass.toFixed(3);
            pmSlider.addEventListener('input', (event) => {
                simConfig.particleMass = parseFloat(event.target.value);
                pmValue.textContent = simConfig.particleMass.toFixed(3);
            });
            
            // Damping Factor
            const dfSlider = document.getElementById('dampingFactorSlider');
            const dfValue = document.getElementById('dampingFactorValue');
            dfSlider.value = simConfig.dampingFactor;
            dfValue.textContent = simConfig.dampingFactor.toFixed(3);
            dfSlider.addEventListener('input', (event) => {
                simConfig.dampingFactor = parseFloat(event.target.value);
                dfValue.textContent = simConfig.dampingFactor.toFixed(3);
            });

            // Wave Params
            const wkxs = document.getElementById('waveKxSlider'); const wkxt = document.getElementById('waveKxValue');
            wkxs.value = simConfig.waveParams.kx; wkxt.textContent = simConfig.waveParams.kx.toFixed(1);
            wkxs.addEventListener('input', (e) => { simConfig.waveParams.kx = parseFloat(e.target.value); wkxt.textContent = simConfig.waveParams.kx.toFixed(1); });

            const wkys = document.getElementById('waveKySlider'); const wkyt = document.getElementById('waveKyValue');
            wkys.value = simConfig.waveParams.ky; wkyt.textContent = simConfig.waveParams.ky.toFixed(1);
            wkys.addEventListener('input', (e) => { simConfig.waveParams.ky = parseFloat(e.target.value); wkyt.textContent = simConfig.waveParams.ky.toFixed(1); });
            
            const wkzs = document.getElementById('waveKzSlider'); const wkzt = document.getElementById('waveKzValue');
            wkzs.value = simConfig.waveParams.kz; wkzt.textContent = simConfig.waveParams.kz.toFixed(1);
            wkzs.addEventListener('input', (e) => { simConfig.waveParams.kz = parseFloat(e.target.value); wkzt.textContent = simConfig.waveParams.kz.toFixed(1); });

            const wos = document.getElementById('waveOmegaSlider'); const wot = document.getElementById('waveOmegaValue');
            wos.value = simConfig.waveParams.omega; wot.textContent = simConfig.waveParams.omega.toFixed(2);
            wos.addEventListener('input', (e) => { simConfig.waveParams.omega = parseFloat(e.target.value); wot.textContent = simConfig.waveParams.omega.toFixed(2); });


            document.getElementById('resetButton').addEventListener('click', () => {
                // Reset simConfig to defaults if needed, or just re-init particles
                simulationTime = 0; // Reset simulation time
                initParticles();
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();
            simulationTime += deltaTime;

            updateParticlesWaveTheory(deltaTime);
            
            controls.update();
            renderer.render(scene, camera);

            // FPS Counter
            const currentTime = performance.now();
            frameCount++;
            if (currentTime >= lastFrameTime + 1000) {
                document.getElementById('fpsCounter').textContent = frameCount;
                frameCount = 0;
                lastFrameTime = currentTime;
            }
            document.getElementById('timeElapsed').textContent = simulationTime.toFixed(1) + 's';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html> 