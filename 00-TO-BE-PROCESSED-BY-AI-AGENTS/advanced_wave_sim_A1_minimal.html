<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Wave Sim (Agent 1 - Minimal)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; background-color: #000; overflow: hidden; }
        #container { width: 100vw; height: 100vh; display: block; }
    </style>
</head>
<body>
    <div id="container"></div>
    <script>
        // ADVANCED WAVE LOGIC WILL BE INSERTED HERE
        let scene, camera, renderer, controls;
        let particleSystem, particlePositions, particleVelocities, particleMaterials;
        
        let PARTICLE_COUNT = 50000;
        const PARTICLE_BOUNDS = 100; // Simulation domain size
        
        // Chladni pattern parameters
        let FREQ = 65.41; // C2
        let MODE_M = 2;
        let MODE_N = 2;
        let MODE_P = 4;
        let FORCE_STRENGTH = 0.5;
        let DAMPING = 0.02;
        let PARTICLE_SIZE = 1.5;

        const DELTA_GRAD = 0.01; // Small delta for numerical gradient calculation

        let lastTime = performance.now();
        let frameCount = 0;

        // --- Chladni Potential Function (3D) ---
        function chladniPotential3D(x, y, z, freq, modeM, modeN, modeP) {
            const k_base = freq / 50.0; 
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r === 0) return 0; 
            const phi = Math.acos(z/r); 
            const theta = Math.atan2(y, x); 
            const angularPartM = Math.cos(modeM * theta);
            const angularPartN = Math.sin(modeN * phi * k_base * 0.5); 
            const radialPartP = Math.sin(modeP * r * k_base * 0.1); 
            let potential = angularPartM * angularPartN * radialPartP;
            potential = isNaN(potential) ? 0 : potential; 
            return Math.max(-1, Math.min(1, potential));
        }

        function gradientChladni3D(x, y, z, freq, modeM, modeN, modeP) {
            const p_dx = (chladniPotential3D(x + DELTA_GRAD, y, z, freq, modeM, modeN, modeP) - chladniPotential3D(x - DELTA_GRAD, y, z, freq, modeM, modeN, modeP)) / (2 * DELTA_GRAD);
            const p_dy = (chladniPotential3D(x, y + DELTA_GRAD, z, freq, modeM, modeN, modeP) - chladniPotential3D(x, y - DELTA_GRAD, z, freq, modeM, modeN, modeP)) / (2 * DELTA_GRAD);
            const p_dz = (chladniPotential3D(x, y, z + DELTA_GRAD, freq, modeM, modeN, modeP) - chladniPotential3D(x, y, z - DELTA_GRAD, freq, modeM, modeN, modeP)) / (2 * DELTA_GRAD);
            return new THREE.Vector3(p_dx, p_dy, p_dz);
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.008); // Darker fog

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(0, 50, 150);
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 500;
            controls.maxPolarAngle = Math.PI;

            initParticles();
            
            // No complex UI for this minimal version, direct control via vars if needed for testing
            // setupUIListeners(); 

            window.addEventListener('resize', onWindowResize, false);
            console.log("Minimal Advanced Wave Simulation Initialized.");
        }

        function initParticles() {
            if (particleSystem) scene.remove(particleSystem);

            const geometry = new THREE.BufferGeometry();
            particlePositions = new Float32Array(PARTICLE_COUNT * 3);
            particleVelocities = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const color = new THREE.Color();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const r_init = PARTICLE_BOUNDS * Math.cbrt(Math.random());
                const theta_init = Math.random() * Math.PI * 2;
                const phi_init = Math.acos(2 * Math.random() - 1);
                particlePositions[i * 3] = r_init * Math.sin(phi_init) * Math.cos(theta_init);
                particlePositions[i * 3 + 1] = r_init * Math.sin(phi_init) * Math.sin(theta_init);
                particlePositions[i * 3 + 2] = r_init * Math.cos(phi_init);
                particleVelocities[i * 3] = (Math.random() - 0.5) * 0.1;
                particleVelocities[i * 3 + 1] = (Math.random() - 0.5) * 0.1;
                particleVelocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
                color.setHSL(i / PARTICLE_COUNT, 0.7, 0.6);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            particleMaterials = new THREE.PointsMaterial({
                size: PARTICLE_SIZE,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 0.8,
                blending: THREE.AdditiveBlending,
                depthWrite: false 
            });

            particleSystem = new THREE.Points(geometry, particleMaterials);
            scene.add(particleSystem);
        }
        
        function updateParticles(deltaTime) {
            if (!particleSystem || !particlePositions || !particleVelocities) return;
            const positions = particleSystem.geometry.attributes.position.array;
            const timeScale = deltaTime * 30; 

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3, iy = i * 3 + 1, iz = i * 3 + 2;
                let x = positions[ix], y = positions[iy], z = positions[iz];
                let vx = particleVelocities[ix], vy = particleVelocities[iy], vz = particleVelocities[iz];

                const potential = chladniPotential3D(x, y, z, FREQ, MODE_M, MODE_N, MODE_P);
                const gradP = gradientChladni3D(x, y, z, FREQ, MODE_M, MODE_N, MODE_P);
                let ax = -FORCE_STRENGTH * potential * gradP.x;
                let ay = -FORCE_STRENGTH * potential * gradP.y;
                let az = -FORCE_STRENGTH * potential * gradP.z;
                ax -= DAMPING * vx;
                ay -= DAMPING * vy;
                az -= DAMPING * vz;
                vx += ax * timeScale;
                vy += ay * timeScale;
                vz += az * timeScale;
                x += vx * timeScale;
                y += vy * timeScale;
                z += vz * timeScale;

                if (x < -PARTICLE_BOUNDS || x > PARTICLE_BOUNDS) { vx *= -0.5; x = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, x)); }
                if (y < -PARTICLE_BOUNDS || y > PARTICLE_BOUNDS) { vy *= -0.5; y = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, y)); }
                if (z < -PARTICLE_BOUNDS || z > PARTICLE_BOUNDS) { vz *= -0.5; z = Math.max(-PARTICLE_BOUNDS, Math.min(PARTICLE_BOUNDS, z)); }
                
                positions[ix] = x;
                positions[iy] = y;
                positions[iz] = z;
                particleVelocities[ix] = vx;
                particleVelocities[iy] = vy;
                particleVelocities[iz] = vz;
            }
            particleSystem.geometry.attributes.position.needsUpdate = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000; 
            lastTime = currentTime; // Update lastTime here
            // FPS counter can be added here if needed
            updateParticles(deltaTime);
            controls.update(); 
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // No UI listeners for minimal version for now
        // function setupUIListeners() { ... }
        // function updateModeStat(){ ... }

        init();
        animate();
    </script>
</body>
</html> 