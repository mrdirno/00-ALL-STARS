<!DOCTYPE html>
<!--
    Resonance is All You Need: Non-linear Wave Filament Simulation
    Concept & Transformation by Agent 1 (Gemini 2.5 Pro) based on 'emergent_wave_phenomena.html'.
    Original Concept & Implementation for base structure by:
    - Aldrin Payopay (Lead Researcher & Visionary)
    - Claude Opus 4 (AI Research Assistant & Code Architect) 
    - Gemini 2.5 Pro (AI Research Assistant & Mathematical Modeling)
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, Agent 1">
    <meta name="description" content="Non-linear Wave Filament Simulation - Advanced cosmic structure formation model. Original research by Aldrin Payopay with AI Assistants, transformed by Agent 1.">
    <meta name="keywords" content="Aldrin Payopay, wave packets, non-linear interaction, cosmic filaments, structure formation, gravitational waves, resonance, chaos theory, Agent 1">
    <meta name="creator" content="Aldrin Payopay (Human Researcher), Claude Opus 4 (AI Assistant), Gemini 2.5 Pro (AI Assistant), Agent 1 (AI Transformation)">
    <title>Non-linear Wave Filament Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script> 
    <script src="https://cdn.jsdelivr.net/npm/three/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* CSS Styling - Unchanged from base */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif; 
            background: #000000; 
            color: #ffffff;
            overflow: hidden; 
            position: relative;
        }
        #container { 
            width: 100vw; 
            height: 100vh; 
            display: block;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%); 
        }
        .ui-panel {
            position: absolute;
            background: rgba(25, 25, 45, 0.15); 
            backdrop-filter: blur(25px) saturate(180%);
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            border: 1px solid rgba(100, 100, 200, 0.15); 
            border-radius: 20px;
            padding: 24px;
            box-shadow: 
                0 20px 50px rgba(0, 0, 0, 0.4), 
                inset 0 1px 0 rgba(255, 255, 255, 0.05); 
            transition: all 0.3s ease;
        }
        .ui-panel:hover {
            background: rgba(35, 35, 55, 0.2);
            box-shadow: 
                0 25px 60px rgba(0, 0, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        #controls-panel { 
            top: 20px; 
            left: 20px; 
            width: 380px; /* Adjusted width for new controls */
            z-index: 10;
            opacity: 0;
            transform: translateX(-20px);
            animation: slideInLeft 0.6s ease forwards;
            animation-delay: 0.3s;
            max-height: calc(100vh - 40px); 
            overflow-y: auto; 
            padding-right: 10px; 
        }
        #controls-panel::-webkit-scrollbar { width: 8px; }
        #controls-panel::-webkit-scrollbar-track { background: rgba(25, 25, 45, 0.1); border-radius: 10px;}
        #controls-panel::-webkit-scrollbar-thumb { background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 10px; border: 1px solid rgba(25, 25, 45, 0.2); }
        #controls-panel::-webkit-scrollbar-thumb:hover { background: linear-gradient(135deg, #9F50E8 0%, #5D1DE0 100%); }
        #controls-panel { scrollbar-width: thin; scrollbar-color: #8A2BE2 rgba(25, 25, 45, 0.1); }
        @keyframes slideInLeft { to { opacity: 1; transform: translateX(0); } }
        #stats-bar { 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(20px);
            padding: 16px 32px;
            z-index: 10;
            display: flex;
            gap: 24px;
            justify-content: center;
            align-items: center;
            opacity: 0;
            animation: slideInUp 0.6s ease forwards;
            animation-delay: 0.5s;
        }
        @keyframes slideInUp { to { opacity: 1; transform: translateX(-50%) translateY(0); } }
        .stat-item { display: flex; flex-direction: column; align-items: center; gap: 4px; }
        .stat-label { font-size: 0.75rem; color: rgba(200, 200, 255, 0.6); text-transform: uppercase; letter-spacing: 0.05em; }
        .stat-value { font-size: 1.25rem; font-weight: 600; color: #fff; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; } 
        .control-group { margin-bottom: 20px; }
        #controls-panel .control-group { padding-right: 14px; }
        #controls-panel h2 { padding-right: 14px; }
        .control-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; font-size: 0.875rem; font-weight: 500; color: rgba(220, 220, 255, 0.9); text-transform: uppercase; letter-spacing: 0.05em; }
        .control-group label[title] { cursor: help; }
        .control-value { font-size: 1rem; color: #8A2BE2; font-weight: 600; }
        .control-group small { display: block; color: rgba(200, 200, 255, 0.5); font-size: 0.75rem; font-weight: 400; text-transform: none; letter-spacing: normal; margin-top: -8px; margin-bottom: 12px; }
        .info-icon { font-size: 0.7em; color: rgba(138, 43, 226, 0.7); font-weight: 400; margin-left: 8px; cursor: help; transition: color 0.2s ease, transform 0.2s ease; display: inline-block; }
        .info-icon:hover { color: rgba(138, 43, 226, 1); transform: scale(1.1); }
        input[type="range"] { width: 100%; height: 6px; background: rgba(200, 200, 255, 0.15); border-radius: 3px; outline: none; -webkit-appearance: none; cursor: pointer; transition: background 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); transition: all 0.3s ease; }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 4px 20px rgba(138, 43, 226, 0.8); }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border-radius: 50%; cursor: pointer; border: none; box-shadow: 0 2px 10px rgba(138, 43, 226, 0.5); }
        select, .ui-input-number { width: 100%; padding: 12px 16px; background: rgba(35, 35, 55, 0.1); border: 1px solid rgba(100, 100, 200, 0.2); border-radius: 12px; color: #fff; font-size: 0.875rem; font-weight: 500; cursor: pointer; outline: none; transition: all 0.3s ease; -moz-appearance: textfield; /* Firefox */ }
        select:hover, .ui-input-number:hover { background: rgba(45, 45, 65, 0.15); border-color: rgba(120, 120, 220, 0.3); }
        select:focus, .ui-input-number:focus { border-color: #8A2BE2; box-shadow: 0 0 0 3px rgba(138, 43, 226, 0.2); }
        .ui-input-number::-webkit-outer-spin-button,
        .ui-input-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        button { width: 100%; padding: 14px 20px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 12px; color: white; font-size: 0.875rem; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.05em; position: relative; overflow: hidden; }
        button::before { content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.15); transition: left 0.5s ease; }
        button:hover::before { left: 100%; }
        button:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(138, 43, 226, 0.4); }
        button:active { transform: translateY(0); }
        button.active { background: linear-gradient(135deg, #CF63CF 0%, #f5576c 100%); } 
        h2 { font-size: 1.5rem; font-weight: 700; margin-bottom: 24px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-align: center; letter-spacing: -0.02em; }
        #initialization-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, #101020 0%, #000000 100%);
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            z-index: 1000; padding: 20px;
        }
        .init-content { text-align: center; max-width: 600px; animation: fadeInScale 0.8s ease; }
        @keyframes fadeInScale { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        .init-title { font-size: 2.8rem; font-weight: 800; margin-bottom: 16px; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); -webkit-background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -0.03em; line-height: 1.2; }
        .init-subtitle { font-size: 1.2rem; color: rgba(220, 220, 255, 0.7); margin-bottom: 40px; font-weight: 300; }
        #start-button { padding: 18px 48px; font-size: 1.125rem; background: linear-gradient(135deg, #8A2BE2 0%, #4A00E0 100%); border: none; border-radius: 30px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-transform: uppercase; letter-spacing: 0.1em; box-shadow: 0 10px 40px rgba(138, 43, 226, 0.4); position: relative; overflow: hidden; }
        #start-button:hover { transform: translateY(-3px); box-shadow: 0 15px 50px rgba(138, 43, 226, 0.6); }
        #start-button:disabled { background: #2a2a2a; cursor: not-allowed; box-shadow: none; }
        #status-message { color: rgba(200, 200, 255, 0.6); margin-top: 20px; font-size: 0.875rem; }
        #error-message { color: #f87171; margin-top: 15px; font-weight: 500; }
        .loading-dots { display: inline-flex; gap: 4px; }
        .dot { width: 8px; height: 8px; background: #8A2BE2; border-radius: 50%; animation: loadingDot 1.4s ease-in-out infinite; }
        .dot:nth-child(2) { animation-delay: 0.2s; }
        .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes loadingDot { 0%, 80%, 100% { transform: scale(0.8); opacity: 0.5; } 40% { transform: scale(1.2); opacity: 1; } }
        .sound-indicator { position: absolute; top: 20px; right: 20px; width: 60px; height: 60px; z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.7s; }
        @keyframes fadeIn { to { opacity: 1; } }
        .sound-waves { position: relative; width: 100%; height: 100%; }
        .wave { position: absolute; border: 2px solid rgba(138, 43, 226, 0.6); border-radius: 50%; opacity: 0; animation: soundWave 2s ease-out infinite; }
        .wave:nth-child(2) { animation-delay: 0.5s; } .wave:nth-child(3) { animation-delay: 1s; }
        @keyframes soundWave { 0% { width: 20px; height: 20px; top: 20px; left: 20px; opacity: 1; } 100% { width: 60px; height: 60px; top: 0; left: 0; opacity: 0; } }
        .sound-icon { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 24px; height: 24px; fill: #8A2BE2; }
        .instructions { position: absolute; bottom: 20px; right: 20px; background: rgba(25, 25, 45, 0.1); backdrop-filter: blur(15px); padding: 16px 20px; border-radius: 12px; border: 1px solid rgba(100, 100, 200, 0.1); font-size: 0.75rem; color: rgba(200, 200, 255, 0.7); z-index: 10; opacity: 0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.9s; }
        .research-watermark { position: fixed; bottom: 5px; left: 5px; font-size: 8px; color: rgba(138, 43, 226, 0.1); z-index: 1; pointer-events: none; font-family: monospace; transform: rotate(-90deg); transform-origin: 0 0; }
        .research-watermark div { white-space: nowrap; }
        .pulse-indicator { width: 20px; height: 20px; background-color: #8A2BE2; border-radius: 50%; transition: all 0.3s ease; }
        .pulse-active { animation: pulseAnim 0.7s ease-out; }
        @keyframes pulseAnim { 0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0.7); } 50% { transform: scale(1.5); box-shadow: 0 0 10px 15px rgba(138, 43, 226, 0); } 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(138, 43, 226, 0); } }
        #fullscreen-button {
            position: absolute;
            top: 20px;
            right: 100px; /* Adjusted to make space for sound indicator */
            padding: 10px 15px;
            background: rgba(25, 25, 45, 0.2);
            border: 1px solid rgba(100, 100, 200, 0.15);
            color: white;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.8rem;
            z-index: 10;
            opacity:0; animation: fadeIn 0.6s ease forwards; animation-delay: 0.8s;
        }
         #fullscreen-button:hover { background: rgba(35, 35, 55, 0.3); }
    </style>
</head>
<body>
    <div id="container"></div>

    <div id="initialization-overlay">
        <div class="init-content">
            <div class="init-title">Non-linear Wave Filament Simulation</div>
            <div class="init-subtitle">Exploring cosmic structure via interacting wave packets and chaotic dynamics. <br>A conceptual model by Agent 1.</div>
            <button id="start-button">Initialize Simulation</button>
            <div id="status-message">Loading assets... <span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span></div>
            <div id="error-message" style="display:none;"></div>
        </div>
    </div>
    
    <div id="controls-panel" class="ui-panel">
        <h2>Wave Packet Parameters</h2>
        <div class="control-group">
            <label for="frequencySlider">Base Frequency: <span id="frequencyValue" class="control-value">5.0</span> Hz <span class="info-icon" title="Base frequency of the wave packets.">ℹ️</span></label>
            <input type="range" id="frequencySlider" min="0.1" max="30" step="0.1" value="5.0">
            <small>Adjusts the fundamental frequency of all wave packets.</small>
        </div>
        <div class="control-group">
            <label for="amplitudeSlider">Base Amplitude: <span id="amplitudeValue" class="control-value">1.5</span> <span class="info-icon" title="Strength of the wave packet displacement force.">ℹ️</span></label>
            <input type="range" id="amplitudeSlider" min="0.0" max="5.0" step="0.01" value="1.5">
            <small>Controls the intensity of the wave packet effects.</small>
        </div>
        <div class="control-group">
            <label for="numWavePacketsSlider">Num Wave Packets: <span id="numWavePacketsValue" class="control-value">3</span> <span class="info-icon" title="Number of active wave packets in the simulation. Requires re-init.">ℹ️</span></label>
            <input type="range" id="numWavePacketsSlider" min="1" max="10" step="1" value="3">
            <small>More packets create complex interference. Re-initialization needed.</small>
        </div>
        <div class="control-group">
            <label for="packetRadiusSlider">Packet Radius: <span id="packetRadiusValue" class="control-value">100</span> <span class="info-icon" title="Effective radius of influence for each wave packet.">ℹ️</span></label>
            <input type="range" id="packetRadiusSlider" min="20" max="300" step="5" value="100">
            <small>Defines the spatial extent of each wave packet's influence.</small>
        </div>
         <div class="control-group">
            <label for="nonLinearCouplingSlider">Non-linear Coupling: <span id="nonLinearCouplingValue" class="control-value">0.1</span> <span class="info-icon" title="Strength of non-linear interaction term between overlapping packets.">ℹ️</span></label>
            <input type="range" id="nonLinearCouplingSlider" min="0.0" max="1.0" step="0.01" value="0.1">
            <small>Controls how strongly overlapping wave packets interact non-linearly.</small>
        </div>
        <div class="control-group">
            <label for="waveformSelect">Waveform: <span id="waveformValue" class="control-value">Sine</span> <span class="info-icon" title="Shape of the fundamental wave in packets.">ℹ️</span></label>
            <select id="waveformSelect">
                <option value="sine" selected>Sine Wave</option>
                <option value="square">Square Wave</option>
                <option value="triangle">Triangle Wave</option>
                <option value="sawtooth">Sawtooth Wave</option>
                <option value="gaussianpulse">Gaussian Pulse</option> <!-- Added Gaussian -->
            </select>
            <small>Modifies the basic wave shape within packets.</small>
        </div>
        <div class="control-group">
            <label for="chaosStrengthSlider">Filament Chaos (K): <span id="chaosStrengthValue" class="control-value">0.3</span> <span class="info-icon" title="Strength of chaotic perturbation (K parameter in Chirikov map) applied to particle motion along filaments.">ℹ️</span></label>
            <input type="range" id="chaosStrengthSlider" min="0.0" max="2.0" step="0.01" value="0.3">
            <small>Controls chaotic motion of particles within filamentary structures.</small>
        </div>

        <h2>Particle & System</h2>
        <div class="control-group">
            <label for="particleCountSlider">Particle Count: <span id="particleCountValue" class="control-value">50000</span> <span class="info-icon" title="Total number of particles in the simulation. Requires re-initialization.">ℹ️</span></label>
            <input type="range" id="particleCountSlider" min="1000" max="250000" step="1000" value="50000">
            <small>More particles create denser structures but reduce performance.</small>
        </div>
         <div class="control-group">
            <label for="particlesToSpawnSlider">Spawn Rate / Frame: <span id="particlesToSpawnValue" class="control-value">500</span> <span class="info-icon" title="Number of particles to (re)initialize per animation frame.">ℹ️</span></label>
            <input type="range" id="particlesToSpawnSlider" min="0" max="5000" step="100" value="500">
            <small>Higher rates fill the volume faster or make patterns more dynamic if particles are reset.</small>
        </div>
        <div class="control-group">
            <label for="heartRateSlider">Heartbeat Rate (BPM): <span id="heartRateValue" class="control-value">60</span> <span class="info-icon" title="Simulated cosmic heartbeat, influences force pulses and audio.">ℹ️</span></label>
            <input type="range" id="heartRateSlider" min="30" max="180" step="1" value="60">
            <small>Frequency of the central 'heartbeat' pulse.</small>
        </div>
        <div class="control-group">
            <label for="gravityStrengthSlider">Gravity Strength: <span id="gravityStrengthValue" class="control-value">50</span> <span class="info-icon" title="Strength of the central gravitational pull.">ℹ️</span></label>
            <input type="range" id="gravityStrengthSlider" min="0" max="1000" step="10" value="50">
            <small>Adjusts the force of the central supermassive black hole analog.</small>
        </div>
        <div class="control-group">
            <button id="reinitializeButton">Re-initialize Simulation</button>
            <small>Applies particle count and wave packet changes, resets the simulation.</small>
        </div>
        <div class="control-group">
            <button id="toggleSoundButton">Sound: ON</button>
            <small>Toggles audio feedback for wave patterns and pulses.</small>
        </div>
        <div class="control-group">
            <button id="stopButton">Stop Simulation</button>
             <small>Pauses the animation and audio.</small>
        </div>
    </div>

    <div id="stats-bar" class="ui-panel">
        <div class="stat-item">
            <span class="stat-label">Particles</span>
            <span id="particleStat" class="stat-value">50000</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">FPS</span>
            <span id="fpsStat" class="stat-value">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Time</span>
            <span id="timeStat" class="stat-value">0.0s</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Pulse</span>
            <div id="pulseIndicator" class="pulse-indicator"></div>
        </div>
    </div>

    <div class="sound-indicator">
        <svg class="sound-icon" viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"></path></svg>
        <div class="sound-waves">
            <div class="wave"></div><div class="wave"></div><div class="wave"></div>
        </div>
    </div>
    <button id="fullscreen-button">Fullscreen</button>
    <div class="instructions">Use mouse to orbit, scroll to zoom.</div>
    <div class="research-watermark">
        <div>Aldrin Payopay, Claude Opus 4, Gemini 2.5 Pro, Agent 1 - Resonance is All You Need - Non-Linear Wave Filament Simulation Research. This is a conceptual model. Not representative of peer-reviewed simulation data. For educational and illustrative purposes only.</div>
        <div>Unauthorized reproduction or distribution strictly prohibited. All rights reserved by the original authors and AI collaborators.</div>
    </div>
    
<script>
    let scene, camera, renderer, particles, geometry, material, controls;
    let positions, velocities, accelerations, phases, originalPositions, particleMasses;
    let audioContext, masterGain, bassSynth, cymbalSynth, pulseSynth;
    let lastPulseTime = 0;
    let isSoundInitialized = false;
    let animationFrameId;
    let spawnIndex = 0;
    let particleColorHSL = []; 
    let wavePackets = []; // Array to store wave packet data

    const params = {
        frequency: 5.0, // Base frequency for packets
        amplitude: 1.5, // Base amplitude for packets
        numWavePackets: 3,
        packetRadius: 100.0,
        nonLinearCoupling: 0.1,
        particleCount: 50000,
        particlesToSpawnPerFrame: 500,
        boxSize: 500,
        baseParticleSize: 1.5,
        waveform: 'sine',
        heartRate: 60, 
        gravityStrength: 50, // Reduced default gravity
        chaosStrengthK: 0.3, 
        particleInteraction: false, // Future use
        timeScale: 1.0,
        colorShiftSpeed: 0.01,
        particleOpacity: 0.7,
        maxVelocity: 2.0,
        dampingFactor: 0.98,
        enableRotation: true,
        rotationSpeed: 0.0005,
        showCentralMass: true,
        centralMassSize: 10,
        centralMassColor: 0xffcc00,
        soundEnabled: true,
        useLogFrequency: false,
        frequencyMin: 0.1,
        frequencyMax: 30, // Adjusted max for new frequency slider
        pulseForce: 1.0,
        pulseFrequencyMod: 0.2,
        cameraFov: 60,
        cameraNear: 1,
        cameraFar: 5000,
        cameraInitialPosition: new THREE.Vector3(0, 200, 600),
        backgroundColor: 0x000000,
        particleColorBase: 0x8A2BE2, 
        particleColorSpread: 0.3, 
    };

    // Cached DOM elements
    const frequencySlider = document.getElementById('frequencySlider');
    const frequencyValue = document.getElementById('frequencyValue');
    const amplitudeSlider = document.getElementById('amplitudeSlider');
    const amplitudeValue = document.getElementById('amplitudeValue');
    const numWavePacketsSlider = document.getElementById('numWavePacketsSlider');
    const numWavePacketsValue = document.getElementById('numWavePacketsValue');
    const packetRadiusSlider = document.getElementById('packetRadiusSlider');
    const packetRadiusValue = document.getElementById('packetRadiusValue');
    const nonLinearCouplingSlider = document.getElementById('nonLinearCouplingSlider');
    const nonLinearCouplingValue = document.getElementById('nonLinearCouplingValue');
    const particleCountSlider = document.getElementById('particleCountSlider');
    const particleCountValue = document.getElementById('particleCountValue');
    const particlesToSpawnSlider = document.getElementById('particlesToSpawnSlider');
    const particlesToSpawnValue = document.getElementById('particlesToSpawnValue');
    const waveformSelect = document.getElementById('waveformSelect');
    const waveformValue = document.getElementById('waveformValue');
    const heartRateSlider = document.getElementById('heartRateSlider');
    const heartRateValue = document.getElementById('heartRateValue');
    const gravityStrengthSlider = document.getElementById('gravityStrengthSlider');
    const gravityStrengthValue = document.getElementById('gravityStrengthValue');
    const chaosStrengthSlider = document.getElementById('chaosStrengthSlider');
    const chaosStrengthValue = document.getElementById('chaosStrengthValue');

    const reinitializeButton = document.getElementById('reinitializeButton');
    const toggleSoundButton = document.getElementById('toggleSoundButton');
    const stopButton = document.getElementById('stopButton');
    const particleStat = document.getElementById('particleStat');
    const fpsStat = document.getElementById('fpsStat');
    const timeStat = document.getElementById('timeStat');
    const pulseIndicator = document.getElementById('pulseIndicator');
    let stats;

    document.addEventListener('DOMContentLoaded', () => {
        initControls();
        
        stopButton.addEventListener('click', stopSimulation);
        document.getElementById('start-button').addEventListener('click', async () => {
            document.getElementById('status-message').innerHTML = 'Initializing audio & visual systems... <span class="loading-dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
            document.getElementById('start-button').disabled = true;
            document.getElementById('error-message').style.display = 'none';

            try {
                if (params.soundEnabled && !isSoundInitialized) {
                    await initAudio();
                }
                document.getElementById('initialization-overlay').style.display = 'none';
                document.getElementById('controls-panel').style.opacity = 1;
                document.getElementById('stats-bar').style.opacity = 1;
                document.querySelector('.sound-indicator').style.opacity = params.soundEnabled ? 1: 0;
                document.querySelector('.instructions').style.opacity = 1;
                document.getElementById('fullscreen-button').style.opacity = 1;

                init();
                animate();
            } catch (error) {
                console.error("Initialization failed:", error);
                const errDiv = document.getElementById('error-message');
                errDiv.textContent = `Error: ${error.message}. Please try reloading. If the issue persists, try disabling sound or reducing particle count.`;
                errDiv.style.display = 'block';
                document.getElementById('status-message').textContent = 'Initialization failed.';
                document.getElementById('start-button').disabled = false; 
            }
        });
        document.getElementById('fullscreen-button').addEventListener('click', toggleFullScreen);
        setupInfoIcons();
    });

    function initControls() {
        frequencySlider.addEventListener('input', () => { params.frequency = parseFloat(frequencySlider.value); frequencyValue.textContent = params.frequency.toFixed(1); updateWavePacketProperties(); });
        amplitudeSlider.addEventListener('input', () => { params.amplitude = parseFloat(amplitudeSlider.value); amplitudeValue.textContent = params.amplitude.toFixed(2); updateWavePacketProperties(); });
        numWavePacketsSlider.addEventListener('input', () => { params.numWavePackets = parseInt(numWavePacketsSlider.value); numWavePacketsValue.textContent = params.numWavePackets; /* Needs re-init */ });
        packetRadiusSlider.addEventListener('input', () => { params.packetRadius = parseFloat(packetRadiusSlider.value); packetRadiusValue.textContent = params.packetRadius.toFixed(0); updateWavePacketProperties(); });
        nonLinearCouplingSlider.addEventListener('input', () => { params.nonLinearCoupling = parseFloat(nonLinearCouplingSlider.value); nonLinearCouplingValue.textContent = params.nonLinearCoupling.toFixed(2); });
        
        particleCountSlider.addEventListener('input', () => { params.particleCount = parseInt(particleCountSlider.value); particleCountValue.textContent = params.particleCount; });
        particlesToSpawnSlider.addEventListener('input', () => { params.particlesToSpawnPerFrame = parseInt(particlesToSpawnSlider.value); particlesToSpawnValue.textContent = params.particlesToSpawnPerFrame; });
        waveformSelect.addEventListener('change', () => { params.waveform = waveformSelect.value; waveformValue.textContent = waveformSelect.options[waveformSelect.selectedIndex].text;});
        heartRateSlider.addEventListener('input', () => { params.heartRate = parseInt(heartRateSlider.value); heartRateValue.textContent = params.heartRate; });
        gravityStrengthSlider.addEventListener('input', () => { params.gravityStrength = parseFloat(gravityStrengthSlider.value); gravityStrengthValue.textContent = params.gravityStrength.toFixed(0); });
        chaosStrengthSlider.addEventListener('input', () => { params.chaosStrengthK = parseFloat(chaosStrengthSlider.value); chaosStrengthValue.textContent = params.chaosStrengthK.toFixed(2); });

        reinitializeButton.addEventListener('click', () => {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            init(); 
            animate();
        });
        toggleSoundButton.addEventListener('click', toggleSound);

        updateSlider(frequencySlider, frequencyValue, params.frequency, val => val.toFixed(1));
        updateSlider(amplitudeSlider, amplitudeValue, params.amplitude, val => val.toFixed(2));
        updateSlider(numWavePacketsSlider, numWavePacketsValue, params.numWavePackets, val => parseInt(val));
        updateSlider(packetRadiusSlider, packetRadiusValue, params.packetRadius, val => parseFloat(val).toFixed(0));
        updateSlider(nonLinearCouplingSlider, nonLinearCouplingValue, params.nonLinearCoupling, val => parseFloat(val).toFixed(2));

        updateSlider(particleCountSlider, particleCountValue, params.particleCount, val => parseInt(val));
        updateSlider(particlesToSpawnSlider, particlesToSpawnValue, params.particlesToSpawnPerFrame, val => parseInt(val));
        updateSlider(heartRateSlider, heartRateValue, params.heartRate, val => parseInt(val));
        updateSlider(gravityStrengthSlider, gravityStrengthValue, params.gravityStrength, val => val.toFixed(0));
        updateSlider(chaosStrengthSlider, chaosStrengthValue, params.chaosStrengthK, val => parseFloat(val).toFixed(2));
        
        waveformSelect.value = params.waveform;
        waveformValue.textContent = waveformSelect.options[waveformSelect.selectedIndex].text;
        toggleSoundButton.textContent = params.soundEnabled ? "Sound: ON" : "Sound: OFF";
    }
    
    function updateSlider(slider, display, paramValue, formatFn = val => val) {
        if (slider) {
            slider.value = paramValue;
            if(display) display.textContent = formatFn(paramValue);
        }
    }

    async function initAudio() {
        if (isSoundInitialized || !params.soundEnabled) return;
        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            await audioContext.resume(); 
            masterGain = audioContext.createGain();
            masterGain.gain.value = 0.3;
            masterGain.connect(audioContext.destination);
            bassSynth = new Tone.MonoSynth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.5 }, filterEnvelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.5, baseFrequency: 100, octaves: 3 }}).connect(masterGain);
            cymbalSynth = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1, release: 0.05 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 1 }).connect(masterGain);
            pulseSynth = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.8, attackCurve: "exponential" }}).connect(masterGain);
            isSoundInitialized = true;
            console.log("Audio initialized successfully.");
            document.querySelector('.sound-indicator').style.opacity = 1;
            toggleSoundButton.textContent = "Sound: ON";
        } catch (e) {
            console.error("Error initializing audio:", e);
            params.soundEnabled = false;
            document.querySelector('.sound-indicator').style.opacity = 0;
            toggleSoundButton.textContent = "Sound: OFF (Error)";
            const errDiv = document.getElementById('error-message');
            if (errDiv) { errDiv.textContent = `Audio initialization failed: ${e.message}. Sound will be disabled.`; errDiv.style.display = 'block'; }
        }
    }

    function toggleSound() {
        params.soundEnabled = !params.soundEnabled;
        // ... (rest of toggleSound is same as original)
        toggleSoundButton.textContent = params.soundEnabled ? "Sound: ON" : "Sound: OFF";
        document.querySelector('.sound-indicator').style.opacity = params.soundEnabled ? 1 : 0;
        if (params.soundEnabled && !isSoundInitialized) {
            initAudio().catch(e => console.error("Failed to init audio on toggle:", e));
        } else if (!params.soundEnabled && audioContext && audioContext.state === 'running') {
            audioContext.suspend();
        } else if (params.soundEnabled && audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
    }
    
    function initWavePackets() {
        wavePackets = [];
        const packetSpread = params.boxSize * 0.6; // Spread packets within this range
        for (let i = 0; i < params.numWavePackets; i++) {
            wavePackets.push({
                position: new THREE.Vector3(
                    (Math.random() - 0.5) * packetSpread,
                    (Math.random() - 0.5) * packetSpread,
                    (Math.random() - 0.5) * packetSpread
                ),
                frequency: params.frequency * (0.8 + Math.random() * 0.4), // Vary freq slightly
                amplitude: params.amplitude * (0.8 + Math.random() * 0.4), // Vary amp slightly
                radius: params.packetRadius * (0.7 + Math.random() * 0.6), // Vary radius
                id: i // For tracking interactions
            });
        }
    }
    
    function updateWavePacketProperties() { // Call this when base freq/amp/radius sliders change
        for (let i = 0; i < wavePackets.length; i++) {
            if (wavePackets[i]) { // Ensure packet exists
                 // Re-calculate based on new global params, maintaining some individual variation
                wavePackets[i].frequency = params.frequency * (0.8 + (wavePackets[i].id / params.numWavePackets) * 0.4); 
                wavePackets[i].amplitude = params.amplitude * (0.8 + (wavePackets[i].id / params.numWavePackets) * 0.4);
                wavePackets[i].radius = params.packetRadius * (0.7 + (wavePackets[i].id / params.numWavePackets) * 0.6);
            }
        }
    }

    function init() {
        if (renderer) { 
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            if(renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement);
            renderer.dispose();
            if (geometry) geometry.dispose();
            if (material) material.dispose();
            if (controls) controls.dispose();
        }
        spawnIndex = 0;
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(params.cameraFov, window.innerWidth / window.innerHeight, params.cameraNear, params.cameraFar);
        camera.position.copy(params.cameraInitialPosition);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(params.backgroundColor);
        document.getElementById('container').appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.screenSpacePanning = false;
        controls.minDistance = 50; controls.maxDistance = 2000; controls.enableRotate = params.enableRotation;

        initWavePackets(); // Initialize wave packets

        geometry = new THREE.BufferGeometry();
        positions = new Float32Array(params.particleCount * 3);
        velocities = new Float32Array(params.particleCount * 3);
        accelerations = new Float32Array(params.particleCount * 3);
        phases = new Float32Array(params.particleCount); // For Chirikov map state
        originalPositions = new Float32Array(params.particleCount * 3);
        particleMasses = new Float32Array(params.particleCount);
        const colors = new Float32Array(params.particleCount * 3);
        particleColorHSL = [];

        for (let i = 0; i < params.particleCount; i++) {
            const i3 = i * 3;
            const r = params.boxSize * Math.cbrt(Math.random()); 
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            positions[i3] = originalPositions[i3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i3 + 1] = originalPositions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i3 + 2] = originalPositions[i3 + 2] = r * Math.cos(phi);
            velocities[i3] = (Math.random() - 0.5) * 0.1; velocities[i3 + 1] = (Math.random() - 0.5) * 0.1; velocities[i3 + 2] = (Math.random() - 0.5) * 0.1;
            accelerations[i3] = 0; accelerations[i3+1] = 0; accelerations[i3+2] = 0;
            phases[i] = Math.random() * Math.PI * 2; 
            particleMasses[i] = 0.5 + Math.random() * 0.5;
            const baseHue = (new THREE.Color(params.particleColorBase)).getHSL({h:0,s:0,l:0}).h;
            const hue = (baseHue + (Math.random() - 0.5) * params.particleColorSpread) % 1.0;
            const saturation = 0.6 + Math.random() * 0.4; 
            const lightness = 0.4 + Math.random() * 0.3;
            particleColorHSL.push({h: hue, s: saturation, l: lightness});
            const color = new THREE.Color(); color.setHSL(hue, saturation, lightness);
            colors[i3] = color.r; colors[i3 + 1] = color.g; colors[i3 + 2] = color.b;
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        material = new THREE.PointsMaterial({ size: params.baseParticleSize, vertexColors: true, opacity: params.particleOpacity, transparent: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false });
        particles = new THREE.Points(geometry, material);
        scene.add(particles);
        if(params.showCentralMass) { /* ... (central mass same as original) ... */ 
            const centralMassGeo = new THREE.SphereGeometry(params.centralMassSize, 32, 32);
            const centralMassMat = new THREE.MeshBasicMaterial({ color: params.centralMassColor, wireframe: true });
            const centralMassMesh = new THREE.Mesh(centralMassGeo, centralMassMat);
            scene.add(centralMassMesh);
        }
        window.addEventListener('resize', onWindowResize, false);
        particleStat.textContent = params.particleCount.toLocaleString();
        lastTime = performance.now();
    }

    let lastTime = 0; let timeAccumulator = 0; let frameCount = 0;

    function gaussianFalloff(distance, radius) {
        const sigma = radius / 3; // Make sigma 1/3 of radius for a reasonable falloff
        return Math.exp(-0.5 * (distance * distance) / (sigma * sigma));
    }

    function updateParticles(time) {
        const dt = Math.min(0.016, (time - (lastTime || time)) / 1000) * params.timeScale; 
        lastTime = time;
        timeAccumulator += dt; frameCount++;
        if (timeAccumulator >= 1) { fpsStat.textContent = frameCount; frameCount = 0; timeAccumulator -=1; }
        timeStat.textContent = (audioContext ? audioContext.currentTime.toFixed(1) : (performance.now()/1000).toFixed(1)) + "s";
        const positions = geometry.attributes.position.array;
        const colors = geometry.attributes.color.array;
        const currentTime = (audioContext ? audioContext.currentTime : performance.now() / 1000) * params.timeScale;
        const pulseInterval = 60 / params.heartRate; 
        let currentPulseForce = 0;
        if (currentTime - lastPulseTime >= pulseInterval) { /* ... (pulse logic same as original, but ensure bassSynth check) ... */
            lastPulseTime = currentTime;
            if (params.soundEnabled && pulseSynth && audioContext.state === 'running') {
                pulseSynth.triggerAttackRelease("C2", "8n", audioContext.currentTime);
            }
            pulseIndicator.classList.add('pulse-active');
            setTimeout(() => pulseIndicator.classList.remove('pulse-active'), 700);
            currentPulseForce = params.pulseForce;
            if (params.soundEnabled && bassSynth && audioContext.state === 'running' && bassSynth.frequency) { // Added bassSynth.frequency check
                const baseFreqHz = params.frequency * 10; 
                bassSynth.frequency.setValueAtTime(baseFreqHz * (1 + params.pulseFrequencyMod), audioContext.currentTime);
                bassSynth.frequency.linearRampToValueAtTime(baseFreqHz, audioContext.currentTime + pulseInterval * 0.5);
            }
        }

        const particlesToUpdate = Math.min(params.particleCount, spawnIndex + params.particlesToSpawnPerFrame);
        for (let i = spawnIndex; i < particlesToUpdate; i++) {
            const i3 = i * 3;
            let pX = positions[i3]; let pY = positions[i3+1]; let pZ = positions[i3+2]; // Current particle position
            let particleOriginalX = originalPositions[i3]; 
            let particleOriginalY = originalPositions[i3+1]; 
            let particleOriginalZ = originalPositions[i3+2];

            let totalDisplacementFactor = 0;
            let influences = []; // Store influence of each packet for non-linear term

            for (let j = 0; j < wavePackets.length; j++) {
                const packet = wavePackets[j];
                const dx = pX - packet.position.x;
                const dy = pY - packet.position.y;
                const dz = pZ - packet.position.z;
                const distToPacketCenter = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                let packetInfluence = 0;
                if (distToPacketCenter < packet.radius * 1.5) { // Consider influence slightly beyond radius
                    let waveVal = 0;
                    let phase = distToPacketCenter * packet.frequency * 0.1 - currentTime * packet.frequency;
                    switch (params.waveform) {
                        case 'sine': waveVal = Math.sin(phase); break;
                        case 'square': waveVal = Math.sign(Math.sin(phase)); break;
                        case 'triangle': waveVal = Math.asin(Math.sin(phase)) * (2 / Math.PI); break;
                        case 'sawtooth': waveVal = 2 * ((phase / (2 * Math.PI)) - Math.floor(0.5 + (phase / (2 * Math.PI)))); break;
                        case 'gaussianpulse': // A non-oscillating pulse, decays with distance
                             waveVal = Math.exp(-0.5 * Math.pow(distToPacketCenter / (packet.radius * 0.3), 2)); // Gaussian shape
                             // Make it time-dependent if it's a traveling pulse, for now static envelope
                             break;
                    }
                    packetInfluence = packet.amplitude * waveVal * gaussianFalloff(distToPacketCenter, packet.radius);
                    totalDisplacementFactor += packetInfluence;
                    influences.push(packetInfluence);
                } else {
                    influences.push(0);
                }
            }

            // Non-linear interaction term (simple pairwise product sum)
            if (params.nonLinearCoupling > 0 && influences.length > 1) {
                for (let j = 0; j < influences.length; j++) {
                    for (let k = j + 1; k < influences.length; k++) {
                        totalDisplacementFactor += params.nonLinearCoupling * influences[j] * influences[k];
                    }
                }
            }
            
            let r_orig = Math.sqrt(particleOriginalX*particleOriginalX + particleOriginalY*particleOriginalY + particleOriginalZ*particleOriginalZ);
            if (r_orig < 1e-5) r_orig = 1e-5;
            let theta_orig = Math.acos(particleOriginalZ / r_orig); 
            let phi_orig = Math.atan2(particleOriginalY, particleOriginalX);   

            let p_phi = phases[i]; 
            p_phi = p_phi + params.chaosStrengthK * Math.sin(phi_orig); 
            let new_phi = phi_orig + p_phi; 
            phases[i] = p_phi; 
            
            let final_r = r_orig + totalDisplacementFactor; 
            
            let targetX = final_r * Math.sin(theta_orig) * Math.cos(new_phi);
            let targetY = final_r * Math.sin(theta_orig) * Math.sin(new_phi);
            let targetZ = final_r * Math.cos(theta_orig);

            let dx_g = -pX; let dy_g = -pY; let dz_g = -pZ;
            let distSq_g = dx_g*dx_g + dy_g*dy_g + dz_g*dz_g;
            let dist_g = Math.sqrt(distSq_g);
            let force_g = (params.gravityStrength / (distSq_g + 1000)) * particleMasses[i]; 

            accelerations[i3] = force_g * (dx_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetX - pX) * 0.1; 
            accelerations[i3+1] = force_g * (dy_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetY - pY) * 0.1;
            accelerations[i3+2] = force_g * (dz_g / (dist_g < 1e-5 ? 1e-5 : dist_g)) + (targetZ - pZ) * 0.1;
            
            if (currentPulseForce > 0 && dist_g > 1e-5) { /* ... (pulse acceleration same as original) ... */
                accelerations[i3] += currentPulseForce * (pX / dist_g) / particleMasses[i];
                accelerations[i3+1] += currentPulseForce * (pY / dist_g) / particleMasses[i];
                accelerations[i3+2] += currentPulseForce * (pZ / dist_g) / particleMasses[i];
            }

            velocities[i3] += accelerations[i3] * dt; velocities[i3 + 1] += accelerations[i3 + 1] * dt; velocities[i3 + 2] += accelerations[i3 + 2] * dt;
            velocities[i3] *= params.dampingFactor; velocities[i3 + 1] *= params.dampingFactor; velocities[i3 + 2] *= params.dampingFactor;
            const speed = Math.sqrt(velocities[i3]*velocities[i3] + velocities[i3+1]*velocities[i3+1] + velocities[i3+2]*velocities[i3+2]);
            if (speed > params.maxVelocity) { /* ... (speed limit same as original) ... */
                const factor = params.maxVelocity / speed;
                velocities[i3] *= factor; velocities[i3 + 1] *= factor; velocities[i3 + 2] *= factor;
            }
            positions[i3] += velocities[i3] * dt; positions[i3 + 1] += velocities[i3 + 1] * dt; positions[i3 + 2] += velocities[i3 + 2] * dt;
            
            const currentSpeedNormalized = Math.min(1, speed / params.maxVelocity); /* ... (color update same as original) ... */
            const {h, s, l} = particleColorHSL[i];
            const newLightness = Math.max(0.1, Math.min(0.9, l * (0.5 + currentSpeedNormalized * 0.5)));
            const newHue = (h + currentTime * params.colorShiftSpeed * 0.1) % 1.0;
            const tempColor = new THREE.Color(); tempColor.setHSL(newHue, s, newLightness);
            colors[i3] = tempColor.r; colors[i3 + 1] = tempColor.g; colors[i3 + 2] = tempColor.b;
        }
        spawnIndex = particlesToUpdate % params.particleCount;
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.color.needsUpdate = true;
    }

    function animate(time) {
        animationFrameId = requestAnimationFrame(animate);
        controls.update(); 
        updateParticles(time);
        renderer.render(scene, camera);
    }

    function onWindowResize() { /* ... (same as original) ... */
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function stopSimulation() { /* ... (same as original) ... */
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
            console.log("Simulation stopped.");
            if (params.soundEnabled && audioContext && audioContext.state === 'running') {
                audioContext.suspend(); 
            }
        } else { 
            if (params.soundEnabled && audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            animate();
             console.log("Simulation resumed.");
        }
    }
    function setupInfoIcons() { /* ... (same as original) ... */
        document.querySelectorAll('.info-icon').forEach(icon => {
            icon.addEventListener('mouseenter', (e) => {
                const tooltipText = e.target.getAttribute('title');
                if (!tooltipText) return;
                let tooltip = document.getElementById('info-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div'); tooltip.id = 'info-tooltip';
                    tooltip.style.position = 'absolute'; tooltip.style.background = 'rgba(10, 10, 20, 0.9)';
                    tooltip.style.color = '#eee'; tooltip.style.padding = '8px 12px';
                    tooltip.style.borderRadius = '8px'; tooltip.style.fontSize = '0.8rem';
                    tooltip.style.maxWidth = '250px'; tooltip.style.zIndex = '1001';
                    tooltip.style.border = '1px solid rgba(138, 43, 226, 0.3)';
                    tooltip.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';
                    tooltip.style.backdropFilter = 'blur(5px)';
                    document.body.appendChild(tooltip);
                }
                tooltip.textContent = tooltipText; tooltip.style.display = 'block';
                const rect = e.target.getBoundingClientRect();
                tooltip.style.left = `${rect.left + rect.width / 2 - tooltip.offsetWidth / 2}px`;
                tooltip.style.top = `${rect.bottom + 8}px`;
                if (tooltip.offsetLeft < 0) tooltip.style.left = '5px';
                if (tooltip.offsetTop + tooltip.offsetHeight > window.innerHeight) tooltip.style.top = `${rect.top - tooltip.offsetHeight - 8}px`;
            });
            icon.addEventListener('mouseleave', () => {
                let tooltip = document.getElementById('info-tooltip');
                if (tooltip) tooltip.style.display = 'none';
            });
        });
    }
    function toggleFullScreen() { /* ... (same as original) ... */
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
            });
        } else {
            if (document.exitFullscreen) { document.exitFullscreen(); }
        }
    }
</script>
</body>
</html> 