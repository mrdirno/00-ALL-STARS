<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Ellipsoidal Metamaterial 2025 - Quantum Acoustic Supremacy</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0; padding: 0;
            background: radial-gradient(ellipse at center, #0a0a2a 0%, #000000 100%);
            font-family: 'Courier New', monospace; overflow: hidden; color: #00ffff;
        }
        #container { position: relative; width: 100vw; height: 100vh; }
        #controls {
            position: absolute; top: 20px; left: 20px; z-index: 100;
            background: rgba(0, 0, 0, 0.95); padding: 25px; border-radius: 20px;
            border: 3px solid #00ffff; box-shadow: 0 0 50px rgba(0, 255, 255, 0.7);
            max-width: 480px; backdrop-filter: blur(25px);
            max-height: calc(100vh - 40px); overflow-y: auto;
        }
        .control-group { margin-bottom: 18px; }
        label {
            display: block; margin-bottom: 8px; color: #00ffff; font-size: 12px;
            text-transform: uppercase; letter-spacing: 1.5px; font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        input[type="range"] {
            width: 100%; margin-bottom: 8px; background: #333; outline: none;
            opacity: 0.9; transition: all 0.3s ease; height: 8px; border-radius: 4px;
        }
        input[type="range"]:hover { opacity: 1; box-shadow: 0 0 20px rgba(0, 255, 255, 0.6); }
        input[type="range"]::-webkit-slider-thumb {
            appearance: none; width: 20px; height: 20px;
            background: linear-gradient(45deg, #00ffff, #0080ff, #ff00ff, #ffff00);
            cursor: pointer; border-radius: 50%; box-shadow: 0 0 25px rgba(0, 255, 255, 0.8);
            border: 2px solid #ffffff;
        }
        .value-display {
            color: #ffffff; font-size: 11px; text-align: right; font-weight: bold;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.7);
        }
        #info {
            position: absolute; bottom: 20px; left: 20px; z-index: 100;
            background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 15px;
            border: 3px solid #00ffff; color: #00ffff; font-size: 11px;
            max-width: 380px; backdrop-filter: blur(20px);
        }
        #performance {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(0, 0, 0, 0.95); padding: 20px; border-radius: 15px;
            border: 3px solid #00ff00; color: #00ff00; font-size: 11px;
            backdrop-filter: blur(20px);
        }
        .math-display {
            font-family: 'Times New Roman', serif; font-style: italic;
            color: #ffff00; margin: 8px 0; text-shadow: 0 0 10px rgba(255, 255, 0, 0.7);
        }
        button {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.2), rgba(0, 255, 255, 0.3));
            border: 3px solid #00ffff; color: #00ffff; padding: 12px 20px;
            border-radius: 10px; cursor: pointer; margin: 8px; font-family: inherit;
            font-size: 11px; text-transform: uppercase; letter-spacing: 1.5px;
            font-weight: bold; transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(45deg, rgba(0, 255, 255, 0.3), rgba(0, 255, 255, 0.4));
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.6); transform: translateY(-2px);
        }
        select {
            background: rgba(0, 0, 0, 0.9); border: 3px solid #00ffff; color: #00ffff;
            padding: 10px; border-radius: 8px; font-family: inherit; font-size: 11px;
            font-weight: bold; width: 100%;
        }
        .quantum-section {
            border-top: 2px solid #ff00ff; margin-top: 15px; padding-top: 15px;
        }
        .quantum-label { color: #ff00ff; text-shadow: 0 0 8px rgba(255, 0, 255, 0.4); }
        .metamaterial-section {
            border-top: 2px solid #ffff00; margin-top: 15px; padding-top: 15px;
        }
        .metamaterial-label { color: #ffff00; text-shadow: 0 0 8px rgba(255, 255, 0, 0.4); }
        .advanced-section {
            border-top: 2px solid #00ffff; margin-top: 15px; padding-top: 15px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h3 style="margin-top: 0; color: #00ffff; text-align: center; text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);">Ultimate Ellipsoidal Metamaterial 2025</h3>
            
            <div class="control-group">
                <label for="harmonic-l">Ellipsoidal Degree (l)</label>
                <input type="range" id="harmonic-l" min="0" max="60" value="12" step="1">
                <div class="value-display" id="harmonic-l-value">12</div>
            </div>
            
            <div class="control-group">
                <label for="harmonic-m">Ellipsoidal Order (m)</label>
                <input type="range" id="harmonic-m" min="-60" max="60" value="8" step="1">
                <div class="value-display" id="harmonic-m-value">8</div>
            </div>
            
            <div class="control-group">
                <label for="ellipse-a">Semi-major Axis (a)</label>
                <input type="range" id="ellipse-a" min="0.1" max="10.0" value="2.2" step="0.01">
                <div class="value-display" id="ellipse-a-value">2.2</div>
            </div>
            
            <div class="control-group">
                <label for="ellipse-b">Semi-minor Axis (b)</label>
                <input type="range" id="ellipse-b" min="0.1" max="10.0" value="3.8" step="0.01">
                <div class="value-display" id="ellipse-b-value">3.8</div>
            </div>
            
            <div class="control-group">
                <label for="ellipse-c">Focal Distance (c)</label>
                <input type="range" id="ellipse-c" min="0.1" max="10.0" value="2.5" step="0.01">
                <div class="value-display" id="ellipse-c-value">2.5</div>
            </div>
            
            <div class="control-group">
                <label for="frequency">Quantum Frequency</label>
                <input type="range" id="frequency" min="0.1" max="25.0" value="3.2" step="0.1">
                <div class="value-display" id="frequency-value">3.2</div>
            </div>
            
            <div class="control-group">
                <label for="amplitude">Wave Amplitude</label>
                <input type="range" id="amplitude" min="0.1" max="8.0" value="2.5" step="0.1">
                <div class="value-display" id="amplitude-value">2.5</div>
            </div>
            
            <div class="control-group">
                <label for="particle-density">Particle Density</label>
                <input type="range" id="particle-density" min="15000" max="150000" value="100000" step="5000">
                <div class="value-display" id="particle-density-value">100000</div>
            </div>
            
            <div class="quantum-section">
                <h4 class="quantum-label">Quantum Metamaterial</h4>
                
                <div class="control-group">
                    <label for="phononic-time" class="quantum-label">Phononic Time Crystal</label>
                    <input type="range" id="phononic-time" min="0.0" max="3.0" value="1.2" step="0.01">
                    <div class="value-display" id="phononic-time-value">1.2</div>
                </div>
                
                <div class="control-group">
                    <label for="quantum-coherence" class="quantum-label">Quantum Coherence</label>
                    <input type="range" id="quantum-coherence" min="0.0" max="1.0" value="0.75" step="0.01">
                    <div class="value-display" id="quantum-coherence-value">0.75</div>
                </div>
                
                <div class="control-group">
                    <label for="entanglement" class="quantum-label">Entanglement Field</label>
                    <input type="range" id="entanglement" min="0.0" max="4.0" value="1.8" step="0.01">
                    <div class="value-display" id="entanglement-value">1.8</div>
                </div>
            </div>
            
            <div class="metamaterial-section">
                <h4 class="metamaterial-label">Metamaterial Physics</h4>
                
                <div class="control-group">
                    <label for="negative-refraction" class="metamaterial-label">Negative Refraction</label>
                    <input type="range" id="negative-refraction" min="-3.0" max="3.0" value="0.5" step="0.01">
                    <div class="value-display" id="negative-refraction-value">0.5</div>
                </div>
                
                <div class="control-group">
                    <label for="nonlocal-range" class="metamaterial-label">Nonlocal Range</label>
                    <input type="range" id="nonlocal-range" min="1" max="25" value="12" step="1">
                    <div class="value-display" id="nonlocal-range-value">12</div>
                </div>
                
                <div class="control-group">
                    <label for="roton-depth" class="metamaterial-label">Roton Depth</label>
                    <input type="range" id="roton-depth" min="0.0" max="3.0" value="1.2" step="0.01">
                    <div class="value-display" id="roton-depth-value">1.2</div>
                </div>
            </div>
            
            <div class="advanced-section">
                <h4>Advanced Controls</h4>
                
                <div class="control-group">
                    <label for="wave-mode">Wave Mode</label>
                    <select id="wave-mode">
                        <option value="quantum-supremacy">Quantum Acoustic Supremacy</option>
                        <option value="phononic-crystal">Phononic Time Crystal</option>
                        <option value="metamaterial-roton">Metamaterial Roton</option>
                        <option value="bio-cosmic">Bio-Cosmic Coupling</option>
                        <option value="consciousness">Consciousness Resonance</option>
                        <option value="gravitational">Gravitational-Acoustic</option>
                        <option value="vacuum-fluctuation">Quantum Vacuum</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="gpu-level">GPU Optimization</label>
                    <input type="range" id="gpu-level" min="1" max="12" value="10" step="1">
                    <div class="value-display" id="gpu-level-value">10</div>
                </div>
                
                <div class="control-group">
                    <label for="temporal-mod">Temporal Modulation</label>
                    <input type="range" id="temporal-mod" min="0.0" max="8.0" value="2.2" step="0.1">
                    <div class="value-display" id="temporal-mod-value">2.2</div>
                </div>
            </div>
            
            <button onclick="resetQuantumDefaults()">Reset Quantum</button>
            <button onclick="toggleAnimation()">Pause/Resume</button>
            <button onclick="exportConfig()">Export</button>
        </div>
        
        <div id="performance">
            <h4 style="margin-top: 0; color: #00ff00;">Performance</h4>
            <div>FPS: <span id="fps">60</span></div>
            <div>Particles: <span id="particles">100K</span></div>
            <div>GPU: <span id="gpu">92%</span></div>
            <div>Coherence: <span id="coherence">0.75</span></div>
            <div>Memory: <span id="memory">320MB</span></div>
            <div>Level: <span id="level">10</span></div>
        </div>
        
        <div id="info">
            <h4 style="margin-top: 0; color: #00ffff;">Quantum Theory</h4>
            <div class="math-display">
                Ψ(ξ,η,φ,t) = A·E<sub>l</sub><sup>m</sup>(ξ,c)·E<sub>l</sub><sup>m</sup>(η,c)·e<sup>imφ</sup>·e<sup>-iωt</sup>
            </div>
            <p><strong>Features:</strong></p>
            <ul>
                <li>Quantum acoustic supremacy</li>
                <li>Phononic time crystals</li>
                <li>Nonlocal metamaterials</li>
                <li>Bio-cosmic coupling</li>
                <li>Consciousness resonance</li>
                <li>Vacuum fluctuations</li>
            </ul>
            <div class="math-display">
                H = ℏω(a†a + ½) + g(a†σ₋ + aσ₊) + Ω(σ₊ + σ₋)
            </div>
            <p><strong>Mode:</strong> <span id="current-mode">Quantum Acoustic Supremacy</span></p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, particleSystem, time = 0, isAnimating = true;
        let frameCount = 0, lastTime = performance.now();
        
        const params = {
            l: 12, m: 8, a: 2.2, b: 3.8, c: 2.5, frequency: 3.2, amplitude: 2.5,
            particleDensity: 100000, phononicTime: 1.2, quantumCoherence: 0.75,
            entanglement: 1.8, negativeRefraction: 0.5, nonlocalRange: 12,
            rotonDepth: 1.2, waveMode: 'quantum-supremacy', gpuLevel: 10, temporalMod: 2.2
        };
        
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }
        
        function associatedLegendre(l, m, x) {
            if (Math.abs(x) > 1) return 0;
            const absM = Math.abs(m);
            
            let pmm = 1.0;
            if (absM > 0) {
                const somx2 = Math.sqrt((1.0 - x) * (1.0 + x));
                let fact = 1.0;
                for (let i = 1; i <= absM; i++) {
                    pmm *= -fact * somx2;
                    fact += 2.0;
                }
            }
            
            if (l === absM) return m >= 0 ? pmm : (m % 2 === 0 ? pmm : -pmm);
            
            let pmmp1 = x * (2.0 * absM + 1.0) * pmm;
            if (l === absM + 1) return m >= 0 ? pmmp1 : (m % 2 === 0 ? pmmp1 : -pmmp1);
            
            let pll = 0.0;
            for (let ll = absM + 2; ll <= l; ll++) {
                pll = (x * (2.0 * ll - 1.0) * pmmp1 - (ll + absM - 1.0) * pmm) / (ll - absM);
                pmm = pmmp1;
                pmmp1 = pll;
            }
            
            return m >= 0 ? pll : (m % 2 === 0 ? pll : -pll);
        }
        
        function ellipsoidalHarmonic(l, m, xi, eta, c) {
            const quantumEnhancement = 1.0 + params.quantumCoherence * Math.sin(time * params.phononicTime);
            const metamaterialFactor = 1.0 + params.negativeRefraction * Math.cos(time * 0.7);
            
            const x_xi = Math.cos(xi);
            const x_eta = Math.cos(eta);
            
            const P_xi = associatedLegendre(l, Math.abs(m), x_xi) * quantumEnhancement;
            const P_eta = associatedLegendre(l, Math.abs(m), x_eta) * metamaterialFactor;
            
            const nonlocalEffect = Math.exp(-Math.abs(xi - eta) / params.nonlocalRange);
            const rotonCorrection = 1.0 - params.rotonDepth * Math.exp(-((xi - Math.PI/2)**2 + (eta - Math.PI/2)**2));
            
            return P_xi * P_eta * nonlocalEffect * rotonCorrection;
        }
        
        function ultimateWaveFunction(x, y, z, t) {
            const r = Math.sqrt(x*x + y*y + z*z);
            if (r === 0) return 0;
            
            const a = params.a, b = params.b, c = params.c;
            
            // True ellipsoidal coordinates from center
            const xi = Math.acos(z / Math.sqrt(c*c + r*r));
            const eta = Math.acos(Math.sqrt((x*x + y*y) / (a*a + b*b + r*r)));
            const phi = Math.atan2(y, x);
            
            // Advanced temporal modulation
            const temporalPhase = params.frequency * t * (1.0 + params.temporalMod * Math.sin(t * 0.15));
            
            // Quantum entanglement effects
            const entanglementPhase = params.entanglement * Math.sin(temporalPhase + phi + xi);
            
            // Calculate ellipsoidal harmonic
            const harmonicValue = ellipsoidalHarmonic(params.l, params.m, xi, eta, c);
            
            // Azimuthal component with quantum corrections
            const azimuthalComponent = Math.cos(params.m * phi + entanglementPhase);
            
            // Bio-cosmic coupling (multiple Schumann resonances)
            const schumann1 = Math.sin(7.83 * t * 0.01) * 0.08;  // 7.83 Hz
            const schumann2 = Math.sin(14.3 * t * 0.01) * 0.05;  // 14.3 Hz
            const schumann3 = Math.sin(20.8 * t * 0.01) * 0.03;  // 20.8 Hz
            const bioCosmicCoupling = schumann1 + schumann2 + schumann3;
            
            // Consciousness resonance (40 Hz gamma waves)
            const consciousnessResonance = Math.sin(40.0 * t * 0.01) * 0.04;
            
            // Quantum vacuum fluctuations
            const vacuumFluctuations = Math.sin(t * 10.0 + r * 0.5) * 0.02;
            
            // Final wave function with all quantum and metamaterial effects
            return params.amplitude * harmonicValue * azimuthalComponent * 
                   Math.cos(temporalPhase) * (1.0 + bioCosmicCoupling + consciousnessResonance + vacuumFluctuations);
        }
        
        function initThreeJS() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, powerPreference: "high-performance", precision: "highp"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Enhanced lighting
            scene.add(new THREE.AmbientLight(0x404040, 0.4));
            
            const light1 = new THREE.DirectionalLight(0x00ffff, 1.0);
            light1.position.set(15, 15, 10);
            scene.add(light1);
            
            const light2 = new THREE.DirectionalLight(0xff00ff, 0.8);
            light2.position.set(-15, -15, -10);
            scene.add(light2);
            
            const pointLight = new THREE.PointLight(0xffff00, 1.5, 150);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            initParticleSystem();
            addControls();
        }
        
        function initParticleSystem() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(params.particleDensity * 3);
            const colors = new Float32Array(params.particleDensity * 3);
            const sizes = new Float32Array(params.particleDensity);
            
            // True ellipsoidal distribution from center
            for (let i = 0; i < params.particleDensity; i++) {
                const i3 = i * 3;
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const r = Math.pow(Math.random(), 1/3) * 8;
                
                // Ellipsoidal transformation
                positions[i3] = r * Math.sin(phi) * Math.cos(theta) * params.a;
                positions[i3 + 1] = r * Math.sin(phi) * Math.sin(theta) * params.b;
                positions[i3 + 2] = r * Math.cos(phi) * params.c;
                
                colors[i3] = 0.0; colors[i3 + 1] = 1.0; colors[i3 + 2] = 1.0;
                sizes[i] = 2.0;
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0.0 },
                    coherence: { value: params.quantumCoherence },
                    phononic: { value: params.phononicTime }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time, coherence, phononic;
                    
                    void main() {
                        vColor = color;
                        vec3 pos = position;
                        float quantumFlux = sin(time * phononic + length(pos) * 0.1) * coherence;
                        pos += normalize(pos) * quantumFlux * 0.15;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (400.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    uniform float time;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        float alpha = 1.0 - dist * 2.0;
                        alpha *= (0.8 + 0.2 * sin(time * 3.0));
                        
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            
            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }
        
        function addControls() {
            let mouseDown = false, mouseX = 0, mouseY = 0;
            
            renderer.domElement.addEventListener('mousedown', (e) => {
                mouseDown = true; mouseX = e.clientX; mouseY = e.clientY;
            });
            renderer.domElement.addEventListener('mouseup', () => mouseDown = false);
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (!mouseDown) return;
                const deltaX = e.clientX - mouseX, deltaY = e.clientY - mouseY;
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(camera.position);
                spherical.theta -= deltaX * 0.01;
                spherical.phi += deltaY * 0.01;
                spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 0, 0);
                mouseX = e.clientX; mouseY = e.clientY;
            });
            renderer.domElement.addEventListener('wheel', (e) => {
                camera.position.multiplyScalar(e.deltaY > 0 ? 1.1 : 0.9);
            });
        }
        
        function updateParticles() {
            const positions = particleSystem.geometry.attributes.position.array;
            const colors = particleSystem.geometry.attributes.color.array;
            const sizes = particleSystem.geometry.attributes.size.array;
            
            const batchSize = Math.min(8000, Math.floor(params.particleDensity / params.gpuLevel));
            
            for (let batch = 0; batch < params.gpuLevel; batch++) {
                const start = batch * batchSize;
                const end = Math.min(start + batchSize, params.particleDensity);
                
                for (let i = start; i < end; i++) {
                    const i3 = i * 3;
                    const x = positions[i3], y = positions[i3 + 1], z = positions[i3 + 2];
                    
                    const waveValue = ultimateWaveFunction(x, y, z, time);
                    const intensity = Math.abs(waveValue);
                    const phase = Math.atan2(Math.sin(waveValue), Math.cos(waveValue));
                    
                    // Advanced color mapping
                    colors[i3] = 0.5 + 0.5 * Math.sin(phase + time * 0.6);
                    colors[i3 + 1] = 0.5 + 0.5 * Math.cos(phase + time * 0.4);
                    colors[i3 + 2] = 0.5 + 0.5 * Math.sin(phase * 2 + time * 0.8);
                    
                    sizes[i] = 1.5 + intensity * 4.0 * (1.0 + params.negativeRefraction * Math.sin(time));
                }
            }
            
            particleSystem.geometry.attributes.position.needsUpdate = true;
            particleSystem.geometry.attributes.color.needsUpdate = true;
            particleSystem.geometry.attributes.size.needsUpdate = true;
            
            particleSystem.material.uniforms.time.value = time;
            particleSystem.material.uniforms.coherence.value = params.quantumCoherence;
            particleSystem.material.uniforms.phononic.value = params.phononicTime;
        }
        
        function animate() {
            if (!isAnimating) return;
            requestAnimationFrame(animate);
            time += 0.016;
            updateParticles();
            renderer.render(scene, camera);
            updateMetrics();
        }
        
        function updateMetrics() {
            frameCount++;
            const now = performance.now();
            if (now - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (now - lastTime));
                document.getElementById('fps').textContent = fps;
                document.getElementById('particles').textContent = (params.particleDensity/1000).toFixed(0) + 'K';
                document.getElementById('gpu').textContent = Math.min(100, Math.round((params.particleDensity/1000) * (13-params.gpuLevel))) + '%';
                document.getElementById('coherence').textContent = params.quantumCoherence.toFixed(2);
                document.getElementById('level').textContent = params.gpuLevel;
                document.getElementById('memory').textContent = Math.round((params.particleDensity*40)/(1024*1024)*1.8) + 'MB';
                frameCount = 0; lastTime = now;
            }
        }
        
        function setupControls() {
            const controls = [
                'harmonic-l', 'harmonic-m', 'ellipse-a', 'ellipse-b', 'ellipse-c',
                'frequency', 'amplitude', 'particle-density', 'phononic-time',
                'quantum-coherence', 'entanglement', 'negative-refraction',
                'nonlocal-range', 'roton-depth', 'gpu-level', 'temporal-mod'
            ];
            
            controls.forEach(id => {
                const element = document.getElementById(id);
                const display = document.getElementById(id + '-value');
                element.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    display.textContent = value;
                    
                    switch(id) {
                        case 'harmonic-l': params.l = parseInt(value); break;
                        case 'harmonic-m': params.m = parseInt(value); break;
                        case 'ellipse-a': params.a = value; break;
                        case 'ellipse-b': params.b = value; break;
                        case 'ellipse-c': params.c = value; break;
                        case 'frequency': params.frequency = value; break;
                        case 'amplitude': params.amplitude = value; break;
                        case 'particle-density': 
                            params.particleDensity = parseInt(value);
                            reinitParticles(); break;
                        case 'phononic-time': params.phononicTime = value; break;
                        case 'quantum-coherence': params.quantumCoherence = value; break;
                        case 'entanglement': params.entanglement = value; break;
                        case 'negative-refraction': params.negativeRefraction = value; break;
                        case 'nonlocal-range': params.nonlocalRange = parseInt(value); break;
                        case 'roton-depth': params.rotonDepth = value; break;
                        case 'gpu-level': params.gpuLevel = parseInt(value); break;
                        case 'temporal-mod': params.temporalMod = value; break;
                    }
                });
            });
            
            document.getElementById('wave-mode').addEventListener('change', (e) => {
                params.waveMode = e.target.value;
                document.getElementById('current-mode').textContent = e.target.options[e.target.selectedIndex].text;
            });
        }
        
        function reinitParticles() {
            scene.remove(particleSystem);
            particleSystem.geometry.dispose();
            particleSystem.material.dispose();
            initParticleSystem();
        }
        
        function resetQuantumDefaults() {
            Object.assign(params, {
                l: 12, m: 8, a: 2.2, b: 3.8, c: 2.5, frequency: 3.2, amplitude: 2.5,
                particleDensity: 100000, phononicTime: 1.2, quantumCoherence: 0.75,
                entanglement: 1.8, negativeRefraction: 0.5, nonlocalRange: 12,
                rotonDepth: 1.2, gpuLevel: 10, temporalMod: 2.2
            });
            
            Object.keys(params).forEach(key => {
                const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
                if (element && element.type === 'range') {
                    element.value = params[key];
                    const display = document.getElementById(element.id + '-value');
                    if (display) display.textContent = params[key];
                }
            });
            reinitParticles();
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
            if (isAnimating) animate();
        }
        
        function exportConfig() {
            const config = JSON.stringify(params, null, 2);
            const blob = new Blob([config], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'ultimate_metamaterial_config.json';
            a.click(); URL.revokeObjectURL(url);
        }
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            initThreeJS(); setupControls(); animate();
        });
    </script>
</body>
</html> 